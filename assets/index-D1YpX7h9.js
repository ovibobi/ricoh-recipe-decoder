(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Nn(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const K={},st=[],Ae=()=>{},Xr=()=>!1,Jt=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),Dn=e=>e.startsWith("onUpdate:"),oe=Object.assign,Wn=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},Kr=Object.prototype.hasOwnProperty,V=(e,t)=>Kr.call(e,t),q=Array.isArray,ot=e=>Zt(e)==="[object Map]",Wi=e=>Zt(e)==="[object Set]",G=e=>typeof e=="function",ne=e=>typeof e=="string",ze=e=>typeof e=="symbol",Q=e=>e!==null&&typeof e=="object",Ri=e=>(Q(e)||G(e))&&G(e.then)&&G(e.catch),Li=Object.prototype.toString,Zt=e=>Li.call(e),Yr=e=>Zt(e).slice(8,-1),Pi=e=>Zt(e)==="[object Object]",Rn=e=>ne(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,ht=Nn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Qt=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},Jr=/-(\w)/g,Be=Qt(e=>e.replace(Jr,(t,n)=>n?n.toUpperCase():"")),Zr=/\B([A-Z])/g,nt=Qt(e=>e.replace(Zr,"-$1").toLowerCase()),qi=Qt(e=>e.charAt(0).toUpperCase()+e.slice(1)),$n=Qt(e=>e?`on${qi(e)}`:""),Ve=(e,t)=>!Object.is(e,t),fn=(e,...t)=>{for(let n=0;n<e.length;n++)e[n](...t)},vn=(e,t,n,i=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:i,value:n})},Qr=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let ii;const en=()=>ii||(ii=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Ln(e){if(q(e)){const t={};for(let n=0;n<e.length;n++){const i=e[n],r=ne(i)?is(i):Ln(i);if(r)for(const s in r)t[s]=r[s]}return t}else if(ne(e)||Q(e))return e}const es=/;(?![^(]*\))/g,ts=/:([^]+)/,ns=/\/\*[^]*?\*\//g;function is(e){const t={};return e.replace(ns,"").split(es).forEach(n=>{if(n){const i=n.split(ts);i.length>1&&(t[i[0].trim()]=i[1].trim())}}),t}function pe(e){let t="";if(ne(e))t=e;else if(q(e))for(let n=0;n<e.length;n++){const i=pe(e[n]);i&&(t+=i+" ")}else if(Q(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}const rs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",ss=Nn(rs);function Gi(e){return!!e||e===""}const ki=e=>!!(e&&e.__v_isRef===!0),te=e=>ne(e)?e:e==null?"":q(e)||Q(e)&&(e.toString===Li||!G(e.toString))?ki(e)?te(e.value):JSON.stringify(e,Mi,2):String(e),Mi=(e,t)=>ki(t)?Mi(e,t.value):ot(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((n,[i,r],s)=>(n[un(i,s)+" =>"]=r,n),{})}:Wi(t)?{[`Set(${t.size})`]:[...t.values()].map(n=>un(n))}:ze(t)?un(t):Q(t)&&!q(t)&&!Pi(t)?String(t):t,un=(e,t="")=>{var n;return ze(e)?`Symbol(${(n=e.description)!=null?n:t})`:e};/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ce;class Ui{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=ce,!t&&ce&&(this.index=(ce.scopes||(ce.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].pause();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].resume();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].resume()}}run(t){if(this._active){const n=ce;try{return ce=this,t()}finally{ce=n}}}on(){++this._on===1&&(this.prevScope=ce,ce=this)}off(){this._on>0&&--this._on===0&&(ce=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let n,i;for(n=0,i=this.effects.length;n<i;n++)this.effects[n].stop();for(this.effects.length=0,n=0,i=this.cleanups.length;n<i;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,i=this.scopes.length;n<i;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function os(e){return new Ui(e)}function ls(){return ce}let X;const dn=new WeakSet;class Vi{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,ce&&ce.active&&ce.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,dn.has(this)&&(dn.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Hi(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,ri(this),ji(this);const t=X,n=ve;X=this,ve=!0;try{return this.fn()}finally{zi(this),X=t,ve=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)Gn(t);this.deps=this.depsTail=void 0,ri(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?dn.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){bn(this)&&this.run()}get dirty(){return bn(this)}}let Bi=0,yt,xt;function Hi(e,t=!1){if(e.flags|=8,t){e.next=xt,xt=e;return}e.next=yt,yt=e}function Pn(){Bi++}function qn(){if(--Bi>0)return;if(xt){let t=xt;for(xt=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;yt;){let t=yt;for(yt=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(i){e||(e=i)}t=n}}if(e)throw e}function ji(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function zi(e){let t,n=e.depsTail,i=n;for(;i;){const r=i.prevDep;i.version===-1?(i===n&&(n=r),Gn(i),as(i)):t=i,i.dep.activeLink=i.prevActiveLink,i.prevActiveLink=void 0,i=r}e.deps=t,e.depsTail=n}function bn(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Xi(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Xi(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===Et)||(e.globalVersion=Et,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!bn(e))))return;e.flags|=2;const t=e.dep,n=X,i=ve;X=e,ve=!0;try{ji(e);const r=e.fn(e._value);(t.version===0||Ve(r,e._value))&&(e.flags|=128,e._value=r,t.version++)}catch(r){throw t.version++,r}finally{X=n,ve=i,zi(e),e.flags&=-3}}function Gn(e,t=!1){const{dep:n,prevSub:i,nextSub:r}=e;if(i&&(i.nextSub=r,e.prevSub=void 0),r&&(r.prevSub=i,e.nextSub=void 0),n.subs===e&&(n.subs=i,!i&&n.computed)){n.computed.flags&=-5;for(let s=n.computed.deps;s;s=s.nextDep)Gn(s,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function as(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let ve=!0;const Ki=[];function Le(){Ki.push(ve),ve=!1}function Pe(){const e=Ki.pop();ve=e===void 0?!0:e}function ri(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=X;X=void 0;try{t()}finally{X=n}}}let Et=0;class $s{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class kn{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){if(!X||!ve||X===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==X)n=this.activeLink=new $s(X,this),X.deps?(n.prevDep=X.depsTail,X.depsTail.nextDep=n,X.depsTail=n):X.deps=X.depsTail=n,Yi(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const i=n.nextDep;i.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=i),n.prevDep=X.depsTail,n.nextDep=void 0,X.depsTail.nextDep=n,X.depsTail=n,X.deps===n&&(X.deps=i)}return n}trigger(t){this.version++,Et++,this.notify(t)}notify(t){Pn();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{qn()}}}function Yi(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let i=t.deps;i;i=i.nextDep)Yi(i)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),e.dep.subs=e}}const Fn=new WeakMap,tt=Symbol(""),En=Symbol(""),Tt=Symbol("");function re(e,t,n){if(ve&&X){let i=Fn.get(e);i||Fn.set(e,i=new Map);let r=i.get(n);r||(i.set(n,r=new kn),r.map=i,r.key=n),r.track()}}function Re(e,t,n,i,r,s){const o=Fn.get(e);if(!o){Et++;return}const l=a=>{a&&a.trigger()};if(Pn(),t==="clear")o.forEach(l);else{const a=q(e),m=a&&Rn(n);if(a&&n==="length"){const u=Number(i);o.forEach((c,h)=>{(h==="length"||h===Tt||!ze(h)&&h>=u)&&l(c)})}else switch((n!==void 0||o.has(void 0))&&l(o.get(n)),m&&l(o.get(Tt)),t){case"add":a?m&&l(o.get("length")):(l(o.get(tt)),ot(e)&&l(o.get(En)));break;case"delete":a||(l(o.get(tt)),ot(e)&&l(o.get(En)));break;case"set":ot(e)&&l(o.get(tt));break}}qn()}function it(e){const t=U(e);return t===e?t:(re(t,"iterate",Tt),xe(e)?t:t.map(ie))}function tn(e){return re(e=U(e),"iterate",Tt),e}const fs={__proto__:null,[Symbol.iterator](){return cn(this,Symbol.iterator,ie)},concat(...e){return it(this).concat(...e.map(t=>q(t)?it(t):t))},entries(){return cn(this,"entries",e=>(e[1]=ie(e[1]),e))},every(e,t){return De(this,"every",e,t,void 0,arguments)},filter(e,t){return De(this,"filter",e,t,n=>n.map(ie),arguments)},find(e,t){return De(this,"find",e,t,ie,arguments)},findIndex(e,t){return De(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return De(this,"findLast",e,t,ie,arguments)},findLastIndex(e,t){return De(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return De(this,"forEach",e,t,void 0,arguments)},includes(...e){return pn(this,"includes",e)},indexOf(...e){return pn(this,"indexOf",e)},join(e){return it(this).join(e)},lastIndexOf(...e){return pn(this,"lastIndexOf",e)},map(e,t){return De(this,"map",e,t,void 0,arguments)},pop(){return pt(this,"pop")},push(...e){return pt(this,"push",e)},reduce(e,...t){return si(this,"reduce",e,t)},reduceRight(e,...t){return si(this,"reduceRight",e,t)},shift(){return pt(this,"shift")},some(e,t){return De(this,"some",e,t,void 0,arguments)},splice(...e){return pt(this,"splice",e)},toReversed(){return it(this).toReversed()},toSorted(e){return it(this).toSorted(e)},toSpliced(...e){return it(this).toSpliced(...e)},unshift(...e){return pt(this,"unshift",e)},values(){return cn(this,"values",ie)}};function cn(e,t,n){const i=tn(e),r=i[t]();return i!==e&&!xe(e)&&(r._next=r.next,r.next=()=>{const s=r._next();return s.value&&(s.value=n(s.value)),s}),r}const us=Array.prototype;function De(e,t,n,i,r,s){const o=tn(e),l=o!==e&&!xe(e),a=o[t];if(a!==us[t]){const c=a.apply(e,s);return l?ie(c):c}let m=n;o!==e&&(l?m=function(c,h){return n.call(this,ie(c),h,e)}:n.length>2&&(m=function(c,h){return n.call(this,c,h,e)}));const u=a.call(o,m,i);return l&&r?r(u):u}function si(e,t,n,i){const r=tn(e);let s=n;return r!==e&&(xe(e)?n.length>3&&(s=function(o,l,a){return n.call(this,o,l,a,e)}):s=function(o,l,a){return n.call(this,o,ie(l),a,e)}),r[t](s,...i)}function pn(e,t,n){const i=U(e);re(i,"iterate",Tt);const r=i[t](...n);return(r===-1||r===!1)&&Bn(n[0])?(n[0]=U(n[0]),i[t](...n)):r}function pt(e,t,n=[]){Le(),Pn();const i=U(e)[t].apply(e,n);return qn(),Pe(),i}const ds=Nn("__proto__,__v_isRef,__isVue"),Ji=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(ze));function cs(e){ze(e)||(e=String(e));const t=U(this);return re(t,"has",e),t.hasOwnProperty(e)}class Zi{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,i){if(n==="__v_skip")return t.__v_skip;const r=this._isReadonly,s=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return s;if(n==="__v_raw")return i===(r?s?Fs:nr:s?tr:er).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(i)?t:void 0;const o=q(t);if(!r){let a;if(o&&(a=fs[n]))return a;if(n==="hasOwnProperty")return cs}const l=Reflect.get(t,n,se(t)?t:i);return(ze(n)?Ji.has(n):ds(n))||(r||re(t,"get",n),s)?l:se(l)?o&&Rn(n)?l:l.value:Q(l)?r?ir(l):Un(l):l}}class Qi extends Zi{constructor(t=!1){super(!1,t)}set(t,n,i,r){let s=t[n];if(!this._isShallow){const a=He(s);if(!xe(i)&&!He(i)&&(s=U(s),i=U(i)),!q(t)&&se(s)&&!se(i))return a?!1:(s.value=i,!0)}const o=q(t)&&Rn(n)?Number(n)<t.length:V(t,n),l=Reflect.set(t,n,i,se(t)?t:r);return t===U(r)&&(o?Ve(i,s)&&Re(t,"set",n,i):Re(t,"add",n,i)),l}deleteProperty(t,n){const i=V(t,n);t[n];const r=Reflect.deleteProperty(t,n);return r&&i&&Re(t,"delete",n,void 0),r}has(t,n){const i=Reflect.has(t,n);return(!ze(n)||!Ji.has(n))&&re(t,"has",n),i}ownKeys(t){return re(t,"iterate",q(t)?"length":tt),Reflect.ownKeys(t)}}class ps extends Zi{constructor(t=!1){super(!0,t)}set(t,n){return!0}deleteProperty(t,n){return!0}}const ms=new Qi,gs=new ps,hs=new Qi(!0);const Tn=e=>e,Rt=e=>Reflect.getPrototypeOf(e);function ys(e,t,n){return function(...i){const r=this.__v_raw,s=U(r),o=ot(s),l=e==="entries"||e===Symbol.iterator&&o,a=e==="keys"&&o,m=r[e](...i),u=n?Tn:t?Bt:ie;return!t&&re(s,"iterate",a?En:tt),{next(){const{value:c,done:h}=m.next();return h?{value:c,done:h}:{value:l?[u(c[0]),u(c[1])]:u(c),done:h}},[Symbol.iterator](){return this}}}}function Lt(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function xs(e,t){const n={get(r){const s=this.__v_raw,o=U(s),l=U(r);e||(Ve(r,l)&&re(o,"get",r),re(o,"get",l));const{has:a}=Rt(o),m=t?Tn:e?Bt:ie;if(a.call(o,r))return m(s.get(r));if(a.call(o,l))return m(s.get(l));s!==o&&s.get(r)},get size(){const r=this.__v_raw;return!e&&re(U(r),"iterate",tt),Reflect.get(r,"size",r)},has(r){const s=this.__v_raw,o=U(s),l=U(r);return e||(Ve(r,l)&&re(o,"has",r),re(o,"has",l)),r===l?s.has(r):s.has(r)||s.has(l)},forEach(r,s){const o=this,l=o.__v_raw,a=U(l),m=t?Tn:e?Bt:ie;return!e&&re(a,"iterate",tt),l.forEach((u,c)=>r.call(s,m(u),m(c),o))}};return oe(n,e?{add:Lt("add"),set:Lt("set"),delete:Lt("delete"),clear:Lt("clear")}:{add(r){!t&&!xe(r)&&!He(r)&&(r=U(r));const s=U(this);return Rt(s).has.call(s,r)||(s.add(r),Re(s,"add",r,r)),this},set(r,s){!t&&!xe(s)&&!He(s)&&(s=U(s));const o=U(this),{has:l,get:a}=Rt(o);let m=l.call(o,r);m||(r=U(r),m=l.call(o,r));const u=a.call(o,r);return o.set(r,s),m?Ve(s,u)&&Re(o,"set",r,s):Re(o,"add",r,s),this},delete(r){const s=U(this),{has:o,get:l}=Rt(s);let a=o.call(s,r);a||(r=U(r),a=o.call(s,r)),l&&l.call(s,r);const m=s.delete(r);return a&&Re(s,"delete",r,void 0),m},clear(){const r=U(this),s=r.size!==0,o=r.clear();return s&&Re(r,"clear",void 0,void 0),o}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=ys(r,e,t)}),n}function Mn(e,t){const n=xs(e,t);return(i,r,s)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?i:Reflect.get(V(n,r)&&r in i?n:i,r,s)}const _s={get:Mn(!1,!1)},vs={get:Mn(!1,!0)},bs={get:Mn(!0,!1)};const er=new WeakMap,tr=new WeakMap,nr=new WeakMap,Fs=new WeakMap;function Es(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Ts(e){return e.__v_skip||!Object.isExtensible(e)?0:Es(Yr(e))}function Un(e){return He(e)?e:Vn(e,!1,ms,_s,er)}function Ss(e){return Vn(e,!1,hs,vs,tr)}function ir(e){return Vn(e,!0,gs,bs,nr)}function Vn(e,t,n,i,r){if(!Q(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=Ts(e);if(s===0)return e;const o=r.get(e);if(o)return o;const l=new Proxy(e,s===2?i:n);return r.set(e,l),l}function lt(e){return He(e)?lt(e.__v_raw):!!(e&&e.__v_isReactive)}function He(e){return!!(e&&e.__v_isReadonly)}function xe(e){return!!(e&&e.__v_isShallow)}function Bn(e){return e?!!e.__v_raw:!1}function U(e){const t=e&&e.__v_raw;return t?U(t):e}function rr(e){return!V(e,"__v_skip")&&Object.isExtensible(e)&&vn(e,"__v_skip",!0),e}const ie=e=>Q(e)?Un(e):e,Bt=e=>Q(e)?ir(e):e;function se(e){return e?e.__v_isRef===!0:!1}function Ht(e){return ws(e,!1)}function ws(e,t){return se(e)?e:new Os(e,t)}class Os{constructor(t,n){this.dep=new kn,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?t:U(t),this._value=n?t:ie(t),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(t){const n=this._rawValue,i=this.__v_isShallow||xe(t)||He(t);t=i?t:U(t),Ve(t,n)&&(this._rawValue=t,this._value=i?t:ie(t),this.dep.trigger())}}function Is(e){return se(e)?e.value:e}const Cs={get:(e,t,n)=>t==="__v_raw"?e:Is(Reflect.get(e,t,n)),set:(e,t,n,i)=>{const r=e[t];return se(r)&&!se(n)?(r.value=n,!0):Reflect.set(e,t,n,i)}};function sr(e){return lt(e)?e:new Proxy(e,Cs)}class As{constructor(t,n,i){this.fn=t,this.setter=n,this._value=void 0,this.dep=new kn(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Et-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=i}notify(){if(this.flags|=16,!(this.flags&8)&&X!==this)return Hi(this,!0),!0}get value(){const t=this.dep.track();return Xi(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter&&this.setter(t)}}function Ns(e,t,n=!1){let i,r;return G(e)?i=e:(i=e.get,r=e.set),new As(i,r,n)}const Pt={},jt=new WeakMap;let Qe;function Ds(e,t=!1,n=Qe){if(n){let i=jt.get(n);i||jt.set(n,i=[]),i.push(e)}}function Ws(e,t,n=K){const{immediate:i,deep:r,once:s,scheduler:o,augmentJob:l,call:a}=n,m=E=>r?E:xe(E)||r===!1||r===0?Ue(E,1):Ue(E);let u,c,h,f,p=!1,y=!1;if(se(e)?(c=()=>e.value,p=xe(e)):lt(e)?(c=()=>m(e),p=!0):q(e)?(y=!0,p=e.some(E=>lt(E)||xe(E)),c=()=>e.map(E=>{if(se(E))return E.value;if(lt(E))return m(E);if(G(E))return a?a(E,2):E()})):G(e)?t?c=a?()=>a(e,2):e:c=()=>{if(h){Le();try{h()}finally{Pe()}}const E=Qe;Qe=u;try{return a?a(e,3,[f]):e(f)}finally{Qe=E}}:c=Ae,t&&r){const E=c,L=r===!0?1/0:r;c=()=>Ue(E(),L)}const x=ls(),D=()=>{u.stop(),x&&x.active&&Wn(x.effects,u)};if(s&&t){const E=t;t=(...L)=>{E(...L),D()}}let W=y?new Array(e.length).fill(Pt):Pt;const R=E=>{if(!(!(u.flags&1)||!u.dirty&&!E))if(t){const L=u.run();if(r||p||(y?L.some((k,H)=>Ve(k,W[H])):Ve(L,W))){h&&h();const k=Qe;Qe=u;try{const H=[L,W===Pt?void 0:y&&W[0]===Pt?[]:W,f];W=L,a?a(t,3,H):t(...H)}finally{Qe=k}}}else u.run()};return l&&l(R),u=new Vi(c),u.scheduler=o?()=>o(R,!1):R,f=E=>Ds(E,!1,u),h=u.onStop=()=>{const E=jt.get(u);if(E){if(a)a(E,4);else for(const L of E)L();jt.delete(u)}},t?i?R(!0):W=u.run():o?o(R.bind(null,!0),!0):u.run(),D.pause=u.pause.bind(u),D.resume=u.resume.bind(u),D.stop=D,D}function Ue(e,t=1/0,n){if(t<=0||!Q(e)||e.__v_skip||(n=n||new Set,n.has(e)))return e;if(n.add(e),t--,se(e))Ue(e.value,t,n);else if(q(e))for(let i=0;i<e.length;i++)Ue(e[i],t,n);else if(Wi(e)||ot(e))e.forEach(i=>{Ue(i,t,n)});else if(Pi(e)){for(const i in e)Ue(e[i],t,n);for(const i of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,i)&&Ue(e[i],t,n)}return e}/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function It(e,t,n,i){try{return i?e(...i):e()}catch(r){nn(r,t,n)}}function Ne(e,t,n,i){if(G(e)){const r=It(e,t,n,i);return r&&Ri(r)&&r.catch(s=>{nn(s,t,n)}),r}if(q(e)){const r=[];for(let s=0;s<e.length;s++)r.push(Ne(e[s],t,n,i));return r}}function nn(e,t,n,i=!0){const r=t?t.vnode:null,{errorHandler:s,throwUnhandledErrorInProduction:o}=t&&t.appContext.config||K;if(t){let l=t.parent;const a=t.proxy,m=`https://vuejs.org/error-reference/#runtime-${n}`;for(;l;){const u=l.ec;if(u){for(let c=0;c<u.length;c++)if(u[c](e,a,m)===!1)return}l=l.parent}if(s){Le(),It(s,null,10,[e,a,m]),Pe();return}}Rs(e,n,r,i,o)}function Rs(e,t,n,i=!0,r=!1){if(r)throw e;console.error(e)}const $e=[];let Oe=-1;const at=[];let ke=null,rt=0;const or=Promise.resolve();let zt=null;function Ls(e){const t=zt||or;return e?t.then(this?e.bind(this):e):t}function Ps(e){let t=Oe+1,n=$e.length;for(;t<n;){const i=t+n>>>1,r=$e[i],s=St(r);s<e||s===e&&r.flags&2?t=i+1:n=i}return t}function Hn(e){if(!(e.flags&1)){const t=St(e),n=$e[$e.length-1];!n||!(e.flags&2)&&t>=St(n)?$e.push(e):$e.splice(Ps(t),0,e),e.flags|=1,lr()}}function lr(){zt||(zt=or.then($r))}function qs(e){q(e)?at.push(...e):ke&&e.id===-1?ke.splice(rt+1,0,e):e.flags&1||(at.push(e),e.flags|=1),lr()}function oi(e,t,n=Oe+1){for(;n<$e.length;n++){const i=$e[n];if(i&&i.flags&2){if(e&&i.id!==e.uid)continue;$e.splice(n,1),n--,i.flags&4&&(i.flags&=-2),i(),i.flags&4||(i.flags&=-2)}}}function ar(e){if(at.length){const t=[...new Set(at)].sort((n,i)=>St(n)-St(i));if(at.length=0,ke){ke.push(...t);return}for(ke=t,rt=0;rt<ke.length;rt++){const n=ke[rt];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}ke=null,rt=0}}const St=e=>e.id==null?e.flags&2?-1:1/0:e.id;function $r(e){try{for(Oe=0;Oe<$e.length;Oe++){const t=$e[Oe];t&&!(t.flags&8)&&(t.flags&4&&(t.flags&=-2),It(t,t.i,t.i?15:14),t.flags&4||(t.flags&=-2))}}finally{for(;Oe<$e.length;Oe++){const t=$e[Oe];t&&(t.flags&=-2)}Oe=-1,$e.length=0,ar(),zt=null,($e.length||at.length)&&$r()}}let Ce=null,fr=null;function Xt(e){const t=Ce;return Ce=e,fr=e&&e.type.__scopeId||null,t}function Gs(e,t=Ce,n){if(!t||e._n)return e;const i=(...r)=>{i._d&&mi(-1);const s=Xt(t);let o;try{o=e(...r)}finally{Xt(s),i._d&&mi(1)}return o};return i._n=!0,i._c=!0,i._d=!0,i}function Je(e,t,n,i){const r=e.dirs,s=t&&t.dirs;for(let o=0;o<r.length;o++){const l=r[o];s&&(l.oldValue=s[o].value);let a=l.dir[i];a&&(Le(),Ne(a,n,8,[e.el,l,e,t]),Pe())}}const ks=Symbol("_vte"),Ms=e=>e.__isTeleport;function jn(e,t){e.shapeFlag&6&&e.component?(e.transition=t,jn(e.component.subTree,t)):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}/*! #__NO_SIDE_EFFECTS__ */function zn(e,t){return G(e)?oe({name:e.name},t,{setup:e}):e}function ur(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}function _t(e,t,n,i,r=!1){if(q(e)){e.forEach((p,y)=>_t(p,t&&(q(t)?t[y]:t),n,i,r));return}if(vt(i)&&!r){i.shapeFlag&512&&i.type.__asyncResolved&&i.component.subTree.component&&_t(e,t,n,i.component.subTree);return}const s=i.shapeFlag&4?Jn(i.component):i.el,o=r?null:s,{i:l,r:a}=e,m=t&&t.r,u=l.refs===K?l.refs={}:l.refs,c=l.setupState,h=U(c),f=c===K?()=>!1:p=>V(h,p);if(m!=null&&m!==a&&(ne(m)?(u[m]=null,f(m)&&(c[m]=null)):se(m)&&(m.value=null)),G(a))It(a,l,12,[o,u]);else{const p=ne(a),y=se(a);if(p||y){const x=()=>{if(e.f){const D=p?f(a)?c[a]:u[a]:a.value;r?q(D)&&Wn(D,s):q(D)?D.includes(s)||D.push(s):p?(u[a]=[s],f(a)&&(c[a]=u[a])):(a.value=[s],e.k&&(u[e.k]=a.value))}else p?(u[a]=o,f(a)&&(c[a]=o)):y&&(a.value=o,e.k&&(u[e.k]=o))};o?(x.id=-1,he(x,n)):x()}}}en().requestIdleCallback;en().cancelIdleCallback;const vt=e=>!!e.type.__asyncLoader,dr=e=>e.type.__isKeepAlive;function Us(e,t){cr(e,"a",t)}function Vs(e,t){cr(e,"da",t)}function cr(e,t,n=fe){const i=e.__wdc||(e.__wdc=()=>{let r=n;for(;r;){if(r.isDeactivated)return;r=r.parent}return e()});if(rn(t,i,n),n){let r=n.parent;for(;r&&r.parent;)dr(r.parent.vnode)&&Bs(i,t,n,r),r=r.parent}}function Bs(e,t,n,i){const r=rn(t,e,i,!0);mr(()=>{Wn(i[t],r)},n)}function rn(e,t,n=fe,i=!1){if(n){const r=n[e]||(n[e]=[]),s=t.__weh||(t.__weh=(...o)=>{Le();const l=Ct(n),a=Ne(t,n,e,o);return l(),Pe(),a});return i?r.unshift(s):r.push(s),s}}const qe=e=>(t,n=fe)=>{(!Ot||e==="sp")&&rn(e,(...i)=>t(...i),n)},Hs=qe("bm"),pr=qe("m"),js=qe("bu"),zs=qe("u"),Xs=qe("bum"),mr=qe("um"),Ks=qe("sp"),Ys=qe("rtg"),Js=qe("rtc");function Zs(e,t=fe){rn("ec",e,t)}const Qs=Symbol.for("v-ndc");function gr(e,t,n,i){let r;const s=n,o=q(e);if(o||ne(e)){const l=o&&lt(e);let a=!1,m=!1;l&&(a=!xe(e),m=He(e),e=tn(e)),r=new Array(e.length);for(let u=0,c=e.length;u<c;u++)r[u]=t(a?m?Bt(ie(e[u])):ie(e[u]):e[u],u,void 0,s)}else if(typeof e=="number"){r=new Array(e);for(let l=0;l<e;l++)r[l]=t(l+1,l,void 0,s)}else if(Q(e))if(e[Symbol.iterator])r=Array.from(e,(l,a)=>t(l,a,void 0,s));else{const l=Object.keys(e);r=new Array(l.length);for(let a=0,m=l.length;a<m;a++){const u=l[a];r[a]=t(e[u],u,a,s)}}else r=[];return r}const Sn=e=>e?Pr(e)?Jn(e):Sn(e.parent):null,bt=oe(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Sn(e.parent),$root:e=>Sn(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>yr(e),$forceUpdate:e=>e.f||(e.f=()=>{Hn(e.update)}),$nextTick:e=>e.n||(e.n=Ls.bind(e.proxy)),$watch:e=>bo.bind(e)}),mn=(e,t)=>e!==K&&!e.__isScriptSetup&&V(e,t),eo={get({_:e},t){if(t==="__v_skip")return!0;const{ctx:n,setupState:i,data:r,props:s,accessCache:o,type:l,appContext:a}=e;let m;if(t[0]!=="$"){const f=o[t];if(f!==void 0)switch(f){case 1:return i[t];case 2:return r[t];case 4:return n[t];case 3:return s[t]}else{if(mn(i,t))return o[t]=1,i[t];if(r!==K&&V(r,t))return o[t]=2,r[t];if((m=e.propsOptions[0])&&V(m,t))return o[t]=3,s[t];if(n!==K&&V(n,t))return o[t]=4,n[t];wn&&(o[t]=0)}}const u=bt[t];let c,h;if(u)return t==="$attrs"&&re(e.attrs,"get",""),u(e);if((c=l.__cssModules)&&(c=c[t]))return c;if(n!==K&&V(n,t))return o[t]=4,n[t];if(h=a.config.globalProperties,V(h,t))return h[t]},set({_:e},t,n){const{data:i,setupState:r,ctx:s}=e;return mn(r,t)?(r[t]=n,!0):i!==K&&V(i,t)?(i[t]=n,!0):V(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(s[t]=n,!0)},has({_:{data:e,setupState:t,accessCache:n,ctx:i,appContext:r,propsOptions:s}},o){let l;return!!n[o]||e!==K&&V(e,o)||mn(t,o)||(l=s[0])&&V(l,o)||V(i,o)||V(bt,o)||V(r.config.globalProperties,o)},defineProperty(e,t,n){return n.get!=null?e._.accessCache[t]=0:V(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};function li(e){return q(e)?e.reduce((t,n)=>(t[n]=null,t),{}):e}let wn=!0;function to(e){const t=yr(e),n=e.proxy,i=e.ctx;wn=!1,t.beforeCreate&&ai(t.beforeCreate,e,"bc");const{data:r,computed:s,methods:o,watch:l,provide:a,inject:m,created:u,beforeMount:c,mounted:h,beforeUpdate:f,updated:p,activated:y,deactivated:x,beforeDestroy:D,beforeUnmount:W,destroyed:R,unmounted:E,render:L,renderTracked:k,renderTriggered:H,errorCaptured:ee,serverPrefetch:Ge,expose:_e,inheritAttrs:Xe,components:At,directives:Nt,filters:ln}=t;if(m&&no(m,i,null),o)for(const Z in o){const j=o[Z];G(j)&&(i[Z]=j.bind(n))}if(r){const Z=r.call(n,n);Q(Z)&&(e.data=Un(Z))}if(wn=!0,s)for(const Z in s){const j=s[Z],Ke=G(j)?j.bind(n,n):G(j.get)?j.get.bind(n,n):Ae,Dt=!G(j)&&G(j.set)?j.set.bind(n):Ae,Ye=Bo({get:Ke,set:Dt});Object.defineProperty(i,Z,{enumerable:!0,configurable:!0,get:()=>Ye.value,set:Fe=>Ye.value=Fe})}if(l)for(const Z in l)hr(l[Z],i,n,Z);if(a){const Z=G(a)?a.call(n):a;Reflect.ownKeys(Z).forEach(j=>{ao(j,Z[j])})}u&&ai(u,e,"c");function le(Z,j){q(j)?j.forEach(Ke=>Z(Ke.bind(n))):j&&Z(j.bind(n))}if(le(Hs,c),le(pr,h),le(js,f),le(zs,p),le(Us,y),le(Vs,x),le(Zs,ee),le(Js,k),le(Ys,H),le(Xs,W),le(mr,E),le(Ks,Ge),q(_e))if(_e.length){const Z=e.exposed||(e.exposed={});_e.forEach(j=>{Object.defineProperty(Z,j,{get:()=>n[j],set:Ke=>n[j]=Ke})})}else e.exposed||(e.exposed={});L&&e.render===Ae&&(e.render=L),Xe!=null&&(e.inheritAttrs=Xe),At&&(e.components=At),Nt&&(e.directives=Nt),Ge&&ur(e)}function no(e,t,n=Ae){q(e)&&(e=On(e));for(const i in e){const r=e[i];let s;Q(r)?"default"in r?s=Gt(r.from||i,r.default,!0):s=Gt(r.from||i):s=Gt(r),se(s)?Object.defineProperty(t,i,{enumerable:!0,configurable:!0,get:()=>s.value,set:o=>s.value=o}):t[i]=s}}function ai(e,t,n){Ne(q(e)?e.map(i=>i.bind(t.proxy)):e.bind(t.proxy),t,n)}function hr(e,t,n,i){let r=i.includes(".")?Ar(n,i):()=>n[i];if(ne(e)){const s=t[e];G(s)&&hn(r,s)}else if(G(e))hn(r,e.bind(n));else if(Q(e))if(q(e))e.forEach(s=>hr(s,t,n,i));else{const s=G(e.handler)?e.handler.bind(n):t[e.handler];G(s)&&hn(r,s,e)}}function yr(e){const t=e.type,{mixins:n,extends:i}=t,{mixins:r,optionsCache:s,config:{optionMergeStrategies:o}}=e.appContext,l=s.get(t);let a;return l?a=l:!r.length&&!n&&!i?a=t:(a={},r.length&&r.forEach(m=>Kt(a,m,o,!0)),Kt(a,t,o)),Q(t)&&s.set(t,a),a}function Kt(e,t,n,i=!1){const{mixins:r,extends:s}=t;s&&Kt(e,s,n,!0),r&&r.forEach(o=>Kt(e,o,n,!0));for(const o in t)if(!(i&&o==="expose")){const l=io[o]||n&&n[o];e[o]=l?l(e[o],t[o]):t[o]}return e}const io={data:$i,props:fi,emits:fi,methods:gt,computed:gt,beforeCreate:ae,created:ae,beforeMount:ae,mounted:ae,beforeUpdate:ae,updated:ae,beforeDestroy:ae,beforeUnmount:ae,destroyed:ae,unmounted:ae,activated:ae,deactivated:ae,errorCaptured:ae,serverPrefetch:ae,components:gt,directives:gt,watch:so,provide:$i,inject:ro};function $i(e,t){return t?e?function(){return oe(G(e)?e.call(this,this):e,G(t)?t.call(this,this):t)}:t:e}function ro(e,t){return gt(On(e),On(t))}function On(e){if(q(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function ae(e,t){return e?[...new Set([].concat(e,t))]:t}function gt(e,t){return e?oe(Object.create(null),e,t):t}function fi(e,t){return e?q(e)&&q(t)?[...new Set([...e,...t])]:oe(Object.create(null),li(e),li(t??{})):t}function so(e,t){if(!e)return t;if(!t)return e;const n=oe(Object.create(null),e);for(const i in t)n[i]=ae(e[i],t[i]);return n}function xr(){return{app:null,config:{isNativeTag:Xr,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let oo=0;function lo(e,t){return function(i,r=null){G(i)||(i=oe({},i)),r!=null&&!Q(r)&&(r=null);const s=xr(),o=new WeakSet,l=[];let a=!1;const m=s.app={_uid:oo++,_component:i,_props:r,_container:null,_context:s,_instance:null,version:Ho,get config(){return s.config},set config(u){},use(u,...c){return o.has(u)||(u&&G(u.install)?(o.add(u),u.install(m,...c)):G(u)&&(o.add(u),u(m,...c))),m},mixin(u){return s.mixins.includes(u)||s.mixins.push(u),m},component(u,c){return c?(s.components[u]=c,m):s.components[u]},directive(u,c){return c?(s.directives[u]=c,m):s.directives[u]},mount(u,c,h){if(!a){const f=m._ceVNode||be(i,r);return f.appContext=s,h===!0?h="svg":h===!1&&(h=void 0),e(f,u,h),a=!0,m._container=u,u.__vue_app__=m,Jn(f.component)}},onUnmount(u){l.push(u)},unmount(){a&&(Ne(l,m._instance,16),e(null,m._container),delete m._container.__vue_app__)},provide(u,c){return s.provides[u]=c,m},runWithContext(u){const c=$t;$t=m;try{return u()}finally{$t=c}}};return m}}let $t=null;function ao(e,t){if(fe){let n=fe.provides;const i=fe.parent&&fe.parent.provides;i===n&&(n=fe.provides=Object.create(i)),n[e]=t}}function Gt(e,t,n=!1){const i=fe||Ce;if(i||$t){let r=$t?$t._context.provides:i?i.parent==null||i.ce?i.vnode.appContext&&i.vnode.appContext.provides:i.parent.provides:void 0;if(r&&e in r)return r[e];if(arguments.length>1)return n&&G(t)?t.call(i&&i.proxy):t}}const _r={},vr=()=>Object.create(_r),br=e=>Object.getPrototypeOf(e)===_r;function $o(e,t,n,i=!1){const r={},s=vr();e.propsDefaults=Object.create(null),Fr(e,t,r,s);for(const o in e.propsOptions[0])o in r||(r[o]=void 0);n?e.props=i?r:Ss(r):e.type.props?e.props=r:e.props=s,e.attrs=s}function fo(e,t,n,i){const{props:r,attrs:s,vnode:{patchFlag:o}}=e,l=U(r),[a]=e.propsOptions;let m=!1;if((i||o>0)&&!(o&16)){if(o&8){const u=e.vnode.dynamicProps;for(let c=0;c<u.length;c++){let h=u[c];if(sn(e.emitsOptions,h))continue;const f=t[h];if(a)if(V(s,h))f!==s[h]&&(s[h]=f,m=!0);else{const p=Be(h);r[p]=In(a,l,p,f,e,!1)}else f!==s[h]&&(s[h]=f,m=!0)}}}else{Fr(e,t,r,s)&&(m=!0);let u;for(const c in l)(!t||!V(t,c)&&((u=nt(c))===c||!V(t,u)))&&(a?n&&(n[c]!==void 0||n[u]!==void 0)&&(r[c]=In(a,l,c,void 0,e,!0)):delete r[c]);if(s!==l)for(const c in s)(!t||!V(t,c))&&(delete s[c],m=!0)}m&&Re(e.attrs,"set","")}function Fr(e,t,n,i){const[r,s]=e.propsOptions;let o=!1,l;if(t)for(let a in t){if(ht(a))continue;const m=t[a];let u;r&&V(r,u=Be(a))?!s||!s.includes(u)?n[u]=m:(l||(l={}))[u]=m:sn(e.emitsOptions,a)||(!(a in i)||m!==i[a])&&(i[a]=m,o=!0)}if(s){const a=U(n),m=l||K;for(let u=0;u<s.length;u++){const c=s[u];n[c]=In(r,a,c,m[c],e,!V(m,c))}}return o}function In(e,t,n,i,r,s){const o=e[n];if(o!=null){const l=V(o,"default");if(l&&i===void 0){const a=o.default;if(o.type!==Function&&!o.skipFactory&&G(a)){const{propsDefaults:m}=r;if(n in m)i=m[n];else{const u=Ct(r);i=m[n]=a.call(null,t),u()}}else i=a;r.ce&&r.ce._setProp(n,i)}o[0]&&(s&&!l?i=!1:o[1]&&(i===""||i===nt(n))&&(i=!0))}return i}const uo=new WeakMap;function Er(e,t,n=!1){const i=n?uo:t.propsCache,r=i.get(e);if(r)return r;const s=e.props,o={},l=[];let a=!1;if(!G(e)){const u=c=>{a=!0;const[h,f]=Er(c,t,!0);oe(o,h),f&&l.push(...f)};!n&&t.mixins.length&&t.mixins.forEach(u),e.extends&&u(e.extends),e.mixins&&e.mixins.forEach(u)}if(!s&&!a)return Q(e)&&i.set(e,st),st;if(q(s))for(let u=0;u<s.length;u++){const c=Be(s[u]);ui(c)&&(o[c]=K)}else if(s)for(const u in s){const c=Be(u);if(ui(c)){const h=s[u],f=o[c]=q(h)||G(h)?{type:h}:oe({},h),p=f.type;let y=!1,x=!0;if(q(p))for(let D=0;D<p.length;++D){const W=p[D],R=G(W)&&W.name;if(R==="Boolean"){y=!0;break}else R==="String"&&(x=!1)}else y=G(p)&&p.name==="Boolean";f[0]=y,f[1]=x,(y||V(f,"default"))&&l.push(c)}}const m=[o,l];return Q(e)&&i.set(e,m),m}function ui(e){return e[0]!=="$"&&!ht(e)}const Xn=e=>e[0]==="_"||e==="$stable",Kn=e=>q(e)?e.map(Ie):[Ie(e)],co=(e,t,n)=>{if(t._n)return t;const i=Gs((...r)=>Kn(t(...r)),n);return i._c=!1,i},Tr=(e,t,n)=>{const i=e._ctx;for(const r in e){if(Xn(r))continue;const s=e[r];if(G(s))t[r]=co(r,s,i);else if(s!=null){const o=Kn(s);t[r]=()=>o}}},Sr=(e,t)=>{const n=Kn(t);e.slots.default=()=>n},wr=(e,t,n)=>{for(const i in t)(n||!Xn(i))&&(e[i]=t[i])},po=(e,t,n)=>{const i=e.slots=vr();if(e.vnode.shapeFlag&32){const r=t.__;r&&vn(i,"__",r,!0);const s=t._;s?(wr(i,t,n),n&&vn(i,"_",s,!0)):Tr(t,i)}else t&&Sr(e,t)},mo=(e,t,n)=>{const{vnode:i,slots:r}=e;let s=!0,o=K;if(i.shapeFlag&32){const l=t._;l?n&&l===1?s=!1:wr(r,t,n):(s=!t.$stable,Tr(t,r)),o=t}else t&&(Sr(e,t),o={default:1});if(s)for(const l in r)!Xn(l)&&o[l]==null&&delete r[l]},he=Io;function go(e){return ho(e)}function ho(e,t){const n=en();n.__VUE__=!0;const{insert:i,remove:r,patchProp:s,createElement:o,createText:l,createComment:a,setText:m,setElementText:u,parentNode:c,nextSibling:h,setScopeId:f=Ae,insertStaticContent:p}=e,y=($,d,g,b=null,_=null,v=null,I=void 0,O=null,T=!!d.dynamicChildren)=>{if($===d)return;$&&!mt($,d)&&(b=Wt($),Fe($,_,v,!0),$=null),d.patchFlag===-2&&(T=!1,d.dynamicChildren=null);const{type:F,ref:N,shapeFlag:C}=d;switch(F){case on:x($,d,g,b);break;case je:D($,d,g,b);break;case yn:$==null&&W(d,g,b,I);break;case me:At($,d,g,b,_,v,I,O,T);break;default:C&1?L($,d,g,b,_,v,I,O,T):C&6?Nt($,d,g,b,_,v,I,O,T):(C&64||C&128)&&F.process($,d,g,b,_,v,I,O,T,dt)}N!=null&&_?_t(N,$&&$.ref,v,d||$,!d):N==null&&$&&$.ref!=null&&_t($.ref,null,v,$,!0)},x=($,d,g,b)=>{if($==null)i(d.el=l(d.children),g,b);else{const _=d.el=$.el;d.children!==$.children&&m(_,d.children)}},D=($,d,g,b)=>{$==null?i(d.el=a(d.children||""),g,b):d.el=$.el},W=($,d,g,b)=>{[$.el,$.anchor]=p($.children,d,g,b,$.el,$.anchor)},R=({el:$,anchor:d},g,b)=>{let _;for(;$&&$!==d;)_=h($),i($,g,b),$=_;i(d,g,b)},E=({el:$,anchor:d})=>{let g;for(;$&&$!==d;)g=h($),r($),$=g;r(d)},L=($,d,g,b,_,v,I,O,T)=>{d.type==="svg"?I="svg":d.type==="math"&&(I="mathml"),$==null?k(d,g,b,_,v,I,O,T):Ge($,d,_,v,I,O,T)},k=($,d,g,b,_,v,I,O)=>{let T,F;const{props:N,shapeFlag:C,transition:A,dirs:P}=$;if(T=$.el=o($.type,v,N&&N.is,N),C&8?u(T,$.children):C&16&&ee($.children,T,null,b,_,gn($,v),I,O),P&&Je($,null,b,"created"),H(T,$,$.scopeId,I,b),N){for(const z in N)z!=="value"&&!ht(z)&&s(T,z,null,N[z],v,b);"value"in N&&s(T,"value",null,N.value,v),(F=N.onVnodeBeforeMount)&&we(F,b,$)}P&&Je($,null,b,"beforeMount");const M=yo(_,A);M&&A.beforeEnter(T),i(T,d,g),((F=N&&N.onVnodeMounted)||M||P)&&he(()=>{F&&we(F,b,$),M&&A.enter(T),P&&Je($,null,b,"mounted")},_)},H=($,d,g,b,_)=>{if(g&&f($,g),b)for(let v=0;v<b.length;v++)f($,b[v]);if(_){let v=_.subTree;if(d===v||Dr(v.type)&&(v.ssContent===d||v.ssFallback===d)){const I=_.vnode;H($,I,I.scopeId,I.slotScopeIds,_.parent)}}},ee=($,d,g,b,_,v,I,O,T=0)=>{for(let F=T;F<$.length;F++){const N=$[F]=O?Me($[F]):Ie($[F]);y(null,N,d,g,b,_,v,I,O)}},Ge=($,d,g,b,_,v,I)=>{const O=d.el=$.el;let{patchFlag:T,dynamicChildren:F,dirs:N}=d;T|=$.patchFlag&16;const C=$.props||K,A=d.props||K;let P;if(g&&Ze(g,!1),(P=A.onVnodeBeforeUpdate)&&we(P,g,d,$),N&&Je(d,$,g,"beforeUpdate"),g&&Ze(g,!0),(C.innerHTML&&A.innerHTML==null||C.textContent&&A.textContent==null)&&u(O,""),F?_e($.dynamicChildren,F,O,g,b,gn(d,_),v):I||j($,d,O,null,g,b,gn(d,_),v,!1),T>0){if(T&16)Xe(O,C,A,g,_);else if(T&2&&C.class!==A.class&&s(O,"class",null,A.class,_),T&4&&s(O,"style",C.style,A.style,_),T&8){const M=d.dynamicProps;for(let z=0;z<M.length;z++){const B=M[z],ue=C[B],de=A[B];(de!==ue||B==="value")&&s(O,B,ue,de,_,g)}}T&1&&$.children!==d.children&&u(O,d.children)}else!I&&F==null&&Xe(O,C,A,g,_);((P=A.onVnodeUpdated)||N)&&he(()=>{P&&we(P,g,d,$),N&&Je(d,$,g,"updated")},b)},_e=($,d,g,b,_,v,I)=>{for(let O=0;O<d.length;O++){const T=$[O],F=d[O],N=T.el&&(T.type===me||!mt(T,F)||T.shapeFlag&198)?c(T.el):g;y(T,F,N,null,b,_,v,I,!0)}},Xe=($,d,g,b,_)=>{if(d!==g){if(d!==K)for(const v in d)!ht(v)&&!(v in g)&&s($,v,d[v],null,_,b);for(const v in g){if(ht(v))continue;const I=g[v],O=d[v];I!==O&&v!=="value"&&s($,v,O,I,_,b)}"value"in g&&s($,"value",d.value,g.value,_)}},At=($,d,g,b,_,v,I,O,T)=>{const F=d.el=$?$.el:l(""),N=d.anchor=$?$.anchor:l("");let{patchFlag:C,dynamicChildren:A,slotScopeIds:P}=d;P&&(O=O?O.concat(P):P),$==null?(i(F,g,b),i(N,g,b),ee(d.children||[],g,N,_,v,I,O,T)):C>0&&C&64&&A&&$.dynamicChildren?(_e($.dynamicChildren,A,g,_,v,I,O),(d.key!=null||_&&d===_.subTree)&&Or($,d,!0)):j($,d,g,N,_,v,I,O,T)},Nt=($,d,g,b,_,v,I,O,T)=>{d.slotScopeIds=O,$==null?d.shapeFlag&512?_.ctx.activate(d,g,b,I,T):ln(d,g,b,_,v,I,T):Zn($,d,T)},ln=($,d,g,b,_,v,I)=>{const O=$.component=qo($,b,_);if(dr($)&&(O.ctx.renderer=dt),Go(O,!1,I),O.asyncDep){if(_&&_.registerDep(O,le,I),!$.el){const T=O.subTree=be(je);D(null,T,d,g)}}else le(O,$,d,g,_,v,I)},Zn=($,d,g)=>{const b=d.component=$.component;if(wo($,d,g))if(b.asyncDep&&!b.asyncResolved){Z(b,d,g);return}else b.next=d,b.update();else d.el=$.el,b.vnode=d},le=($,d,g,b,_,v,I)=>{const O=()=>{if($.isMounted){let{next:C,bu:A,u:P,parent:M,vnode:z}=$;{const Te=Ir($);if(Te){C&&(C.el=z.el,Z($,C,I)),Te.asyncDep.then(()=>{$.isUnmounted||O()});return}}let B=C,ue;Ze($,!1),C?(C.el=z.el,Z($,C,I)):C=z,A&&fn(A),(ue=C.props&&C.props.onVnodeBeforeUpdate)&&we(ue,M,C,z),Ze($,!0);const de=ci($),Ee=$.subTree;$.subTree=de,y(Ee,de,c(Ee.el),Wt(Ee),$,_,v),C.el=de.el,B===null&&Oo($,de.el),P&&he(P,_),(ue=C.props&&C.props.onVnodeUpdated)&&he(()=>we(ue,M,C,z),_)}else{let C;const{el:A,props:P}=d,{bm:M,m:z,parent:B,root:ue,type:de}=$,Ee=vt(d);Ze($,!1),M&&fn(M),!Ee&&(C=P&&P.onVnodeBeforeMount)&&we(C,B,d),Ze($,!0);{ue.ce&&ue.ce._def.shadowRoot!==!1&&ue.ce._injectChildStyle(de);const Te=$.subTree=ci($);y(null,Te,g,b,$,_,v),d.el=Te.el}if(z&&he(z,_),!Ee&&(C=P&&P.onVnodeMounted)){const Te=d;he(()=>we(C,B,Te),_)}(d.shapeFlag&256||B&&vt(B.vnode)&&B.vnode.shapeFlag&256)&&$.a&&he($.a,_),$.isMounted=!0,d=g=b=null}};$.scope.on();const T=$.effect=new Vi(O);$.scope.off();const F=$.update=T.run.bind(T),N=$.job=T.runIfDirty.bind(T);N.i=$,N.id=$.uid,T.scheduler=()=>Hn(N),Ze($,!0),F()},Z=($,d,g)=>{d.component=$;const b=$.vnode.props;$.vnode=d,$.next=null,fo($,d.props,b,g),mo($,d.children,g),Le(),oi($),Pe()},j=($,d,g,b,_,v,I,O,T=!1)=>{const F=$&&$.children,N=$?$.shapeFlag:0,C=d.children,{patchFlag:A,shapeFlag:P}=d;if(A>0){if(A&128){Dt(F,C,g,b,_,v,I,O,T);return}else if(A&256){Ke(F,C,g,b,_,v,I,O,T);return}}P&8?(N&16&&ut(F,_,v),C!==F&&u(g,C)):N&16?P&16?Dt(F,C,g,b,_,v,I,O,T):ut(F,_,v,!0):(N&8&&u(g,""),P&16&&ee(C,g,b,_,v,I,O,T))},Ke=($,d,g,b,_,v,I,O,T)=>{$=$||st,d=d||st;const F=$.length,N=d.length,C=Math.min(F,N);let A;for(A=0;A<C;A++){const P=d[A]=T?Me(d[A]):Ie(d[A]);y($[A],P,g,null,_,v,I,O,T)}F>N?ut($,_,v,!0,!1,C):ee(d,g,b,_,v,I,O,T,C)},Dt=($,d,g,b,_,v,I,O,T)=>{let F=0;const N=d.length;let C=$.length-1,A=N-1;for(;F<=C&&F<=A;){const P=$[F],M=d[F]=T?Me(d[F]):Ie(d[F]);if(mt(P,M))y(P,M,g,null,_,v,I,O,T);else break;F++}for(;F<=C&&F<=A;){const P=$[C],M=d[A]=T?Me(d[A]):Ie(d[A]);if(mt(P,M))y(P,M,g,null,_,v,I,O,T);else break;C--,A--}if(F>C){if(F<=A){const P=A+1,M=P<N?d[P].el:b;for(;F<=A;)y(null,d[F]=T?Me(d[F]):Ie(d[F]),g,M,_,v,I,O,T),F++}}else if(F>A)for(;F<=C;)Fe($[F],_,v,!0),F++;else{const P=F,M=F,z=new Map;for(F=M;F<=A;F++){const ge=d[F]=T?Me(d[F]):Ie(d[F]);ge.key!=null&&z.set(ge.key,F)}let B,ue=0;const de=A-M+1;let Ee=!1,Te=0;const ct=new Array(de);for(F=0;F<de;F++)ct[F]=0;for(F=P;F<=C;F++){const ge=$[F];if(ue>=de){Fe(ge,_,v,!0);continue}let Se;if(ge.key!=null)Se=z.get(ge.key);else for(B=M;B<=A;B++)if(ct[B-M]===0&&mt(ge,d[B])){Se=B;break}Se===void 0?Fe(ge,_,v,!0):(ct[Se-M]=F+1,Se>=Te?Te=Se:Ee=!0,y(ge,d[Se],g,null,_,v,I,O,T),ue++)}const ti=Ee?xo(ct):st;for(B=ti.length-1,F=de-1;F>=0;F--){const ge=M+F,Se=d[ge],ni=ge+1<N?d[ge+1].el:b;ct[F]===0?y(null,Se,g,ni,_,v,I,O,T):Ee&&(B<0||F!==ti[B]?Ye(Se,g,ni,2):B--)}}},Ye=($,d,g,b,_=null)=>{const{el:v,type:I,transition:O,children:T,shapeFlag:F}=$;if(F&6){Ye($.component.subTree,d,g,b);return}if(F&128){$.suspense.move(d,g,b);return}if(F&64){I.move($,d,g,dt);return}if(I===me){i(v,d,g);for(let C=0;C<T.length;C++)Ye(T[C],d,g,b);i($.anchor,d,g);return}if(I===yn){R($,d,g);return}if(b!==2&&F&1&&O)if(b===0)O.beforeEnter(v),i(v,d,g),he(()=>O.enter(v),_);else{const{leave:C,delayLeave:A,afterLeave:P}=O,M=()=>{$.ctx.isUnmounted?r(v):i(v,d,g)},z=()=>{C(v,()=>{M(),P&&P()})};A?A(v,M,z):z()}else i(v,d,g)},Fe=($,d,g,b=!1,_=!1)=>{const{type:v,props:I,ref:O,children:T,dynamicChildren:F,shapeFlag:N,patchFlag:C,dirs:A,cacheIndex:P}=$;if(C===-2&&(_=!1),O!=null&&(Le(),_t(O,null,g,$,!0),Pe()),P!=null&&(d.renderCache[P]=void 0),N&256){d.ctx.deactivate($);return}const M=N&1&&A,z=!vt($);let B;if(z&&(B=I&&I.onVnodeBeforeUnmount)&&we(B,d,$),N&6)zr($.component,g,b);else{if(N&128){$.suspense.unmount(g,b);return}M&&Je($,null,d,"beforeUnmount"),N&64?$.type.remove($,d,g,dt,b):F&&!F.hasOnce&&(v!==me||C>0&&C&64)?ut(F,d,g,!1,!0):(v===me&&C&384||!_&&N&16)&&ut(T,d,g),b&&Qn($)}(z&&(B=I&&I.onVnodeUnmounted)||M)&&he(()=>{B&&we(B,d,$),M&&Je($,null,d,"unmounted")},g)},Qn=$=>{const{type:d,el:g,anchor:b,transition:_}=$;if(d===me){jr(g,b);return}if(d===yn){E($);return}const v=()=>{r(g),_&&!_.persisted&&_.afterLeave&&_.afterLeave()};if($.shapeFlag&1&&_&&!_.persisted){const{leave:I,delayLeave:O}=_,T=()=>I(g,v);O?O($.el,v,T):T()}else v()},jr=($,d)=>{let g;for(;$!==d;)g=h($),r($),$=g;r(d)},zr=($,d,g)=>{const{bum:b,scope:_,job:v,subTree:I,um:O,m:T,a:F,parent:N,slots:{__:C}}=$;di(T),di(F),b&&fn(b),N&&q(C)&&C.forEach(A=>{N.renderCache[A]=void 0}),_.stop(),v&&(v.flags|=8,Fe(I,$,d,g)),O&&he(O,d),he(()=>{$.isUnmounted=!0},d),d&&d.pendingBranch&&!d.isUnmounted&&$.asyncDep&&!$.asyncResolved&&$.suspenseId===d.pendingId&&(d.deps--,d.deps===0&&d.resolve())},ut=($,d,g,b=!1,_=!1,v=0)=>{for(let I=v;I<$.length;I++)Fe($[I],d,g,b,_)},Wt=$=>{if($.shapeFlag&6)return Wt($.component.subTree);if($.shapeFlag&128)return $.suspense.next();const d=h($.anchor||$.el),g=d&&d[ks];return g?h(g):d};let an=!1;const ei=($,d,g)=>{$==null?d._vnode&&Fe(d._vnode,null,null,!0):y(d._vnode||null,$,d,null,null,null,g),d._vnode=$,an||(an=!0,oi(),ar(),an=!1)},dt={p:y,um:Fe,m:Ye,r:Qn,mt:ln,mc:ee,pc:j,pbc:_e,n:Wt,o:e};return{render:ei,hydrate:void 0,createApp:lo(ei)}}function gn({type:e,props:t},n){return n==="svg"&&e==="foreignObject"||n==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:n}function Ze({effect:e,job:t},n){n?(e.flags|=32,t.flags|=4):(e.flags&=-33,t.flags&=-5)}function yo(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function Or(e,t,n=!1){const i=e.children,r=t.children;if(q(i)&&q(r))for(let s=0;s<i.length;s++){const o=i[s];let l=r[s];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=r[s]=Me(r[s]),l.el=o.el),!n&&l.patchFlag!==-2&&Or(o,l)),l.type===on&&(l.el=o.el),l.type===je&&!l.el&&(l.el=o.el)}}function xo(e){const t=e.slice(),n=[0];let i,r,s,o,l;const a=e.length;for(i=0;i<a;i++){const m=e[i];if(m!==0){if(r=n[n.length-1],e[r]<m){t[i]=r,n.push(i);continue}for(s=0,o=n.length-1;s<o;)l=s+o>>1,e[n[l]]<m?s=l+1:o=l;m<e[n[s]]&&(s>0&&(t[i]=n[s-1]),n[s]=i)}}for(s=n.length,o=n[s-1];s-- >0;)n[s]=o,o=t[o];return n}function Ir(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:Ir(t)}function di(e){if(e)for(let t=0;t<e.length;t++)e[t].flags|=8}const _o=Symbol.for("v-scx"),vo=()=>Gt(_o);function hn(e,t,n){return Cr(e,t,n)}function Cr(e,t,n=K){const{immediate:i,deep:r,flush:s,once:o}=n,l=oe({},n),a=t&&i||!t&&s!=="post";let m;if(Ot){if(s==="sync"){const f=vo();m=f.__watcherHandles||(f.__watcherHandles=[])}else if(!a){const f=()=>{};return f.stop=Ae,f.resume=Ae,f.pause=Ae,f}}const u=fe;l.call=(f,p,y)=>Ne(f,u,p,y);let c=!1;s==="post"?l.scheduler=f=>{he(f,u&&u.suspense)}:s!=="sync"&&(c=!0,l.scheduler=(f,p)=>{p?f():Hn(f)}),l.augmentJob=f=>{t&&(f.flags|=4),c&&(f.flags|=2,u&&(f.id=u.uid,f.i=u))};const h=Ws(e,t,l);return Ot&&(m?m.push(h):a&&h()),h}function bo(e,t,n){const i=this.proxy,r=ne(e)?e.includes(".")?Ar(i,e):()=>i[e]:e.bind(i,i);let s;G(t)?s=t:(s=t.handler,n=t);const o=Ct(this),l=Cr(r,s.bind(i),n);return o(),l}function Ar(e,t){const n=t.split(".");return()=>{let i=e;for(let r=0;r<n.length&&i;r++)i=i[n[r]];return i}}const Fo=(e,t)=>t==="modelValue"||t==="model-value"?e.modelModifiers:e[`${t}Modifiers`]||e[`${Be(t)}Modifiers`]||e[`${nt(t)}Modifiers`];function Eo(e,t,...n){if(e.isUnmounted)return;const i=e.vnode.props||K;let r=n;const s=t.startsWith("update:"),o=s&&Fo(i,t.slice(7));o&&(o.trim&&(r=n.map(u=>ne(u)?u.trim():u)),o.number&&(r=n.map(Qr)));let l,a=i[l=$n(t)]||i[l=$n(Be(t))];!a&&s&&(a=i[l=$n(nt(t))]),a&&Ne(a,e,6,r);const m=i[l+"Once"];if(m){if(!e.emitted)e.emitted={};else if(e.emitted[l])return;e.emitted[l]=!0,Ne(m,e,6,r)}}function Nr(e,t,n=!1){const i=t.emitsCache,r=i.get(e);if(r!==void 0)return r;const s=e.emits;let o={},l=!1;if(!G(e)){const a=m=>{const u=Nr(m,t,!0);u&&(l=!0,oe(o,u))};!n&&t.mixins.length&&t.mixins.forEach(a),e.extends&&a(e.extends),e.mixins&&e.mixins.forEach(a)}return!s&&!l?(Q(e)&&i.set(e,null),null):(q(s)?s.forEach(a=>o[a]=null):oe(o,s),Q(e)&&i.set(e,o),o)}function sn(e,t){return!e||!Jt(t)?!1:(t=t.slice(2).replace(/Once$/,""),V(e,t[0].toLowerCase()+t.slice(1))||V(e,nt(t))||V(e,t))}function ci(e){const{type:t,vnode:n,proxy:i,withProxy:r,propsOptions:[s],slots:o,attrs:l,emit:a,render:m,renderCache:u,props:c,data:h,setupState:f,ctx:p,inheritAttrs:y}=e,x=Xt(e);let D,W;try{if(n.shapeFlag&4){const E=r||i,L=E;D=Ie(m.call(L,E,u,c,f,h,p)),W=l}else{const E=t;D=Ie(E.length>1?E(c,{attrs:l,slots:o,emit:a}):E(c,null)),W=t.props?l:To(l)}}catch(E){Ft.length=0,nn(E,e,1),D=be(je)}let R=D;if(W&&y!==!1){const E=Object.keys(W),{shapeFlag:L}=R;E.length&&L&7&&(s&&E.some(Dn)&&(W=So(W,s)),R=ft(R,W,!1,!0))}return n.dirs&&(R=ft(R,null,!1,!0),R.dirs=R.dirs?R.dirs.concat(n.dirs):n.dirs),n.transition&&jn(R,n.transition),D=R,Xt(x),D}const To=e=>{let t;for(const n in e)(n==="class"||n==="style"||Jt(n))&&((t||(t={}))[n]=e[n]);return t},So=(e,t)=>{const n={};for(const i in e)(!Dn(i)||!(i.slice(9)in t))&&(n[i]=e[i]);return n};function wo(e,t,n){const{props:i,children:r,component:s}=e,{props:o,children:l,patchFlag:a}=t,m=s.emitsOptions;if(t.dirs||t.transition)return!0;if(n&&a>=0){if(a&1024)return!0;if(a&16)return i?pi(i,o,m):!!o;if(a&8){const u=t.dynamicProps;for(let c=0;c<u.length;c++){const h=u[c];if(o[h]!==i[h]&&!sn(m,h))return!0}}}else return(r||l)&&(!l||!l.$stable)?!0:i===o?!1:i?o?pi(i,o,m):!0:!!o;return!1}function pi(e,t,n){const i=Object.keys(t);if(i.length!==Object.keys(e).length)return!0;for(let r=0;r<i.length;r++){const s=i[r];if(t[s]!==e[s]&&!sn(n,s))return!0}return!1}function Oo({vnode:e,parent:t},n){for(;t;){const i=t.subTree;if(i.suspense&&i.suspense.activeBranch===e&&(i.el=e.el),i===e)(e=t.vnode).el=n,t=t.parent;else break}}const Dr=e=>e.__isSuspense;function Io(e,t){t&&t.pendingBranch?q(e)?t.effects.push(...e):t.effects.push(e):qs(e)}const me=Symbol.for("v-fgt"),on=Symbol.for("v-txt"),je=Symbol.for("v-cmt"),yn=Symbol.for("v-stc"),Ft=[];let ye=null;function Y(e=!1){Ft.push(ye=e?null:[])}function Co(){Ft.pop(),ye=Ft[Ft.length-1]||null}let wt=1;function mi(e,t=!1){wt+=e,e<0&&ye&&t&&(ye.hasOnce=!0)}function Wr(e){return e.dynamicChildren=wt>0?ye||st:null,Co(),wt>0&&ye&&ye.push(e),e}function J(e,t,n,i,r,s){return Wr(S(e,t,n,i,r,s,!0))}function Ao(e,t,n,i,r){return Wr(be(e,t,n,i,r,!0))}function Rr(e){return e?e.__v_isVNode===!0:!1}function mt(e,t){return e.type===t.type&&e.key===t.key}const Lr=({key:e})=>e??null,kt=({ref:e,ref_key:t,ref_for:n})=>(typeof e=="number"&&(e=""+e),e!=null?ne(e)||se(e)||G(e)?{i:Ce,r:e,k:t,f:!!n}:e:null);function S(e,t=null,n=null,i=0,r=null,s=e===me?0:1,o=!1,l=!1){const a={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&Lr(t),ref:t&&kt(t),scopeId:fr,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:s,patchFlag:i,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:Ce};return l?(Yn(a,n),s&128&&e.normalize(a)):n&&(a.shapeFlag|=ne(n)?8:16),wt>0&&!o&&ye&&(a.patchFlag>0||s&6)&&a.patchFlag!==32&&ye.push(a),a}const be=No;function No(e,t=null,n=null,i=0,r=null,s=!1){if((!e||e===Qs)&&(e=je),Rr(e)){const l=ft(e,t,!0);return n&&Yn(l,n),wt>0&&!s&&ye&&(l.shapeFlag&6?ye[ye.indexOf(e)]=l:ye.push(l)),l.patchFlag=-2,l}if(Vo(e)&&(e=e.__vccOpts),t){t=Do(t);let{class:l,style:a}=t;l&&!ne(l)&&(t.class=pe(l)),Q(a)&&(Bn(a)&&!q(a)&&(a=oe({},a)),t.style=Ln(a))}const o=ne(e)?1:Dr(e)?128:Ms(e)?64:Q(e)?4:G(e)?2:0;return S(e,t,n,i,r,o,s,!0)}function Do(e){return e?Bn(e)||br(e)?oe({},e):e:null}function ft(e,t,n=!1,i=!1){const{props:r,ref:s,patchFlag:o,children:l,transition:a}=e,m=t?Ro(r||{},t):r,u={__v_isVNode:!0,__v_skip:!0,type:e.type,props:m,key:m&&Lr(m),ref:t&&t.ref?n&&s?q(s)?s.concat(kt(t)):[s,kt(t)]:kt(t):s,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:l,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==me?o===-1?16:o|16:o,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:a,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&ft(e.ssContent),ssFallback:e.ssFallback&&ft(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return a&&i&&jn(u,a.clone(u)),u}function Wo(e=" ",t=0){return be(on,null,e,t)}function et(e="",t=!1){return t?(Y(),Ao(je,null,e)):be(je,null,e)}function Ie(e){return e==null||typeof e=="boolean"?be(je):q(e)?be(me,null,e.slice()):Rr(e)?Me(e):be(on,null,String(e))}function Me(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:ft(e)}function Yn(e,t){let n=0;const{shapeFlag:i}=e;if(t==null)t=null;else if(q(t))n=16;else if(typeof t=="object")if(i&65){const r=t.default;r&&(r._c&&(r._d=!1),Yn(e,r()),r._c&&(r._d=!0));return}else{n=32;const r=t._;!r&&!br(t)?t._ctx=Ce:r===3&&Ce&&(Ce.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else G(t)?(t={default:t,_ctx:Ce},n=32):(t=String(t),i&64?(n=16,t=[Wo(t)]):n=8);e.children=t,e.shapeFlag|=n}function Ro(...e){const t={};for(let n=0;n<e.length;n++){const i=e[n];for(const r in i)if(r==="class")t.class!==i.class&&(t.class=pe([t.class,i.class]));else if(r==="style")t.style=Ln([t.style,i.style]);else if(Jt(r)){const s=t[r],o=i[r];o&&s!==o&&!(q(s)&&s.includes(o))&&(t[r]=s?[].concat(s,o):o)}else r!==""&&(t[r]=i[r])}return t}function we(e,t,n,i=null){Ne(e,t,7,[n,i])}const Lo=xr();let Po=0;function qo(e,t,n){const i=e.type,r=(t?t.appContext:e.appContext)||Lo,s={uid:Po++,vnode:e,type:i,parent:t,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new Ui(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(r.provides),ids:t?t.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Er(i,r),emitsOptions:Nr(i,r),emit:null,emitted:null,propsDefaults:K,inheritAttrs:i.inheritAttrs,ctx:K,data:K,props:K,attrs:K,slots:K,refs:K,setupState:K,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return s.ctx={_:s},s.root=t?t.root:s,s.emit=Eo.bind(null,s),e.ce&&e.ce(s),s}let fe=null,Yt,Cn;{const e=en(),t=(n,i)=>{let r;return(r=e[n])||(r=e[n]=[]),r.push(i),s=>{r.length>1?r.forEach(o=>o(s)):r[0](s)}};Yt=t("__VUE_INSTANCE_SETTERS__",n=>fe=n),Cn=t("__VUE_SSR_SETTERS__",n=>Ot=n)}const Ct=e=>{const t=fe;return Yt(e),e.scope.on(),()=>{e.scope.off(),Yt(t)}},gi=()=>{fe&&fe.scope.off(),Yt(null)};function Pr(e){return e.vnode.shapeFlag&4}let Ot=!1;function Go(e,t=!1,n=!1){t&&Cn(t);const{props:i,children:r}=e.vnode,s=Pr(e);$o(e,i,s,t),po(e,r,n||t);const o=s?ko(e,t):void 0;return t&&Cn(!1),o}function ko(e,t){const n=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,eo);const{setup:i}=n;if(i){Le();const r=e.setupContext=i.length>1?Uo(e):null,s=Ct(e),o=It(i,e,0,[e.props,r]),l=Ri(o);if(Pe(),s(),(l||e.sp)&&!vt(e)&&ur(e),l){if(o.then(gi,gi),t)return o.then(a=>{hi(e,a)}).catch(a=>{nn(a,e,0)});e.asyncDep=o}else hi(e,o)}else qr(e)}function hi(e,t,n){G(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:Q(t)&&(e.setupState=sr(t)),qr(e)}function qr(e,t,n){const i=e.type;e.render||(e.render=i.render||Ae);{const r=Ct(e);Le();try{to(e)}finally{Pe(),r()}}}const Mo={get(e,t){return re(e,"get",""),e[t]}};function Uo(e){const t=n=>{e.exposed=n||{}};return{attrs:new Proxy(e.attrs,Mo),slots:e.slots,emit:e.emit,expose:t}}function Jn(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(sr(rr(e.exposed)),{get(t,n){if(n in t)return t[n];if(n in bt)return bt[n](e)},has(t,n){return n in t||n in bt}})):e.proxy}function Vo(e){return G(e)&&"__vccOpts"in e}const Bo=(e,t)=>Ns(e,t,Ot),Ho="3.5.17";/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let An;const yi=typeof window<"u"&&window.trustedTypes;if(yi)try{An=yi.createPolicy("vue",{createHTML:e=>e})}catch{}const Gr=An?e=>An.createHTML(e):e=>e,jo="http://www.w3.org/2000/svg",zo="http://www.w3.org/1998/Math/MathML",We=typeof document<"u"?document:null,xi=We&&We.createElement("template"),Xo={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,i)=>{const r=t==="svg"?We.createElementNS(jo,e):t==="mathml"?We.createElementNS(zo,e):n?We.createElement(e,{is:n}):We.createElement(e);return e==="select"&&i&&i.multiple!=null&&r.setAttribute("multiple",i.multiple),r},createText:e=>We.createTextNode(e),createComment:e=>We.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>We.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,i,r,s){const o=n?n.previousSibling:t.lastChild;if(r&&(r===s||r.nextSibling))for(;t.insertBefore(r.cloneNode(!0),n),!(r===s||!(r=r.nextSibling)););else{xi.innerHTML=Gr(i==="svg"?`<svg>${e}</svg>`:i==="mathml"?`<math>${e}</math>`:e);const l=xi.content;if(i==="svg"||i==="mathml"){const a=l.firstChild;for(;a.firstChild;)l.appendChild(a.firstChild);l.removeChild(a)}t.insertBefore(l,n)}return[o?o.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}},Ko=Symbol("_vtc");function Yo(e,t,n){const i=e[Ko];i&&(t=(t?[t,...i]:[...i]).join(" ")),t==null?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}const _i=Symbol("_vod"),Jo=Symbol("_vsh"),Zo=Symbol(""),Qo=/(^|;)\s*display\s*:/;function el(e,t,n){const i=e.style,r=ne(n);let s=!1;if(n&&!r){if(t)if(ne(t))for(const o of t.split(";")){const l=o.slice(0,o.indexOf(":")).trim();n[l]==null&&Mt(i,l,"")}else for(const o in t)n[o]==null&&Mt(i,o,"");for(const o in n)o==="display"&&(s=!0),Mt(i,o,n[o])}else if(r){if(t!==n){const o=i[Zo];o&&(n+=";"+o),i.cssText=n,s=Qo.test(n)}}else t&&e.removeAttribute("style");_i in e&&(e[_i]=s?i.display:"",e[Jo]&&(i.display="none"))}const vi=/\s*!important$/;function Mt(e,t,n){if(q(n))n.forEach(i=>Mt(e,t,i));else if(n==null&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{const i=tl(e,t);vi.test(n)?e.setProperty(nt(i),n.replace(vi,""),"important"):e[i]=n}}const bi=["Webkit","Moz","ms"],xn={};function tl(e,t){const n=xn[t];if(n)return n;let i=Be(t);if(i!=="filter"&&i in e)return xn[t]=i;i=qi(i);for(let r=0;r<bi.length;r++){const s=bi[r]+i;if(s in e)return xn[t]=s}return t}const Fi="http://www.w3.org/1999/xlink";function Ei(e,t,n,i,r,s=ss(t)){i&&t.startsWith("xlink:")?n==null?e.removeAttributeNS(Fi,t.slice(6,t.length)):e.setAttributeNS(Fi,t,n):n==null||s&&!Gi(n)?e.removeAttribute(t):e.setAttribute(t,s?"":ze(n)?String(n):n)}function Ti(e,t,n,i,r){if(t==="innerHTML"||t==="textContent"){n!=null&&(e[t]=t==="innerHTML"?Gr(n):n);return}const s=e.tagName;if(t==="value"&&s!=="PROGRESS"&&!s.includes("-")){const l=s==="OPTION"?e.getAttribute("value")||"":e.value,a=n==null?e.type==="checkbox"?"on":"":String(n);(l!==a||!("_value"in e))&&(e.value=a),n==null&&e.removeAttribute(t),e._value=n;return}let o=!1;if(n===""||n==null){const l=typeof e[t];l==="boolean"?n=Gi(n):n==null&&l==="string"?(n="",o=!0):l==="number"&&(n=0,o=!0)}try{e[t]=n}catch{}o&&e.removeAttribute(r||t)}function nl(e,t,n,i){e.addEventListener(t,n,i)}function il(e,t,n,i){e.removeEventListener(t,n,i)}const Si=Symbol("_vei");function rl(e,t,n,i,r=null){const s=e[Si]||(e[Si]={}),o=s[t];if(i&&o)o.value=i;else{const[l,a]=sl(t);if(i){const m=s[t]=al(i,r);nl(e,l,m,a)}else o&&(il(e,l,o,a),s[t]=void 0)}}const wi=/(?:Once|Passive|Capture)$/;function sl(e){let t;if(wi.test(e)){t={};let i;for(;i=e.match(wi);)e=e.slice(0,e.length-i[0].length),t[i[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):nt(e.slice(2)),t]}let _n=0;const ol=Promise.resolve(),ll=()=>_n||(ol.then(()=>_n=0),_n=Date.now());function al(e,t){const n=i=>{if(!i._vts)i._vts=Date.now();else if(i._vts<=n.attached)return;Ne($l(i,n.value),t,5,[i])};return n.value=e,n.attached=ll(),n}function $l(e,t){if(q(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map(i=>r=>!r._stopped&&i&&i(r))}else return t}const Oi=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,fl=(e,t,n,i,r,s)=>{const o=r==="svg";t==="class"?Yo(e,i,o):t==="style"?el(e,n,i):Jt(t)?Dn(t)||rl(e,t,n,i,s):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):ul(e,t,i,o))?(Ti(e,t,i),!e.tagName.includes("-")&&(t==="value"||t==="checked"||t==="selected")&&Ei(e,t,i,o,s,t!=="value")):e._isVueCE&&(/[A-Z]/.test(t)||!ne(i))?Ti(e,Be(t),i,s,t):(t==="true-value"?e._trueValue=i:t==="false-value"&&(e._falseValue=i),Ei(e,t,i,o))};function ul(e,t,n,i){if(i)return!!(t==="innerHTML"||t==="textContent"||t in e&&Oi(t)&&G(n));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="autocorrect"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const r=e.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return Oi(t)&&ne(n)?!1:t in e}const dl=["ctrl","shift","alt","meta"],cl={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,t)=>dl.some(n=>e[`${n}Key`]&&!t.includes(n))},pl=(e,t)=>{const n=e._withMods||(e._withMods={}),i=t.join(".");return n[i]||(n[i]=(r,...s)=>{for(let o=0;o<t.length;o++){const l=cl[t[o]];if(l&&l(r,t))return}return e(r,...s)})},ml=oe({patchProp:fl},Xo);let Ii;function gl(){return Ii||(Ii=go(ml))}const hl=(...e)=>{const t=gl().createApp(...e),{mount:n}=t;return t.mount=i=>{const r=xl(i);if(!r)return;const s=t._component;!G(s)&&!s.render&&!s.template&&(s.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const o=n(r,!1,yl(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},t};function yl(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function xl(e){return ne(e)?document.querySelector(e):e}/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */const _l=Symbol();var Ci;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(Ci||(Ci={}));function vl(){const e=os(!0),t=e.run(()=>Ht({}));let n=[],i=[];const r=rr({install(s){r._a=s,s.provide(_l,r),s.config.globalProperties.$pinia=r,i.forEach(o=>n.push(o)),i=[]},use(s){return this._a?n.push(s):i.push(s),this},_p:n,_a:null,_e:e,_s:new Map,state:t});return r}const bl={class:"extracted-data-viewer"},Fl={class:"data-section"},El={class:"data-grid"},Tl={class:"data-item"},Sl={class:"data-item"},wl={class:"data-item"},Ol={class:"data-item"},Il={class:"data-item"},Cl={class:"data-section"},Al={class:"data-grid"},Nl={key:0,class:"data-item"},Dl={class:"label"},Wl={class:"data-section"},Rl={class:"data-grid"},Ll={class:"data-item"},Pl={class:"data-item"},ql={class:"data-item"},Gl={key:0,class:"data-section"},kl=zn({__name:"ExtractedDataViewer",props:{data:{}},setup(e){const t=e,n={shadow_correction:f=>({Weak:"Low",Normal:"Medium",Strong:"High"})[f]??f,dynamic_range_expansion:f=>{const p=f.split(";")[1]?.trim();return{Auto:"Auto",0:"Off",Enabled:"On"}[p||""]??f},wb_shift_ab:f=>{const p=parseFloat(f);return p===0?"0":p<0?`A${-p}`:`B${p}`},wb_shift_gm:f=>{const p=parseFloat(f);return p===0?"0":p<0?`M${-p}`:`G${p}`},image_control:f=>({"Bleach Bypass 2":"Bleach Bypass","Cross Processing 2":"Cross Processing"})[f]??f},i={toning:f=>({0:"--",1:"S",2:"R",3:"G",4:"B",5:"P"})[f]??String(f),filter_effect:f=>f>0?"ON":"--",filter_effect_red:f=>f>0?`R+${f}%`:"--",filter_effect_green:f=>f>0?`G+${f}%`:"--",filter_effect_blue:f=>f>0?`B-${f}%`:"--",hdr_toning:f=>({0:"--",1:"BW",2:"S"})[f]??String(f),color_tone:f=>({1:"B",2:"M",3:"Y"})[f]??String(f),bleach_bypass_toning:f=>({0:"--",1:"C",2:"W"})[f]??String(f)},r={saturation:!1,hue:!1,grain_effect:!0,filter_effect:!0,filter_effect_red:!0,filter_effect_green:!0,filter_effect_blue:!0,toning:!0},s={default:{saturation:!0,hue:!0,high_low_key:!0,contrast:!0,contrast_highlight:!0,contrast_shadow:!0,sharpness:!0,shading:!0,clarity:!0,grain_effect:!1,toning:!1,filter_effect:!1,filter_effect_red:!1,filter_effect_green:!1,filter_effect_blue:!1,hdr_tone_level:!1,hdr_toning:!1,color_tone:!1,retro_toning:!1,bleach_bypass_toning:!1},Monotone:{...r},"Soft Monotone":{...r,clarity:!1},"HDR Tone":{hdr_tone_level:!0,hdr_toning:!0,shading:!1},"Cross Processing 2":{color_tone:!0},Retro:{retro_toning:!0},"Bleach Bypass 2":{bleach_bypass_toning:!0}},o=f=>{const p=t.data.props[f];if(n[f])return n[f](p);if(p===void 0)return"N/A";const y=f==="color_temperature"?"K":"";return String(p)+y},l=f=>({saturation:"Saturation",hue:"Hue",high_low_key:"High/Low Key Adjustment",contrast:"Contrast",contrast_highlight:"Contrast (Highlight)",contrast_shadow:"Contrast (Shadow)",sharpness:"Sharpness",shading:"Shading",clarity:"Clarity",grain_effect:"Grain Effect",toning:"Toning",filter_effect:"Filter Effect",filter_effect_red:"Filter Effect Red",filter_effect_green:"Filter Effect Green",filter_effect_blue:"Filter Effect Blue",hdr_tone_level:"HDR Tone Level",hdr_toning:"Toning",color_tone:"Color Tone",retro_toning:"Toning",bleach_bypass_toning:"Toning"})[f],a=f=>{const p=s[t.data.props.image_control]?.[f];return p!==void 0?p:s.default[f]},m=(f,p)=>{if(p===void 0)return"--";const y=i[f];return y!==void 0?y(p):String(p)},u=f=>({image_control:"",white_balance:"Auto",wb_shift_ab:"0",wb_shift_gm:"0",color_temperature:"5200",peripheral_illumination_correction:"",shadow_correction:"",dynamic_range_expansion:""})[f]||"",c=f=>t.data.props[f]===void 0?!1:o(f)!==u(f),h=Ht(!1);return pr(()=>{const f=new URLSearchParams(window.location.search);h.value=f.has("debug")}),(f,p)=>(Y(),J("div",bl,[S("section",Fl,[p[5]||(p[5]=S("h3",null,"Image Settings",-1)),S("div",El,[S("div",Tl,[p[0]||(p[0]=S("span",{class:"label"},"Image Control:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("image_control")}])},te(o("image_control")),3)]),S("div",Sl,[p[1]||(p[1]=S("span",{class:"label"},"White Balance:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("white_balance")}])},te(o("white_balance")),3)]),S("div",wl,[p[2]||(p[2]=S("span",{class:"label"},"WB Shift GM:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("wb_shift_gm")}])},te(o("wb_shift_gm")),3)]),S("div",Ol,[p[3]||(p[3]=S("span",{class:"label"},"WB Shift AB:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("wb_shift_ab")}])},te(o("wb_shift_ab")),3)]),S("div",Il,[p[4]||(p[4]=S("span",{class:"label"},"Color Temperature:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("color_temperature")}])},te(o("color_temperature")),3)])])]),S("section",Cl,[p[6]||(p[6]=S("h3",null,"Image Control Settings",-1)),S("div",Al,[(Y(!0),J(me,null,gr(f.data.props.image_control_settings,(y,x)=>(Y(),J(me,{key:x},[a(x)?(Y(),J("div",Nl,[S("span",Dl,te(l(x))+":",1),S("span",{class:pe(["value",{"value-nonzero":y!==0}])},te(m(x,y)),3)])):et("",!0)],64))),128))])]),S("section",Wl,[p[10]||(p[10]=S("h3",null,"Additional Corrections",-1)),S("div",Rl,[S("div",Ll,[p[7]||(p[7]=S("span",{class:"label"},"Peripheral Illumination:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("peripheral_illumination_correction")}])},te(o("peripheral_illumination_correction")),3)]),S("div",Pl,[p[8]||(p[8]=S("span",{class:"label"},"D-Range Shadow Correction:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("shadow_correction")}])},te(o("shadow_correction")),3)]),S("div",ql,[p[9]||(p[9]=S("span",{class:"label"},"D-Range Highlight Correction:",-1)),S("span",{class:pe(["value",{"value-nonzero":c("dynamic_range_expansion")}])},te(o("dynamic_range_expansion")),3)])])]),h.value?(Y(),J("section",Gl,[p[11]||(p[11]=S("h3",null,"Debug Data",-1)),S("pre",null,te(f.data),1)])):et("",!0)]))}}),kr=(e,t)=>{const n=e.__vccOpts||e;for(const[i,r]of t)n[i]=r;return n},Ml=kr(kl,[["__scopeId","data-v-3f9e6f4c"]]);var Ul=`use strict;use warnings;require 5.004;my$version='13.30';$^W=1;my$exePath;BEGIN {$exePath=@ARGV && lc($ARGV[0])eq '-xpath' && shift()? $^X : $0;my$exeDir=($exePath =~ /(.*)[\\\\\\/]/)? $1 : '.';my$incDir=($0 =~ /(.*)[\\\\\\/]/)? "$1/lib" : './lib';if (-l $0){my$lnk=eval {readlink $0};if (defined$lnk){my$lnkDir=($lnk =~ /(.*)[\\\\\\/]/)? $1 : '.';$exeDir=(($lnk =~ m(^/))? '' : $exeDir .'/').$lnkDir;$incDir="$exeDir/lib"}}$Image::ExifTool::exeDir=$exeDir;unshift@INC,$incDir;while (@ARGV and lc($ARGV[0])eq '-config'){shift;push@Image::ExifTool::configFiles,shift}}use Image::ExifTool qw{:Public};sub SigInt();sub SigCont();sub Cleanup();sub GetImageInfo($$);sub SetImageInfo($$$);sub DoHardLink($$$$$);sub CleanXML($);sub EncodeXML($);sub FormatXML($$$);sub EscapeJSON($;$);sub FormatJSON($$$;$);sub PrintCSV(;$);sub AddGroups($$$$);sub ConvertBinary($);sub IsEqual($$);sub Printable($);sub LengthUTF8($);sub Infile($;$);sub AddSetTagsFile($;$);sub Warning($$);sub DoSetFromFile($$$);sub CleanFilename($);sub HasWildcards($);sub SetWindowTitle($);sub ProcessFiles($;$);sub ScanDir($$;$);sub FindFileWindows($$);sub FileNotFound($);sub PreserveTime();sub AbsPath($);sub MyConvertFileName($$);sub SuggestedExtension($$$);sub LoadPrintFormat($;$);sub FilenameSPrintf($;$@);sub NextUnusedFilename($;$);sub CreateDirectory($);sub OpenOutputFile($;@);sub AcceptFile($);sub SlurpFile($$);sub FilterArgfileLine($);sub ReadStayOpen($);sub Progress($$);sub PrintTagList($@);sub PrintErrors($$$);$SIG{INT}='SigInt';$SIG{CONT}='SigCont';END {Cleanup()}my@commonArgs;my@condition;my@csvFiles;my@csvTags;my@delFiles;my@dynamicFiles;my@efile;my@exclude;my (@echo3,@echo4);my@files;my@moreArgs;my@newValues;my@requestTags;my@srcFmt;my@tags;my%altFile;my%appended;my%countLink;my%created;my%csvTags;my%database;my%filterExt;my%ignore;my$ignoreHidden;my%outComma;my%outTrailer;my%preserveTime;my%printFmt;my%seqFileDir;my%setTags;my%setTagsList;my%usedFileName;my%utf8FileName;my%warnedOnce;my%wext;my$allGroup;my$altEnc;my$argFormat;my$binaryOutput;my$binaryStdout;my$binSep;my$binTerm;my$comma;my$count;my$countBad;my$countBadCr;my$countBadWr;my$countCopyWr;my$countDir;my$countFailed;my$countGoodCr;my$countGoodWr;my$countNewDir;my$countSameWr;my$critical;my$csv;my$csvAdd;my$csvDelim;my$csvSaveCount;my$deleteOrig;my$diff;my$disableOutput;my$doSetFileName;my$doUnzip;my ($end,$endDir,%endDir);my$escapeC;my$escapeHTML;my$evalWarning;my$executeID;my$failCondition;my$fastCondition;my$fileHeader;my$fileTrailer;my$filtered;my$filterFlag;my$fixLen;my$forcePrint;my$geoOnly;my$helped;my$html;my$interrupted;my$isBinary;my$isWriting;my$joinLists;my$json;my$langOpt;my$listDir;my$listItem;my$listSep;my$mt;my$multiFile;my$noBinary;my$outFormat;my$outOpt;my$overwriteOrig;my$pause;my$plot;my$preserveTime;my$progress;my$progressCount;my$progressIncr;my$progressMax;my$progressNext;my$progStr;my$quiet;my$rafStdin;my$recurse;my$rtnVal;my$rtnValPrev;my$saveCount;my$scanWritable;my$sectHeader;my$sectTrailer;my$seqFileDir;my$seqFileNum;my$setCharset;my$showGroup;my$showTagID;my$stayOpenBuff='';my$stayOpenFile;my$structOpt;my$tabFormat;my$tagOut;my$textOut;my$textOut2;my$textOverwrite;my$tmpFile;my$tmpText;my$validFile;my$verbose;my$vout;my$windowTitle;my%wroteHEAD;my$xml;my$stayOpen=0;my$rtnValApp=0;my$curTitle='';my$isCRLF={MSWin32=>1,os2=>1,dos=>1 }->{$^O};my%jsonChar=('"'=>'"','\\\\'=>'\\\\',"\\t"=>'t',"\\n"=>'n',"\\r"=>'r');my%escC=("\\n"=>'\\n',"\\r"=>'\\r',"\\t"=>'\\t','\\\\'=>'\\\\\\\\');my%unescC=(a=>"\\a",b=>"\\b",f=>"\\f",n=>"\\n",r=>"\\r",t=>"\\t",0=>"\\0",'\\\\'=>'\\\\');my%optArgs=('-tagsfromfile'=>1,'-addtagsfromfile'=>1,'-alltagsfromfile'=>1,'-@'=>1,'-api'=>1,'-c'=>1,'-coordformat'=>1,'-charset'=>0,'-config'=>1,'-csvdelim'=>1,'-d'=>1,'-dateformat'=>1,'-D'=>0,'-diff'=>1,'-echo'=>1,'-echo#'=>1,'-efile'=>1,'-efile#'=>1,'-efile!'=>1,'-efile#!'=>1,'-ext'=>1,'--ext'=>1,'-ext+'=>1,'--ext+'=>1,'-extension'=>1,'--extension'=>1,'-extension+'=>1,'--extension+'=>1,'-fileorder'=>1,'-fileorder#'=>1,'-file#'=>1,'-geotag'=>1,'-globaltimeshift'=>1,'-i'=>1,'-ignore'=>1,'-if'=>1,'-if#'=>1,'-lang'=>0,'-listitem'=>1,'-o'=>1,'-out'=>1,'-p'=>1,'-printformat'=>1,'-p-'=>1,'-printformat-'=>1,'-P'=>0,'-password'=>1,'-require'=>1,'-sep'=>1,'-separator'=>1,'-srcfile'=>1,'-stay_open'=>1,'-use'=>1,'-userparam'=>1,'-w'=>1,'-w!'=>1,'-w+'=>1,'-w+!'=>1,'-w!+'=>1,'-textout'=>1,'-textout!'=>1,'-textout+'=>1,'-textout+!'=>1,'-textout!+'=>1,'-tagout'=>1,'-tagout!'=>1,'-tagout+'=>1,'-tagout+!'=>1,'-tagout!+'=>1,'-wext'=>1,'-wm'=>1,'-writemode'=>1,'-x'=>1,'-exclude'=>1,'-X'=>0,);my@recommends=qw(Archive::Zip Compress::Zlib Digest::MD5 Digest::SHA IO::Compress::Bzip2 POSIX::strptime Time::Local Unicode::LineBreak Compress::Raw::Lzma IO::Compress::RawDeflate IO::Uncompress::RawInflate IO::Compress::Brotli IO::Uncompress::Brotli Win32::API Win32::FindFile Win32API::File);my%altRecommends=('POSIX::strptime'=>'Time::Piece',);my%unescapeChar=('t'=>"\\t",'n'=>"\\n",'r'=>"\\r");sub Image::ExifTool::EndDir() {return$endDir=1}sub Image::ExifTool::End() {return$end=1}sub Exit {if ($pause){if (eval {require Term::ReadKey}){print STDERR "-- press any key --";Term::ReadKey::ReadMode('cbreak');Term::ReadKey::ReadKey(0);Term::ReadKey::ReadMode(0);print STDERR "\\b \\b" x 20}else {print STDERR "-- press RETURN --\\n";<STDIN>}}exit shift}sub Warn {if ($quiet < 2 or $_[0]=~ /^Error/){my$oldWarn=$SIG{'__WARN__'};delete$SIG{'__WARN__'};warn(@_);$SIG{'__WARN__'}=$oldWarn if defined$oldWarn}}sub Error {Warn @_;$rtnVal=1}sub WarnOnce($) {Warn(@_)and $warnedOnce{$_[0]}=1 unless$warnedOnce{$_[0]}}sub SigInt() {$critical and $interrupted=1,return;Cleanup();exit 1}sub SigCont() {}sub Cleanup() {$mt->Unlink($tmpFile)if defined$tmpFile;$mt->Unlink($tmpText)if defined$tmpText;undef$tmpFile;undef$tmpText;PreserveTime()if%preserveTime;SetWindowTitle('')}if (grep /^-common_args$/i,@ARGV){my (@newArgs,$common,$end);for (@ARGV){if (/^-common_args$/i and not $end){$common=1}elsif ($common){push@commonArgs,$_}else {$end=1 if $_ eq '--';push@newArgs,$_}}@ARGV=@newArgs if$common}Command: for (;;){if (@echo3){my$str=join("\\n",@echo3)."\\n";$str =~ s/\\$\\{status\\}/$rtnVal/ig;print STDOUT$str}if (@echo4){my$str=join("\\n",@echo4)."\\n";$str =~ s/\\$\\{status\\}/$rtnVal/ig;print STDERR$str}$rafStdin->Close()if$rafStdin;undef$rafStdin;$rtnValPrev=$rtnVal;$rtnValApp=$rtnVal if$rtnVal;last unless@ARGV or not defined$rtnVal or $stayOpen >= 2 or @commonArgs;if ($binaryStdout){binmode(STDOUT,':crlf')if $] >= 5.006 and $isCRLF;$binaryStdout=0}if ($stayOpen >= 2){if ($quiet and not defined$executeID){eval {require IO::Handle}and STDERR->flush(),STDOUT->flush()}else {eval {require IO::Handle}and STDERR->flush();my$id=defined$executeID ? $executeID : '';my$save=$|;$|=1;print "{ready$id}\\n";$|=$save}}undef@condition;undef@csvFiles;undef@csvTags;undef@delFiles;undef@dynamicFiles;undef@echo3;undef@echo4;undef@efile;undef@exclude;undef@files;undef@newValues;undef@srcFmt;undef@tags;undef%appended;undef%countLink;undef%created;undef%csvTags;undef%database;undef%endDir;undef%filterExt;undef%ignore;undef%outComma;undef%outTrailer;undef%preserveTime;undef%printFmt;undef%seqFileDir;undef%setTags;undef%setTagsList;undef%usedFileName;undef%utf8FileName;undef%warnedOnce;undef%wext;undef$allGroup;undef$altEnc;undef$argFormat;undef$binaryOutput;undef$binSep;undef$binTerm;undef$comma;undef$csv;undef$csvAdd;undef$deleteOrig;undef$diff;undef$disableOutput;undef$doSetFileName;undef$doUnzip;undef$end;undef$endDir;undef$escapeHTML;undef$escapeC;undef$evalWarning;undef$executeID;undef$failCondition;undef$fastCondition;undef$fileHeader;undef$filtered;undef$fixLen;undef$forcePrint;undef$geoOnly;undef$ignoreHidden;undef$joinLists;undef$langOpt;undef$listItem;undef$multiFile;undef$noBinary;undef$outOpt;undef$preserveTime;undef$progress;undef$progressCount;undef$progressIncr;undef$progressMax;undef$progressNext;undef$recurse;undef$scanWritable;undef$sectHeader;undef$setCharset;undef$showGroup;undef$showTagID;undef$structOpt;undef$tagOut;undef$textOut;undef$textOverwrite;undef$tmpFile;undef$tmpText;undef$validFile;undef$verbose;undef$windowTitle;$count=0;$countBad=0;$countBadCr=0;$countBadWr=0;$countCopyWr=0;$countDir=0;$countFailed=0;$countGoodCr=0;$countGoodWr=0;$countNewDir=0;$countSameWr=0;$csvDelim=',';$csvSaveCount=0;$fileTrailer='';$filterFlag=0;$html=0;$isWriting=0;$json=0;$listSep=', ';$outFormat=0;$overwriteOrig=0;$progStr='';$quiet=0;$rtnVal=0;$saveCount=0;$sectTrailer='';$seqFileDir=0;$seqFileNum=0;$tabFormat=0;$vout=\\*STDOUT;$xml=0;my@fileOrder;my$fileOrderFast;my$addGeotime;my$doGlob;my$endOfOpts;my$escapeXML;my$setTagsFile;my$sortOpt;my$srcStdin;my$useMWG;my ($argsLeft,@nextPass,$badCmd);my$pass=0;if ($^O eq 'MSWin32' and eval {require File::Glob}){import File::Glob qw(:globally :nocase);$doGlob=1}$mt=Image::ExifTool->new;$mt->Options(Duplicates=>0)unless%Image::ExifTool::UserDefined::Options and defined$Image::ExifTool::UserDefined::Options{Duplicates};$joinLists=1 if defined$mt->Options('List')and not $mt->Options('List');if (not $preserveTime and $^O eq 'MSWin32'){$preserveTime=2 if eval {require Win32::API}and eval {require Win32API::File}}if (@Image::ExifTool::UserDefined::Arguments){unshift@ARGV,@Image::ExifTool::UserDefined::Arguments}if ($version ne $Image::ExifTool::VERSION){Warn "Application version $version does not match Image::ExifTool library version $Image::ExifTool::VERSION\\n"}for (;;){if (not @ARGV or ($ARGV[0]=~ /^(-|\\xe2\\x88\\x92)execute(\\d+)?$/i and not $endOfOpts)){if (@ARGV){$executeID=$2;$helped=1;$badCmd and shift,$rtnVal=1,next Command}elsif ($stayOpen >= 2){ReadStayOpen(\\@ARGV);next}elsif ($badCmd){undef@commonArgs;$rtnVal=1;next Command}if ($pass==0){if (@commonArgs and not defined$argsLeft){$argsLeft=scalar(@ARGV)+ scalar(@moreArgs);unshift@ARGV,@commonArgs;undef@commonArgs unless$argsLeft;next}if (defined$argsLeft and $argsLeft < scalar(@ARGV)+ scalar(@moreArgs)){Warn "Ignoring -common_args from $ARGV[0] onwards to avoid infinite recursion\\n";while ($argsLeft < scalar(@ARGV)+ scalar(@moreArgs)){@ARGV and shift(@ARGV),next;shift@moreArgs}}$useMWG=1 if not $useMWG and grep /^([--_0-9A-Z]+:)*1?mwg:/i,@tags,@requestTags;if ($useMWG){require Image::ExifTool::MWG;Image::ExifTool::MWG::Load()}if (defined$forcePrint){unless (defined$mt->Options('MissingTagValue')){$mt->Options(MissingTagValue=>'-')}$forcePrint=$mt->Options('MissingTagValue')}}if (@nextPass){unshift@ARGV,@nextPass;undef@nextPass;undef$endOfOpts;++$pass;next}@ARGV and shift;last}$_=shift;next if$badCmd;if (not $endOfOpts and s/^(-|\\xe2\\x88\\x92)//){s/^\\xe2\\x88\\x92/-/;if ($_ eq '-'){$pass or push@nextPass,'--';$endOfOpts=1;next}my$a=lc $_;if (/^list([wfrdx]|wf|g(\\d*)|geo)?$/i){$pass or push@nextPass,"-$_";my$type=lc($1 || '');if (not $type or $type eq 'w' or $type eq 'x'){my$group;if ($ARGV[0]and $ARGV[0]=~ /^(-|\\xe2\\x88\\x92)(.+):(all|\\*)$/i){if ($pass==0){$useMWG=1 if lc($2)eq 'mwg';push@nextPass,shift;next}$group=$2;shift;$group =~ /IFD/i and Warn("Can't list tags for specific IFD\\n"),$helped=1,next;$group =~ /^(all|\\*)$/ and undef$group}else {$pass or next}$helped=1;if ($type eq 'x'){require Image::ExifTool::TagInfoXML;my%opts;$opts{Flags}=1 if defined$forcePrint;$opts{NoDesc}=1 if$outFormat > 0;$opts{Lang}=$langOpt;Image::ExifTool::TagInfoXML::Write(undef,$group,%opts);next}my$wr=($type eq 'w');my$msg=($wr ? 'Writable' : 'Available').($group ? " $group" : '').' tags';PrintTagList($msg,$wr ? GetWritableTags($group): GetAllTags($group));next if$group or $wr;my@tagList=GetShortcuts();PrintTagList('Command-line shortcuts',@tagList)if@tagList;next}$pass or next;$helped=1;if ($type eq 'wf'){my@wf;CanWrite($_)and push@wf,$_ foreach GetFileType();PrintTagList('Writable file extensions',@wf)}elsif ($type eq 'f'){PrintTagList('Supported file extensions',GetFileType())}elsif ($type eq 'r'){PrintTagList('Recognized file extensions',GetFileType(undef,0))}elsif ($type eq 'd'){PrintTagList('Deletable groups',GetDeleteGroups())}elsif ($type eq 'geo'){require Image::ExifTool::Geolocation;my ($i,$entry);print "Geolocation database:\\n" unless$quiet;my$isAlt=$mt->Options('GeolocAltNames')? ',AltNames' : '';$isAlt='' if$isAlt and not Image::ExifTool::Geolocation::ReadAltNames();print "City,Region,Subregion,CountryCode,Country,TimeZone,FeatureCode,Population,Latitude,Longitude$isAlt\\n";Image::ExifTool::Geolocation::SortDatabase('City')if$sortOpt;my$minPop=$mt->Options('GeolocMinPop');my$feature=$mt->Options('GeolocFeature')|| '';my$neg=$feature =~ s/^-//;my%fcodes=map {lc($_)=>1}split /\\s*,\\s*/,$feature;my@isUTF8=(0,1,2,4);push@isUTF8,10 if$isAlt;for ($i=0;;++$i){my@entry=Image::ExifTool::Geolocation::GetEntry($i,$langOpt,1)or last;$#entry=9;next if$minPop and $entry[7]< $minPop;next if%fcodes and $neg ? $fcodes{lc$entry[6]}: not $fcodes{lc$entry[6]};push@entry,Image::ExifTool::Geolocation::GetAltNames($i,1)if$isAlt;$_=defined $_ ? $mt->Decode($_,'UTF8'): '' foreach@entry[@isUTF8];pop@entry if$isAlt and not $entry[10];print join(',',@entry),"\\n"}}else {my$family=$2 || 0;PrintTagList("Groups in family $family",$mt->GetAllGroups($family))}next}if ($a eq 'ver'){$pass or push(@nextPass,'-ver'),next;my$libVer=$Image::ExifTool::VERSION;my$str=$libVer eq $version ? '' : " [Warning: Library version is $libVer]";if ($verbose){print "ExifTool version $version$str$Image::ExifTool::RELEASE\\n";printf "Perl version %s%s\\n",$],(defined \${^UNICODE} ? " (-C\${^UNICODE})" : '');print "Platform: $^O\\n";if ($verbose > 8){print "Current Dir: " .Cwd::getcwd()."\\n" if (eval {require Cwd});print "Script Name: $0\\n";print "Exe Name:    $^X\\n";print "Exe Dir:     $Image::ExifTool::exeDir\\n";print "Exe Path:    $exePath\\n"}print "Optional libraries:\\n";for (@recommends){next if /^Win32/ and $^O ne 'MSWin32';my$ver=eval "require $_ and \\$\${_}::VERSION";my$alt=$altRecommends{$_};$ver=eval "require $alt and \\$\${alt}::VERSION" and $_=$alt if not $ver and $alt;printf "  %-28s %s\\n",$_,$ver || '(not installed)'}if ($verbose > 1){print "Include directories:\\n";ref $_ or print "  $_\\n" foreach@INC}}else {print "$version$str$Image::ExifTool::RELEASE\\n"}$helped=1;next}if (/^(all|add)?tagsfromfile(=.*)?$/i){$setTagsFile=$2 ? substr($2,1): (@ARGV ? shift : '');if ($setTagsFile eq ''){Error("File must be specified for -tagsFromFile option\\n");$badCmd=1;next}AddSetTagsFile($setTagsFile,{Replace=>($1 and lc($1)eq 'add')? 0 : 1 });next}if ($a eq '@'){my$argFile=shift or Error("Expecting filename for -\\@ option\\n"),$badCmd=1,next;if ($stayOpen==1){@moreArgs=@ARGV;undef@ARGV}elsif ($stayOpen==3){if ($stayOpenFile and $stayOpenFile ne '-' and $argFile eq $stayOpenFile){$stayOpen=2;Warn "Ignoring request to switch to the same -stay_open ARGFILE ($argFile)\\n";next}close STAYOPEN;$stayOpen=1}my$fp=($stayOpen==1 ? \\*STAYOPEN : \\*ARGFILE);unless ($mt->Open($fp,$argFile)){unless ($argFile !~ /^\\// and $mt->Open($fp,"$Image::ExifTool::exeDir/$argFile")){Error "Error opening arg file $argFile\\n";$badCmd=1;next}}if ($stayOpen==1){$stayOpenFile=$argFile;$stayOpenBuff='';$stayOpen=2;$helped=1;ReadStayOpen(\\@ARGV);next}my (@newArgs,$didBOM);for (<ARGFILE>){unless ($didBOM){s/^\\xef\\xbb\\xbf//;$didBOM=1}$_=FilterArgfileLine($_);push@newArgs,$_ if defined $_}close ARGFILE;unshift@ARGV,@newArgs;next}/^(-?)(a|duplicates)$/i and $mt->Options(Duplicates=>($1 ? 0 : 1)),next;if ($a eq 'api'){my$opt=shift;if (defined$opt and length$opt){my$val=($opt =~ s/=(.*)//s)? $1 : 1;$val=undef unless$opt =~ s/\\^$// or length$val;$mt->Options($opt=>$val)}else {print "Available API Options:\\n";my$availableOptions=Image::ExifTool::AvailableOptions();$$_[3]or printf("  %-17s - %s\\n",$$_[0],$$_[2])foreach @$availableOptions;$helped=1}next}/^arg(s|format)$/i and $argFormat=1,next;if (/^(-?)b(inary)?$/i){($binaryOutput,$noBinary)=$1 ? (undef,1): (1,undef);$mt->Options(Binary=>$binaryOutput,NoPDFList=>$binaryOutput);next}if (/^c(oordFormat)?$/i){my$fmt=shift;$fmt or Error("Expecting coordinate format for -c option\\n"),$badCmd=1,next;$mt->Options('CoordFormat',$fmt);next}if ($a eq 'charset'){my$charset=(@ARGV and $ARGV[0]!~ /^(-|\\xe2\\x88\\x92)/)? shift : undef;if (not $charset){$pass or push(@nextPass,'-charset'),next;my%charsets;$charsets{$_}=1 foreach values%Image::ExifTool::charsetName;PrintTagList('Available character sets',sort keys%charsets);$helped=1}elsif ($charset !~ s/^(\\w+)=// or lc($1)eq 'exiftool'){{local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};undef$evalWarning;$mt->Options(Charset=>$charset)}if ($evalWarning){Warn$evalWarning}else {$setCharset=$mt->Options('Charset')}}else {my$type={id3=>'ID3',iptc=>'IPTC',exif=>'EXIF',filename=>'FileName',photoshop=>'Photoshop',quicktime=>'QuickTime',riff=>'RIFF' }->{lc $1};$type or Warn("Unknown type for -charset option: $1\\n"),next;$mt->Options("Charset$type"=>$charset)}next}/^config$/i and Warn("Ignored -config option (not first on command line)\\n"),shift,next;if (/^csv(\\+?=.*)?$/i){my$csvFile=$1;unless ($pass){push@nextPass,"-$_";if ($csvFile){push@newValues,{SaveCount=>++$saveCount };$csvSaveCount=$saveCount}next}if ($csvFile){$csvFile =~ s/^(\\+?=)//;$csvAdd=2 if $1 eq '+=';$vout=\\*STDERR if$srcStdin;$verbose and print$vout "Reading CSV file $csvFile\\n";my$msg;if ($mt->Open(\\*CSVFILE,$csvFile)){binmode CSVFILE;require Image::ExifTool::Import;$msg=Image::ExifTool::Import::ReadCSV(\\*CSVFILE,\\%database,$forcePrint,$csvDelim);close(CSVFILE)}else {$msg="Error opening CSV file '\${csvFile}'"}$msg and Warn("$msg\\n");$isWriting=1}$csv='CSV';next}if (/^csvdelim$/i){$csvDelim=shift;defined$csvDelim or Error("Expecting argument for -csvDelim option\\n"),$badCmd=1,next;$csvDelim =~ /"/ and Error("CSV delimiter can not contain a double quote\\n"),$badCmd=1,next;my%unescape=('t'=>"\\t",'n'=>"\\n",'r'=>"\\r",'\\\\'=>'\\\\');$csvDelim =~ s/\\\\(.)/$unescape{$1}||"\\\\$1"/sge;$mt->Options(CSVDelim=>$csvDelim);next}if (/^d$/ or $a eq 'dateformat'){my$fmt=shift;$fmt or Error("Expecting date format for -d option\\n"),$badCmd=1,next;$mt->Options('DateFormat',$fmt);next}(/^D$/ or $a eq 'decimal')and $showTagID='D',next;if (/^diff$/i){$diff=shift;defined$diff or Error("Expecting file name for -$_ option\\n"),$badCmd=1;next}/^delete_original(!?)$/i and $deleteOrig=($1 ? 2 : 1),next;/^list_dir$/i and $listDir=1,next;(/^e$/ or $a eq '-composite')and $mt->Options(Composite=>0),next;(/^-e$/ or $a eq 'composite')and $mt->Options(Composite=>1),next;(/^E$/ or $a eq 'escapehtml')and require Image::ExifTool::HTML and $escapeHTML=1,next;($a eq 'ec' or $a eq 'escapec')and $escapeC=1,next;($a eq 'ex' or $a eq 'escapexml')and $escapeXML=1,next;if (/^echo(\\d)?$/i){my$n=$1 || 1;my$arg=shift;next unless defined$arg;$n > 4 and Warn("Invalid -echo number\\n"),next;if ($n > 2){$n==3 ? push(@echo3,$arg): push(@echo4,$arg)}else {print {$n==2 ? \\*STDERR : \\*STDOUT}$arg,"\\n"}$helped=1;next}if (/^(ee|extractembedded)(\\d*)$/i){$mt->Options(ExtractEmbedded=>$2 || 1);$mt->Options(Duplicates=>1);next}if (/^efile(\\d+)?(!)?$/i){my$arg=shift;defined$arg or Error("Expecting file name for -$_ option\\n"),$badCmd=1,next;$efile[0]=$arg if not $1 or $1 & 0x01;$efile[1]=$arg if $1 and $1 & 0x02;$efile[2]=$arg if $1 and $1 & 0x04;$efile[3]=$arg if $1 and $1 & 0x08;$efile[4]=$arg if $1 and $1 & 0x016;unlink$arg if $2;next}if (/^-?ext(ension)?(\\+)?$/i){my$ext=shift;defined$ext or Error("Expecting extension for -ext option\\n"),$badCmd=1,next;my$flag=/^-/ ? 0 : ($2 ? 2 : 1);$filterFlag |= (0x01 << $flag);$ext =~ s/^\\.//;$filterExt{uc($ext)}=$flag ? 1 : 0;next}if (/^f$/ or $a eq 'forceprint'){$forcePrint=1;next}if (/^F([-+]?\\d*)$/ or /^fixbase([-+]?\\d*)$/i){$mt->Options(FixBase=>$1);next}if (/^fast(\\d*)$/i){$mt->Options(FastScan=>(length $1 ? $1 : 1));next}if (/^(file\\d+)$/i){$altFile{lc $1}=shift or Error("Expecting file name for -file option\\n"),$badCmd=1,next;next}if (/^fileorder(\\d*)$/i){push@fileOrder,shift if@ARGV;my$num=$1 || 0;$fileOrderFast=$num if not defined$fileOrderFast or $fileOrderFast > $num;next}$a eq 'globaltimeshift' and $mt->Options(GlobalTimeShift=>shift),next;if (/^(g)(roupHeadings|roupNames)?([\\d:]*)$/i){$showGroup=$3 || 0;$allGroup=($2 ? lc($2)eq 'roupnames' : $1 eq 'G');$mt->Options(SavePath=>1)if$showGroup =~ /\\b5\\b/;$mt->Options(SaveFormat=>1)if$showGroup =~ /\\b6\\b/;next}if ($a eq 'geotag'){my$trkfile=shift;unless ($pass){push@nextPass,'-geotag',$trkfile;next}$trkfile or Error("Expecting file name for -geotag option\\n"),$badCmd=1,next;if (HasWildcards($trkfile)){my@trks;if ($^O eq 'MSWin32' and eval {require Win32::FindFile}){@trks=FindFileWindows($mt,$trkfile)}elsif (eval {require File::Glob}){@trks=File::Glob::bsd_glob($trkfile)}else {@trks=glob($trkfile)}@trks or Error("No matching file found for -geotag option\\n"),$badCmd=1,next;push@newValues,'geotag='.shift(@trks)while@trks > 1;$trkfile=pop(@trks)}$_="geotag=$trkfile"}if (/^h$/ or $a eq 'htmlformat'){require Image::ExifTool::HTML;$html=$escapeHTML=1;$json=$xml=0;next}(/^H$/ or $a eq 'hex')and $showTagID='H',next;if (/^htmldump([-+]?\\d+)?$/i){$verbose=($verbose || 0)+ 1;$html=2;$mt->Options(HtmlDumpBase=>$1)if defined $1;next}if (/^i(gnore)?$/i){my$dir=shift;defined$dir or Error("Expecting directory name for -i option\\n"),$badCmd=1,next;$ignore{$dir}=1;$dir eq 'HIDDEN' and $ignoreHidden=1;next}if (/^if(\\d*)$/i){my$cond=shift;my$fast=length($1)? $1 : undef;defined$cond or Error("Expecting expression for -if option\\n"),$badCmd=1,next;if (not @condition or not defined$fast or (defined$fastCondition and $fastCondition > $fast)){$fastCondition=$fast}$cond =~ /^\\s*(not\\s*)\\$ok\\s*$/i and ($1 xor $rtnValPrev)and $failCondition=1;push@requestTags,$cond =~ /\\$\\{?((?:[-_0-9A-Z]+:)*[-_0-9A-Z?*]+)/ig;push@condition,$cond;next}if (/^j(son)?(\\+?=.*)?$/i){if ($2){unless ($pass){push@nextPass,"-$_";push@newValues,{SaveCount=>++$saveCount };$csvSaveCount=$saveCount;next}my$jsonFile=$2;$jsonFile =~ s/^(\\+?=)//;$csvAdd=2 if $1 eq '+=';$vout=\\*STDERR if$srcStdin;$verbose and print$vout "Reading JSON file $jsonFile\\n";my$chset=$mt->Options('Charset');my$msg;if ($mt->Open(\\*JSONFILE,$jsonFile)){binmode JSONFILE;require Image::ExifTool::Import;$msg=Image::ExifTool::Import::ReadJSON(\\*JSONFILE,\\%database,$forcePrint,$chset);close(JSONFILE)}else {$msg="Error opening JSON file '\${jsonFile}'"}$msg and Warn("$msg\\n");$isWriting=1;$csv='JSON'}else {$json=1;$html=$xml=0;$mt->Options(Duplicates=>1);require Image::ExifTool::XMP}next}/^(k|pause)$/i and $pause=1,next;(/^l$/ or $a eq 'long')and --$outFormat,next;(/^L$/ or $a eq 'latin')and $mt->Options(Charset=>'Latin'),next;if ($a eq 'lang'){$langOpt=(@ARGV and $ARGV[0]!~ /^(-|\\xe2\\x88\\x92)/)? shift : undef;if ($langOpt){$langOpt =~ tr/-A-Z/_a-z/;$mt->Options(Lang=>$langOpt);next if$langOpt eq $mt->Options('Lang')}else {$pass or push(@nextPass,'-lang'),next}my$langs=$quiet ? '' : "Available languages:\\n";$langs .= "  $_ - $Image::ExifTool::langName{$_}\\n" foreach@Image::ExifTool::langs;$langs =~ tr/_/-/;$langs=Image::ExifTool::HTML::EscapeHTML($langs)if$escapeHTML;$langs=$mt->Decode($langs,'UTF8');$langOpt and Error("Invalid or unsupported language '\${langOpt}'.\\n$langs"),$badCmd=1,next;print$langs;$helped=1;next}if ($a eq 'listitem'){my$li=shift;defined$li and Image::ExifTool::IsInt($li)or Warn("Expecting integer for -listItem option\\n"),next;$mt->Options(ListItem=>$li);$listItem=$li;next}/^(m|ignoreminorerrors)$/i and $mt->Options(IgnoreMinorErrors=>1),next;/^(n|-printconv)$/i and $mt->Options(PrintConv=>0),next;/^(-n|printconv)$/i and $mt->Options(PrintConv=>1),next;$a eq 'nop' and $helped=1,next;if (/^o(ut)?$/i){$outOpt=shift;defined$outOpt or Error("Expected output file or directory name for -o option\\n"),$badCmd=1,next;CleanFilename($outOpt);$vout=\\*STDERR if$vout =~ /^-(\\.\\w+)?$/;next}/^overwrite_original$/i and $overwriteOrig=1,next;/^overwrite_original_in_place$/i and $overwriteOrig=2,next;/^plot$/i and require Image::ExifTool::Plot and $plot=Image::ExifTool::Plot->new,next;if (/^p(-?)$/ or /^printformat(-?)$/i){my$fmt=shift;if ($pass){LoadPrintFormat($fmt,$1 || $binaryOutput);if (not $useMWG and grep /^([-_0-9A-Z]+:)*1?mwg:/i,@requestTags){$useMWG=1;require Image::ExifTool::MWG;Image::ExifTool::MWG::Load()}}else {push@nextPass,"-$_",$fmt}next}(/^P$/ or $a eq 'preserve')and $preserveTime=1,next;/^password$/i and $mt->Options(Password=>shift),next;if (/^progress(\\d*)(:.*)?$/i){$progressIncr=$1 || 1;$progressNext=0;if ($2){$windowTitle=substr $2,1;$windowTitle='ExifTool %p%%' unless length$windowTitle;$windowTitle =~ /%\\d*[bpr]/ and $progress=0 unless defined$progress}else {$progress=1;$verbose=0 unless defined$verbose}$progressCount=0;next}/^q(uiet)?$/i and ++$quiet,next;/^r(ecurse)?(\\.?)$/i and $recurse=($2 ? 2 : 1),next;if ($a eq 'require'){my$ver=shift;unless (defined$ver and Image::ExifTool::IsFloat($ver)){Error("Expecting version number for -require option\\n");$badCmd=1;next}unless ($Image::ExifTool::VERSION >= $ver){Error("Requires ExifTool version $ver or later\\n");$badCmd=1}next}/^restore_original$/i and $deleteOrig=0,next;(/^S$/ or $a eq 'veryshort')and $outFormat+=2,next;/^s(hort)?(\\d*)$/i and $outFormat=$2 eq '' ? $outFormat + 1 : $2,next;/^scanforxmp$/i and $mt->Options(ScanForXMP=>1),next;if (/^sep(arator)?$/i){my$sep=$listSep=shift;defined$listSep or Error("Expecting list item separator for -sep option\\n"),$badCmd=1,next;$sep =~ s/\\\\(.)/$unescapeChar{$1}||$1/sge;(defined$binSep ? $binTerm : $binSep)=$sep;$mt->Options(ListSep=>$listSep);$joinLists=1;my$listSplit=quotemeta$listSep;$listSplit =~ s/(\\\\ )+/\\\\s\\*/g;$listSplit='\\\\s+' if$listSplit eq '\\\\s*';$mt->Options(ListSplit=>$listSplit);next}/^(-)?sort$/i and $sortOpt=$1 ? 0 : 1,next;if ($a eq 'srcfile'){@ARGV or Warn("Expecting FMT for -srcfile option\\n"),next;push@srcFmt,shift;next}if ($a eq 'stay_open'){my$arg=shift;defined$arg or Warn("Expecting argument for -stay_open option\\n"),next;if ($arg =~ /^(1|true)$/i){if (not $stayOpen){$stayOpen=1}elsif ($stayOpen==2){$stayOpen=3}else {Warn "-stay_open already active\\n"}}elsif ($arg =~ /^(0|false)$/i){if ($stayOpen >= 2){close STAYOPEN;push@ARGV,@moreArgs;undef@moreArgs}elsif (not $stayOpen){Warn("-stay_open wasn't active\\n")}$stayOpen=0}else {Warn "Invalid argument for -stay_open\\n"}next}if (/^(-)?struct$/i){$mt->Options(Struct=>$1 ? 0 : 1);next}/^t(ab)?$/ and $tabFormat=1,next;if (/^T$/ or $a eq 'table'){$tabFormat=$forcePrint=1;$outFormat+=2;++$quiet;next}if (/^(u)(nknown(2)?)?$/i){my$inc=($3 or (not $2 and $1 eq 'U'))? 2 : 1;$mt->Options(Unknown=>$mt->Options('Unknown')+ $inc);next}if ($a eq 'use'){my$module=shift;$module or Error("Expecting module name for -use option\\n"),$badCmd=1,next;lc$module eq 'mwg' and $useMWG=1,next;$module =~ /[^\\w:]/ and Error("Invalid module name: $module\\n"),$badCmd=1,next;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};unless (eval "require Image::ExifTool::$module" or eval "require $module" or eval "require '\${module}'"){Error("Error using module $module\\n");$badCmd=1}next}if ($a eq 'userparam'){my$opt=shift;defined$opt or Error("Expected parameter for -userParam option\\n"),$badCmd=1,next;$opt =~ /=/ or $opt .= '=1';$mt->Options(UserParam=>$opt);next}if (/^v(erbose)?(\\d*)$/i){$verbose=($2 eq '')? ($verbose || 0)+ 1 : $2;next}if (/^(w|textout|tagout)([!+]*)$/i){$textOut=shift || Warn("Expecting argument for -$_ option\\n");my ($t1,$t2)=($1,$2);$textOverwrite=0;$textOverwrite += 1 if$t2 =~ /!/;$textOverwrite += 2 if$t2 =~ /\\+/;if ($t1 ne 'W' and lc($t1)ne 'tagout'){undef$tagOut}elsif ($textOverwrite >= 2 and $textOut !~ /%[-+]?\\d*[.:]?\\d*[lu]?[tgso]/){$tagOut=0}else {$tagOut=1}next}if (/^(-?)(wext|tagoutext)$/i){my$ext=shift;defined$ext or Error("Expecting extension for -wext option\\n"),$badCmd=1,next;my$flag=1;$1 and $wext{'*'}=1,$flag=-1;$ext =~ s/^\\.//;$wext{lc$ext}=$flag;next}if ($a eq 'wm' or $a eq 'writemode'){my$wm=shift;defined$wm or Error("Expecting argument for -$_ option\\n"),$badCmd=1,next;$wm =~ /^[wcg]*$/i or Error("Invalid argument for -$_ option\\n"),$badCmd=1,next;$mt->Options(WriteMode=>$wm);next}if (/^x$/ or $a eq 'exclude'){my$tag=shift;defined$tag or Error("Expecting tag name for -x option\\n"),$badCmd=1,next;$tag =~ s/\\ball\\b/\\*/ig;if ($setTagsFile){push @{$setTags{$setTagsFile}},"-$tag"}else {push@exclude,$tag}next}(/^X$/ or $a eq 'xmlformat')and $xml=1,$html=$json=0,$mt->Options(Duplicates=>1),next;if (/^php$/i){$json=2;$html=$xml=0;$mt->Options(Duplicates=>1);next}if (/^z(ip)?$/i){$doUnzip=1;$mt->Options(Compress=>1,XMPShorthand=>1);$mt->Options(Compact=>1)unless$mt->Options('Compact');next}$_ eq '' and push(@files,'-'),$srcStdin=1,next;length $_ eq 1 and $_ ne '*' and Error("Unknown option -$_\\n"),$badCmd=1,next;if (/^[^<]+(<?)=(.*)/s){my$val=$2;if ($1 and length($val)and ($val eq '@' or not defined FilenameSPrintf($val))){push@newValues,{SaveCount=>++$saveCount }}push@newValues,$_;if (/^([-_0-9A-Z]+:)*1?mwg:/i){$useMWG=1}elsif (/^([-_0-9A-Z]+:)*(filename|directory|testname)\\b/i){$doSetFileName=1}elsif (/^([-_0-9A-Z]+:)*(geotag|geotime|geosync|geolocate)\\b/i){if (lc $2 eq 'geotime'){$addGeotime=''}else {unshift@newValues,pop@newValues;if (lc $2 eq 'geotag' and (not defined$addGeotime or $addGeotime)and length$val){$addGeotime=($1 || '').q[Geotime<\${DateTimeOriginal#;$_=$self->GetValue('SubSecDateTimeOriginal','ValueConv') || $_}]}}}}else {AddSetTagsFile($setTagsFile='@')if not $setTagsFile and /(<|>)/;if ($setTagsFile){push @{$setTags{$setTagsFile}},$_;if ($1 eq '>'){$useMWG=1 if /^(.*>\\s*)?([-_0-9A-Z]+:)*1?mwg:/si;if (/\\b(filename|directory|testname)#?$/i){$doSetFileName=1}elsif (/\\bgeotime#?$/i){$addGeotime=''}}else {$useMWG=1 if /^([^<]+<\\s*(.*\\$\\{?)?)?([-_0-9A-Z]+:)*1?mwg:/si;if (/^([-_0-9A-Z]+:)*(filename|directory|testname)\\b/i){$doSetFileName=1}elsif (/^([-_0-9A-Z]+:)*geotime\\b/i){$addGeotime=''}}}else {my$lst=s/^-// ? \\@exclude : \\@tags;Warn(qq(Invalid TAG name: "$_"\\n))unless /^([-_0-9A-Z*]+:)*([-_0-9A-Z*?]+)#?$/i;push @$lst,$_}}}else {unless ($pass){push@nextPass,$_;next}if ($doGlob and HasWildcards($_)){if ($^O eq 'MSWin32' and eval {require Win32::FindFile}){push@files,FindFileWindows($mt,$_)}else {push@files,File::Glob::bsd_glob($_)}$doGlob=2}else {push@files,$_;$srcStdin=1 if $_ eq '-'}}}$mt->Options(UserParam=>'OK=' .(not $rtnValPrev));$vout=\\*STDERR if$srcStdin and ($isWriting or @newValues);$mt->Options(TextOut=>$vout)if$vout eq \\*STDERR;if ($useMWG and not defined$mt->Options('CharsetEXIF')){$mt->Options(CharsetEXIF=>'UTF8')}if (not @files and not $outOpt and not @newValues){my$loc=$mt->Options('Geolocation');$loc and $loc ne '1' and push(@files,qq(\\@JSON:{})),$geoOnly=1}unless ((@tags and not $outOpt)or @files or @newValues or $geoOnly){if ($doGlob and $doGlob==2){Error "No matching files\\n";next}$outOpt and Error("Nothing to write\\n"),next;unless ($helped){local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my$dummy=\\*SAVEERR;unless ($^O eq 'os2'){open SAVEERR,">&STDERR";open STDERR,'>/dev/null'}if (system('perldoc',$0)){print "Syntax:  exiftool [OPTIONS] FILE\\n\\n";print "Consult the exiftool documentation for a full list of options.\\n"}unless ($^O eq 'os2'){close STDERR;open STDERR,'>&SAVEERR'}}next}if (defined$deleteOrig and (@newValues or @tags)){if (not @newValues){my$verb=$deleteOrig ? 'deleting' : 'restoring from';Error "Can't specify tags when $verb originals\\n"}elsif ($deleteOrig){Error "Can't use -delete_original when writing.\\n";Error "Maybe you meant -overwrite_original ?\\n"}else {Error "It makes no sense to use -restore_original when writing\\n"}next}if ($overwriteOrig > 1 and $outOpt){Error "Can't overwrite in place when -o option is used\\n";next}if (($tagOut or defined$diff)and ($csv or $json or %printFmt or $tabFormat or $xml or $plot or ($verbose and $html))){my$opt=$tagOut ? '-W' : '-diff';Error "Sorry, $opt may not be combined with -csv, -htmlDump, -j, -p, -t or -X\\n";next}if ($csv and $csv eq 'CSV' and not $isWriting){$json=0;if ($textOut){$textOut2=$textOut;undef$textOut}if ($binaryOutput){$binaryOutput=0;$setCharset='default' unless defined$setCharset}if (%printFmt){Warn "The -csv option has no effect when -p is used\\n";undef$csv}require Image::ExifTool::XMP if$setCharset}if ($plot and $textOut){$textOut2=$textOut;undef$textOut}if ($textOut2){if ($textOverwrite > 1){Error "Can not append to multi-file output format\\n";undef$textOut2;next}if (not $textOverwrite and $mt->Exists($textOut2,1)){Error "Output file $textOut2 already exists\\n";undef$textOut2;next}CreateDirectory($textOut2);if ($mt->Open(\\*OUTFILE,$textOut2,'>')){close(\\*OUTFILE);unlink($textOut2)}else {Error("Error creating $textOut2\\n");undef$textOut2;next}}if ($escapeHTML or $json){$mt->Options(Charset=>'UTF8')if$json;$mt->Options(Escape=>'HTML')if$escapeHTML and not $xml}elsif ($escapeXML and not $xml){$mt->Options(Escape=>'XML')}if ($sortOpt){my$sort=($outFormat > 0 or $xml or $json or $csv or $plot)? 'Tag' : 'Descr';$mt->Options(Sort=>$sort,Sort2=>$sort)}if ($mt->Options('Struct')and not $structOpt){$structOpt=$mt->Options('Struct');require 'Image/ExifTool/XMPStruct.pl'}if ($plot){undef$joinLists;$mt->Options(List=>1);$plot->Settings($mt->Options('Plot'))}elsif ($xml){require Image::ExifTool::XMP;my$charset=$mt->Options('Charset');my%encoding=(UTF8=>'UTF-8',Latin=>'windows-1252',Latin2=>'windows-1250',Cyrillic=>'windows-1251',Greek=>'windows-1253',Turkish=>'windows-1254',Hebrew=>'windows-1255',Arabic=>'windows-1256',Baltic=>'windows-1257',Vietnam=>'windows-1258',MacRoman=>'macintosh',);unless ($encoding{$charset}){$charset='UTF8';$mt->Options(Charset=>$charset)}$fileHeader="<?xml version='1.0' encoding='$encoding{$charset}'?>\\n" ."<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\\n";$fileTrailer="</rdf:RDF>\\n";$joinLists=1 if$outFormat > 0;$mt->Options(List=>1)unless$joinLists;$showGroup=$allGroup=1;$binaryOutput=($outFormat > 0 ? undef : 0)if$binaryOutput;$showTagID='D' if$tabFormat and not $showTagID}elsif ($json){if ($json==1){$fileHeader='[';$fileTrailer="]\\n"}else {$fileHeader='Array(';$fileTrailer=");\\n"}if ($binaryOutput){$binaryOutput=0;require Image::ExifTool::XMP if$json==1}$mt->Options(List=>1)unless$joinLists;$showTagID='D' if$tabFormat and not $showTagID}elsif ($structOpt){$mt->Options(List=>1)}else {$joinLists=1}if ($argFormat){$outFormat=3;$allGroup=1 if defined$showGroup}if (Image::ExifTool::IsPC()){tr/\\\\/\\// foreach@files}unless (@files){unless ($outOpt){if ($doGlob and $doGlob==2){Error "No matching files\\n"}else {Error "No file specified\\n"}next}push@files,''}if ($verbose){$disableOutput=1 unless@tags or @exclude or $tagOut;undef$binaryOutput unless$tagOut;if ($html){$html=2;$mt->Options(HtmlDump=>$verbose)}else {$mt->Options(Verbose=>$verbose)unless$tagOut}}elsif (defined$verbose){require FileHandle;STDOUT->autoflush(1);STDERR->autoflush(1)}my$needSave=1;if (@newValues){if ($addGeotime){AddSetTagsFile($setTagsFile='@')unless$setTagsFile and $setTagsFile eq '@';push @{$setTags{$setTagsFile}},$addGeotime;$verbose and print$vout qq(Using default "-$addGeotime"\\n)}my%setTagsIndex;my%addDelOpt=('+'=>'AddValue','-'=>'DelValue',"\\xe2\\x88\\x92"=>'DelValue');$saveCount=0;for (@newValues){if (ref $_ eq 'HASH'){if ($$_{SaveCount}){$saveCount=$mt->SaveNewValues();$needSave=0;push@dynamicFiles,\\$csv if $$_{SaveCount}==$csvSaveCount}next}/(.*?)=(.*)/s or next;
        my ($tag, $newVal) = ($1, $2);
        $tag =~ s/\\ball\\b/\\*/ig;    # replace 'all' with '*' in tag names
        $newVal eq '' and undef $newVal unless $tag =~ s/\\^([-+]*)$/$1/;  # undefined to delete tag
        if ($tag =~ /^(All)?TagsFromFile$/i){defined$newVal or Error("Need file name for -tagsFromFile\\n"),next Command;++$isWriting;if ($newVal eq '@' or not defined FilenameSPrintf($newVal)or grep /\\bfile\\d+:/i,@{$setTags{$newVal}}){push@dynamicFiles,$newVal;next}unless ($mt->Exists($newVal)or $newVal eq '-'){Error "File '\${newVal}' does not exist for -tagsFromFile option\\n";next Command}my$setTags=$setTags{$newVal};if ($setTagsList{$newVal}){my$i=$setTagsIndex{$newVal}|| 0;$setTagsIndex{$newVal}=$i + 1;$setTags=$setTagsList{$newVal}[$i]if$setTagsList{$newVal}[$i]}unless (DoSetFromFile($mt,$newVal,$setTags)){$rtnVal=1;next Command}$needSave=1;next}my%opts=(Shift=>0);$opts{Protected}=1 unless$tag =~ /[?*]/;if ($tag =~ s/<// and defined$newVal){if (defined FilenameSPrintf($newVal)){SlurpFile($newVal,\\$newVal)or next}else {$tag =~ s/([-+]|\\xe2\\x88\\x92)$// and $opts{$addDelOpt{$1}}=1;my$result=Image::ExifTool::IsWritable($tag);if ($result){$opts{ProtectSaved}=$saveCount;push@dynamicFiles,[$tag,$newVal,\\%opts ];++$isWriting}elsif (defined$result){Warn "Tag '\${tag}' is not writable\\n"}else {Warn "Tag '\${tag}' does not exist\\n"}next}}if ($tag =~ s/([-+]|\\xe2\\x88\\x92)$//){$opts{$addDelOpt{$1}}=1;$newVal='' if $1 eq '-' and not defined$newVal}if ($escapeC and defined$newVal){$newVal =~ s/\\\\(x([0-9a-fA-F]{2})|.)/$2 ? chr(hex($2)) : $unescC{$1} || $1/seg}my ($rtn,$wrn)=$mt->SetNewValue($tag,$newVal,%opts);$needSave=1;++$isWriting if$rtn;$wrn and Warning($mt,$wrn);}unless ($csv){for (@exclude){$mt->SetNewValue($_,undef,Replace=>2);$needSave=1}}unless ($isWriting or $outOpt or @tags){Error "Nothing to do.\\n";next}}elsif (grep /^(\\*:)?\\*$/,@exclude){Error "All tags excluded -- nothing to do.\\n";next}if ($isWriting){if (defined$diff){Error "Can't use -diff option when writing tags\\n";next}elsif ($plot){Error "Can't use -plot option when writing tags\\n";next}elsif (@tags and not $outOpt and not $csv){my ($tg,$s)=@tags > 1 ? ("$tags[0] ...",'s'): ($tags[0],'');Warn "Ignored superfluous tag name$s or invalid option$s: -$tg\\n"}}$mt->SaveNewValues()if$outOpt or (@dynamicFiles and $needSave);$multiFile=1 if@files > 1;@exclude and $mt->Options(Exclude=>\\@exclude);undef$binaryOutput if$html;if ($binaryOutput){$outFormat=99;$mt->Options(PrintConv=>0);unless ($textOut or $binaryStdout){binmode(STDOUT);$binaryStdout=1;$mt->Options(TextOut=>($vout=\\*STDERR))}undef$showGroup}if (defined$showGroup and not (@tags and ($allGroup or $csv))and ($sortOpt or not defined$sortOpt)){$mt->Options(Sort=>"Group$showGroup")}if ($textOut){CleanFilename($textOut);$textOut=".$textOut" unless$textOut =~ /[.%]/ or defined$tagOut}if ($outOpt){my$type=GetFileType($outOpt);if ($type){my$canWrite=CanWrite($outOpt);unless ($canWrite){if (defined$canWrite and $canWrite eq ''){$type=Image::ExifTool::GetFileExtension($outOpt);$type=uc($outOpt)unless defined$type}Error "Can't write $type files\\n";next}$scanWritable=$type unless CanCreate($type)}else {$scanWritable=1}$isWriting=1}elsif ($isWriting or defined$deleteOrig){$scanWritable=1}$altEnc=$mt->Options('Charset');undef$altEnc if$altEnc eq 'UTF8';if (not $altEnc and $mt->Options('Lang')ne 'en'){$fixLen=eval {require Unicode::GCString}? 2 : 1}if (@fileOrder){my@allFiles;ProcessFiles($mt,\\@allFiles);my$sortTool=Image::ExifTool->new;$sortTool->Options(FastScan=>$fileOrderFast)if$fileOrderFast;$sortTool->Options(PrintConv=>$mt->Options('PrintConv'));$sortTool->Options(Duplicates=>0);my (%sortBy,%isFloat,@rev,$file);push@rev,(s/^-// ? 1 : 0)foreach@fileOrder;for$file (@allFiles){my@tags;my$info=$sortTool->ImageInfo(Infile($file,1),@fileOrder,\\@tags);for (@tags){$_=$$info{$_};defined $_ or $_='~',next;$isFloat{$_}=Image::ExifTool::IsFloat($_);s/(\\d+)/(length($1) < 12 ? '0'x(12-length($1)) : '') . $1/eg unless$isFloat{$_}}$sortBy{$file}=\\@tags}@files=sort {my ($i,$cmp);for ($i=0;$i<@rev;++$i){my$u=$sortBy{$a}[$i];my$v=$sortBy{$b}[$i];if (not $isFloat{$u}and not $isFloat{$v}){$cmp=$u cmp $v}elsif ($isFloat{$u}and $isFloat{$v}){$cmp=$u <=> $v}else {$cmp=$isFloat{$u}? -1 : 1}return$rev[$i]? -$cmp : $cmp if$cmp}return$a cmp $b}@allFiles}elsif (defined$progress){my@allFiles;ProcessFiles($mt,\\@allFiles);@files=@allFiles}$progressMax=scalar@files if defined$progress;my@dbKeys=keys%database;if (@dbKeys){if (eval {require Cwd}){undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};for (@dbKeys){my$db=$database{$_};tr/\\\\/\\// and $database{$_}=$db;my$absPath=AbsPath($_);if (defined$absPath){$database{$absPath}=$db unless$database{$absPath};if ($verbose and $verbose > 1){print$vout "Imported entry for '\${_}' (full path: '\${absPath}')\\n"}}elsif ($verbose and $verbose > 1){print$vout "Imported entry for '\${_}' (no full path)\\n"}}}}ProcessFiles($mt);Error "No file with specified extension\\n" if$filtered and not $validFile;if ($textOut){for (keys%outTrailer){next unless$outTrailer{$_};if ($mt->Open(\\*OUTTRAIL,$_,'>>')){my$fp=\\*OUTTRAIL;print$fp $outTrailer{$_};close$fp}else {Error("Error appending to $_\\n")}}}else {print$sectTrailer if$sectTrailer;print$fileTrailer if$fileTrailer and not $fileHeader;my ($fp,$err);if ($textOut2){if ($mt->Open(\\*OUTFILE,$textOut2,'>')){$fp=\\*OUTFILE}else {Error("Error creating $textOut2\\n");$err=1}}unless ($err){PrintCSV($fp)if$csv and not $isWriting;if ($plot){$plot->Draw($fp || \\*STDOUT);if ($$plot{Error}){Error("Error: $$plot{Error}\\n");$err=1}elsif ($$plot{Warn}){Warn("Warning: $$plot{Warn}\\n")}}}if ($fp){close($fp)or $err=1;if ($err){$mt->Unlink($textOut2)}else {$created{$textOut2}=1}}}my$totWr=$countGoodWr + $countBadWr + $countSameWr + $countCopyWr + $countGoodCr + $countBadCr;if (defined$deleteOrig){unless ($quiet){printf "%5d directories scanned\\n",$countDir if$countDir;printf "%5d directories created\\n",$countNewDir if$countNewDir;printf "%5d files failed condition\\n",$countFailed if$countFailed;printf "%5d image files found\\n",$count}if (@delFiles){if ($deleteOrig==1){printf '%5d originals will be deleted!  Are you sure [y/n]? ',scalar(@delFiles);my$response=<STDIN>;unless ($response =~ /^(y|yes)\\s*$/i){Warn "Originals not deleted.\\n";next}}$countGoodWr=$mt->Unlink(@delFiles);$countBad=scalar(@delFiles)- $countGoodWr}if ($quiet){}elsif ($count and not $countGoodWr and not $countBad){printf "%5d original files found\\n",$countGoodWr}elsif ($deleteOrig){printf "%5d original files deleted\\n",$countGoodWr if$count;printf "%5d originals not deleted due to errors\\n",$countBad if$countBad}else {printf "%5d image files restored from original\\n",$countGoodWr if$count;printf "%5d files not restored due to errors\\n",$countBad if$countBad}}elsif ((not $binaryStdout or $verbose)and not $quiet){my$tot=$count + $countBad;if ($countDir or $totWr or $countFailed or $tot > 1 or $textOut or %countLink){my$o=(($html or $json or $xml or %printFmt or $csv or $plot)and not $textOut)? \\*STDERR : $vout;printf($o "%5d directories scanned\\n",$countDir)if$countDir;printf($o "%5d directories created\\n",$countNewDir)if$countNewDir;printf($o "%5d files failed condition\\n",$countFailed)if$countFailed;printf($o "%5d image files created\\n",$countGoodCr)if$countGoodCr;printf($o "%5d image files updated\\n",$countGoodWr)if$totWr - $countGoodCr - $countBadCr - $countCopyWr;printf($o "%5d image files unchanged\\n",$countSameWr)if$countSameWr;printf($o "%5d image files %s\\n",$countCopyWr,$overwriteOrig ? 'moved' : 'copied')if$countCopyWr;printf($o "%5d files weren't updated due to errors\\n",$countBadWr)if$countBadWr;printf($o "%5d files weren't created due to errors\\n",$countBadCr)if$countBadCr;printf($o "%5d image files read\\n",$count)if ($tot+$countFailed)>1 or ($countDir and not $totWr);printf($o "%5d files could not be read\\n",$countBad)if$countBad;printf($o "%5d output files created\\n",scalar(keys%created))if$textOut or $textOut2;printf($o "%5d output files appended\\n",scalar(keys%appended))if%appended;printf($o "%5d hard links created\\n",$countLink{Hard}|| 0)if$countLink{Hard}or $countLink{BadHard};printf($o "%5d hard links could not be created\\n",$countLink{BadHard})if$countLink{BadHard};printf($o "%5d symbolic links created\\n",$countLink{Sym}|| 0)if$countLink{Sym}or $countLink{BadSym};printf($o "%5d symbolic links could not be created\\n",$countLink{BadSym})if$countLink{BadSym}}}if ($countBadWr or $countBadCr or $countBad){$rtnVal=1}elsif ($countFailed and not ($count or $totWr)and not $rtnVal){$rtnVal=2}Cleanup();}close STAYOPEN if$stayOpen >= 2;Exit$rtnValApp;sub GetImageInfo($$) {my ($et,$orig)=@_;my (@foundTags,@found2,$info,$info2,$et2,$file,$file2,$ind,$g8);if (defined$windowTitle){if ($progressCount >= $progressNext){my$prog=$progressMax ? "$progressCount/$progressMax" : '0/0';my$title=$windowTitle;my ($num,$denom)=split '/',$prog;my$frac=$num / ($denom || 1);my$n=$title =~ s/%(\\d+)b/%b/ ? $1 : 20;my$bar=int($frac * $n + 0.5);my%lkup=(b=>('I' x $bar).('.' x ($n - $bar)),f=>$orig,p=>int(100 * $frac + 0.5),r=>$prog,'%'=>'%',);$title =~ s/%([%bfpr])/$lkup{$1}/eg;SetWindowTitle($title);if (defined$progressMax){undef$progressNext}else {$progressNext += $progressIncr}}++$progressCount unless defined$progressMax}unless (length$orig or $outOpt){Warn qq(Error: Zero-length file name - ""\\n);++$countBad;return}if (@srcFmt){my ($fmt,$first);for$fmt (@srcFmt){$file=$fmt eq '@' ? $orig : FilenameSPrintf($fmt,$orig);$et->Exists($file)and undef($first),last;$verbose and print$vout "Source file $file does not exist\\n";$first=$file unless defined$first}$file=$first if defined$first;my ($d,$f)=Image::ExifTool::SplitFileName($orig);$et->Options(UserParam=>"OriginalDirectory#=$d");$et->Options(UserParam=>"OriginalFileName#=$f")}else {$file=$orig}for$g8 (sort keys%altFile){my$altName=$orig;$altName =~ s/\\$/\\$\\$/g;$altName=FilenameSPrintf($altFile{$g8},$altName);$et->SetAlternateFile($g8,$altName)}my$pipe=$file;if ($doUnzip){if ($file =~ /\\.(gz|bz2)$/i){my$type=lc $1;if ($file =~ /[^-_.'A-Za-z0-9\\/\\\\]/){Warn "Error: Insecure zip file name. Skipped\\n";EFile($file);++$countBad;return}if ($type eq 'gz'){$pipe=qq{gzip -dc "$file" |}}else {$pipe=qq{bzip2 -dc "$file" |}}$$et{TRUST_PIPE}=1}}if (@condition){unless ($file eq '-' or $et->Exists($file)){Warn "Error: File not found - $file\\n";EFile($file);FileNotFound($file);++$countBad;return}my$result;unless ($failCondition){undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my (%info,$condition);my$opts={Duplicates=>1,RequestTags=>\\@requestTags,Verbose=>0,HtmlDump=>0 };$$opts{FastScan}=$fastCondition if defined$fastCondition;@foundTags=('*',@tags)if@tags;$info=$et->ImageInfo(Infile($pipe,$isWriting),\\@foundTags,$opts);for$condition (@condition){my$cond=$et->InsertTagValues($condition,\\@foundTags,\\%info);{package Image::ExifTool;my$self=$et;$result=eval$cond;$@ and $evalWarning=$@}if ($evalWarning){undef$result;if ($verbose){chomp$evalWarning;$evalWarning =~ s/ at \\(eval .*//s;Warn "Condition: $evalWarning - $file\\n"}}last unless$result}undef@foundTags if$fastCondition}unless ($result){Progress($vout,"-------- $file (failed condition)")if$verbose;EFile($file,2);++$countFailed;return}if ($isWriting or $verbose or defined$fastCondition or defined$diff){undef$info;--$$et{FILE_SEQUENCE}}}elsif ($file =~ s/^(\\@JSON:)(.*)/$1/){my$dat=$2;$info=$et->ImageInfo(\\$dat,\\@foundTags);if ($geoOnly){/^Geolocation/ or delete $$info{$_}foreach keys %$info;$file=' '}}if (defined$deleteOrig){Progress($vout,"======== $file")if defined$verbose;++$count;my$original="\${file}_original";$et->Exists($original)or return;if ($deleteOrig){$verbose and print$vout "Scheduled for deletion: $original\\n";push@delFiles,$original}elsif ($et->Rename($original,$file)){$verbose and print$vout "Restored from $original\\n";EFile($file,3);++$countGoodWr}else {Warn "Error renaming $original\\n";EFile($file);++$countBad}return}++$seqFileNum;my ($dir)=Image::ExifTool::SplitFileName($orig);$seqFileDir=$seqFileDir{$dir}=($seqFileDir{$dir}|| 0)+ 1;my$lineCount=0;my ($fp,$outfile,$append);if ($textOut and ($verbose or $et->Options('PrintCSV'))and not ($tagOut or defined$diff or $plot)){($fp,$outfile,$append)=OpenOutputFile($orig);$fp or EFile($file),++$countBad,return;$tmpText=$outfile unless$append;$et->Options(TextOut=>$fp)}if ($isWriting){Progress($vout,"======== $file")if defined$verbose;SetImageInfo($et,$file,$orig);$info=$et->GetInfo('Warning','Error');PrintErrors($et,$info,$file);if (defined$outfile){undef$tmpText;close($fp);$et->Options(TextOut=>$vout);if ($info->{Error}){$et->Unlink($outfile)}elsif ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}}return}unless ($file eq '-' or $et->Exists($file)or $info){Warn "Error: File not found - $file\\n";FileNotFound($file);defined$outfile and close($fp),undef($tmpText),$et->Unlink($outfile);EFile($file);++$countBad;return}my$o;unless ($binaryOutput or $textOut or %printFmt or $html > 1 or $csv or $plot){if ($html){require Image::ExifTool::HTML;my$f=Image::ExifTool::HTML::EscapeHTML($file);print "<!-- $f -->\\n"}elsif (not ($json or $xml or defined$diff)){$o=\\*STDOUT if ($multiFile and not $quiet)or $progress}}$o=\\*STDERR if$progress and not $o;Progress($o,"======== $file")if$o;if ($info){if (@tags and not %printFmt){@foundTags=@tags;$info=$et->GetInfo(\\@foundTags)}}else {my$oldDups=$et->Options('Duplicates');if (%printFmt){$et->Options(Duplicates=>1);$et->Options(RequestTags=>\\@requestTags);if ($printFmt{SetTags}){$$et{TAGS_FROM_FILE}=1;$et->Options(MakerNotes=>1);$et->Options(Struct=>2);$et->Options(List=>1);$et->Options(CoordFormat=>'%d %d %.8f')unless$et->Options('CoordFormat')}}else {@foundTags=@tags}if (defined$diff){$file2=FilenameSPrintf($diff,$orig);if ($file eq $file2){Warn "Error: Diffing file with itself - $file2\\n";EFile($file);++$countBad;return}if ($et->Exists($file2)){$showGroup=1 unless defined$showGroup;$allGroup=1 unless defined$allGroup;$et->Options(Duplicates=>1,Sort=>"Group$showGroup",Verbose=>0);$et2=Image::ExifTool->new;$et2->Options(%{$$et{OPTIONS}});$et2->Options(ListSep=>$$et{OPTIONS}{ListSep});$et2->Options(ListSplit=>$$et{OPTIONS}{ListSplit});@found2=@foundTags;$info2=$et2->ImageInfo($file2,\\@found2)}else {$info2={Error=>"Diff file not found" }}if ($$info2{Error}){Warn "Error: $$info2{Error} - $file2\\n";EFile($file);++$countBad;return}}$info=$et->ImageInfo(Infile($pipe),\\@foundTags);$et->Options(Duplicates=>$oldDups)}if ($fp){if (defined$outfile){$et->Options(TextOut=>\\*STDOUT);undef$tmpText;if ($info->{Error}){close($fp);$et->Unlink($outfile)}else {++$lineCount}}if ($info->{Error}){Warn "Error: $$info{Error} - $file\\n";EFile($file);++$countBad;return}}if ($binaryOutput or not %$info){my$errs=$et->GetInfo('Warning','Error');PrintErrors($et,$errs,$file)and EFile($file),$rtnVal=1}elsif ($et->GetValue('Error')or ($$et{Validate}and $et->GetValue('Warning'))){$rtnVal=1}unless (defined$outfile or $tagOut){($fp,$outfile,$append)=OpenOutputFile($orig);$fp or EFile($file),++$countBad,return;$tmpText=$outfile if defined$outfile and not $append}if (defined$diff){my (%done,%done2,$wasDiff,@diffs,@groupTags2);my$v=$verbose || 0;print$fp "======== diff < $file > $file2\\n";my ($g2,$same)=(0,0);for (;;){my ($g,$tag2,$i,$key,@dupl,$val2,$t2,$equal,%used);my$tag=shift@foundTags;if (defined$tag){$done{$tag}=1;$g=$et->GetGroup($tag,$showGroup)}else {for (;;){$tag2=shift@found2;defined$tag2 or $g='',last;$done2{$tag2}or $g=$et2->GetGroup($tag2,$showGroup),last}}if ($g ne $g2){for$t2 (@groupTags2){next if$done2{$t2};my$val2=$et2->GetValue($t2);next unless defined$val2;my$name=$outFormat < 1 ? $et2->GetDescription($t2): GetTagName($t2);my$len=LengthUTF8($name);my$pad=$outFormat < 2 ? ' ' x ($len < 32 ? 32 - $len : 0): '';if ($allGroup){my$grp="[$g2]";$grp .= ' ' x (15 - length($grp))if length($grp)< 15 and $outFormat < 2;push@diffs,sprintf "> %s %s%s: %s\\n",$grp,$name,$pad,Printable($val2)}else {push@diffs,sprintf "> %s%s: %s\\n",$name,$pad,Printable($val2)}$done2{$t2}=1}my$str='';$v and ($same or $v > 1)and $str="  ($same same tag" .($same==1 ? '' : 's').')';if (not $allGroup){print$fp "---- $g2 ----$str\\n" if$g2 and ($str or @diffs)}elsif ($str and $g2){printf$fp "   %-13s%s\\n",$g2,$str}@diffs and print($fp @diffs),$wasDiff=1,@diffs=();last unless$g;($g2,$same)=($g,0);@groupTags2=();push@groupTags2,$tag2 if defined$tag2;for$t2 (@found2){$done2{$t2}or $g ne $et2->GetGroup($t2,$showGroup)or push@groupTags2,$t2}}next unless defined$tag;my$val=$et->GetValue($tag);next unless defined$val;my$name=GetTagName($tag);my$desc=$outFormat < 1 ? $et->GetDescription($tag): $name;my@tags2=grep /^$name( |$)/,@groupTags2;T2: foreach$t2 (@tags2){next if$done2{$t2};$tag2=$t2;$val2=$et2->GetValue($t2);next unless defined$val2;IsEqual($val,$val2)and $equal=1,last;if ($$et{DUPL_TAG}{$name}and not @dupl){for ($i=0,$key=$name;$i<=$$et{DUPL_TAG}{$name};++$i,$key="$name ($i)"){push@dupl,$key unless$done{$key}or $g ne $et->GetGroup($key,$showGroup)}@dupl=sort {$$et{FILE_ORDER}{$a}<=> $$et{FILE_ORDER}{$b}}@dupl if@dupl > 1}for (@dupl){next if$used{$_};my$v=$et->GetValue($_);next unless defined($v)and IsEqual($v,$val2);$used{$_}=1;undef($tag2);undef($val2);next T2}last}if ($equal){++$same}else {my$len=LengthUTF8($desc);my$pad=$outFormat < 2 ? ' ' x ($len < 32 ? 32 - $len : 0): '';if ($allGroup){my$grp="[$g]";$grp .= ' ' x (15 - length($grp))if length($grp)< 15 and $outFormat < 2;push@diffs,sprintf "< %s %s%s: %s\\n",$grp,$desc,$pad,Printable($val);if (defined$val2){$grp=' ' x length($grp),$desc=' ' x $len if$v < 3;push@diffs,sprintf "> %s %s%s: %s\\n",$grp,$desc,$pad,Printable($val2)}}else {push@diffs,sprintf "< %s%s: %s\\n",$desc,$pad,Printable($val);$desc=' ' x $len if$v < 3;push@diffs,sprintf "> %s%s: %s\\n",$desc,$pad,Printable($val2)if defined$val2}}$done2{$tag2}=1 if defined$tag2}print$fp "(no metadata differences)\\n" unless$wasDiff;if (defined$outfile){$created{$outfile}=1;close($fp);undef$tmpText}++$count;return}$comma=$outComma{$outfile}if$append and ($textOverwrite & 0x02);if (%printFmt){my ($type,$doc,$grp,$lastDoc,$cache);$fileTrailer='';if ($et->Options('ExtractEmbedded')){$lastDoc=$$et{DOC_COUNT}and $cache={}}else {$lastDoc=0}for ($doc=0;$doc<=$lastDoc;++$doc){my ($skipBody,$opt);for$type (qw(HEAD SECT IF BODY ENDS TAIL)){my$prf=$printFmt{$type}or next;if ($type eq 'HEAD' and defined$outfile){next if$wroteHEAD{$outfile};$wroteHEAD{$outfile}=1}next if$type eq 'BODY' and $skipBody;if ($type eq 'IF' or ($doc > 1 and not $$et{OPTIONS}{IgnoreMinorErrors})){$opt='Silent'}else {$opt='Warn'}if ($lastDoc){if ($doc){next if$type eq 'HEAD' or $type eq 'TAIL';$grp="Doc$doc"}else {$grp='Main'}}my@lines;for (@$prf){my$line=$et->InsertTagValues($_,\\@foundTags,$opt,$grp,$cache);if ($type eq 'IF'){$skipBody=1 unless defined$line}elsif (defined$line){push@lines,$line}}$lineCount += scalar@lines;if ($type eq 'SECT'){my$thisHeader=join '',@lines;if ($sectHeader and $sectHeader ne $thisHeader){print$fp $sectTrailer if$sectTrailer;undef$sectHeader}$sectTrailer='';print$fp $sectHeader=$thisHeader unless$sectHeader}elsif ($type eq 'ENDS'){$sectTrailer .= join '',@lines if defined$sectHeader}elsif ($type eq 'TAIL'){$fileTrailer .= join '',@lines}elsif (@lines){print$fp @lines}}}delete$printFmt{HEAD}unless defined$outfile;my$errs=$et->GetInfo('Warning','Error');PrintErrors($et,$errs,$file)and EFile($file)}elsif ($plot){my$tagExtra=$$et{TAG_EXTRA};my ($tag,%docNum);for$tag (keys %$info){next unless $$tagExtra{$tag}and $$tagExtra{$tag}{G3};$docNum{$tag}=$1 if $$tagExtra{$tag}{G3}=~ /(\\d+)/}$$plot{DocNum}=\\%docNum;$$plot{EE}=1 if$et->Options('ExtractEmbedded');$plot->AddPoints($info,\\@foundTags)}elsif (not $disableOutput){my ($tag,$line,%noDups,%csvInfo,$bra,$ket,$sep,$quote);if ($fp){if ($fileHeader){print$fp $fileHeader unless defined$outfile and ($created{$outfile}or $appended{$outfile});undef$fileHeader unless$textOut}if ($html){print$fp "<table>\\n"}elsif ($xml){my$f=$file;CleanXML(\\$f);print$fp "\\n<rdf:Description rdf:about='\${f}'";print$fp "\\n  xmlns:et='http://ns.exiftool.org/1.0/'";print$fp " et:toolkit='Image::ExifTool $Image::ExifTool::VERSION'";my (%groups,@groups,$grp0,$grp1);for$tag (@foundTags){($grp0,$grp1)=$et->GetGroup($tag);unless ($grp1){next unless defined$forcePrint;$grp0=$grp1='Unknown'}AddGroups($$info{$tag},$grp0,\\%groups,\\@groups)if ref $$info{$tag};next if$groups{$grp1};$groups{$grp1}=$grp0;push@groups,$grp1}for$grp1 (@groups){my$grp=$groups{$grp1};unless ($grp eq $grp1 and $grp =~ /^(ExifTool|File|Composite|Unknown)$/){$grp .= "/$grp1"}print$fp "\\n  xmlns:$grp1='http://ns.exiftool.org/$grp/1.0/'"}print$fp '>' if$outFormat < 1;$ind=$outFormat >= 0 ? ' ' : '   '}elsif ($json){($bra,$ket,$sep)=$json==1 ? ('{','}',':'): ('Array(',')',' =>');$quote=1 if $$et{OPTIONS}{StructFormat}and $$et{OPTIONS}{StructFormat}eq 'JSONQ';print$fp ",\\n" if$comma;print$fp qq($bra\\n  "SourceFile"$sep ),EscapeJSON(MyConvertFileName($et,$file),1);$comma=1;$ind=(defined$showGroup and not $allGroup)? '    ' : '  '}elsif ($csv){my$file2=MyConvertFileName($et,$file);$database{$file2}=\\%csvInfo;push@csvFiles,$file2}}my$noDups=($json or ($xml and $outFormat > 0));my$printConv=$et->Options('PrintConv');my$lastGroup='';my$i=-1;TAG: foreach$tag (@foundTags){++$i;my$tagName=GetTagName($tag);my ($group,$valList);my$val=$$info{$tag};$isBinary=(ref$val eq 'SCALAR' and defined$binaryOutput);if (ref$val){if (defined$binaryOutput and not $binaryOutput and $$et{TAG_INFO}{$tag}{Protected}){my$lcTag=lc$tag;$lcTag =~ s/ .*//;next unless $$et{REQ_TAG_LOOKUP}{$lcTag}or ($$et{OPTIONS}{RequestAll}|| 0)> 2}$val=ConvertBinary($val);next unless defined$val;if ($structOpt and ref$val){$val=Image::ExifTool::XMP::SerializeStruct($et,$val)unless$xml or $json}elsif (ref$val eq 'ARRAY'){if (defined$listItem){$val=$$val[$listItem]}elsif ($binaryOutput){if ($tagOut){$valList=$val;$val=shift @$valList}else {$val=join defined$binSep ? $binSep : "\\n",@$val}}elsif ($joinLists){$val=join$listSep,@$val}}}if (not defined$val){next if$binaryOutput;if (defined$forcePrint){$val=$forcePrint}elsif (not $csv){next}}if (defined$showGroup){$group=$et->GetGroup($tag,$showGroup);next if$noDups and $tag =~ /^(.*?) ?\\(/ and defined $$info{$1}and $group eq $et->GetGroup($1,$showGroup);if (not $group and ($xml or $json or $csv)){if ($showGroup !~ /\\b4\\b/){$group='Unknown'}elsif ($json and not $allGroup){$group='Copy0'}}if ($fp and not ($allGroup or $csv)){if ($lastGroup ne $group){if ($html){my$cols=1;++$cols if$outFormat==0 or $outFormat==1;++$cols if$showTagID;print$fp "<tr><td colspan=$cols bgcolor='#dddddd'>$group</td></tr>\\n"}elsif ($json){print$fp "\\n  $ket" if$lastGroup;print$fp ',' if$lastGroup or $comma;print$fp qq(\\n  "$group"$sep $bra);undef$comma;undef%noDups}else {print$fp "---- $group ----\\n"}$lastGroup=$group}undef$group}}elsif ($noDups){next if$tag =~ /^(.*?) ?\\(/ and defined $$info{$1}}++$lineCount;for (;;){if ($tagOut){my$ext=SuggestedExtension($et,\\$val,$tagName);if (%wext and ($wext{$ext}|| $wext{'*'}|| -1)< 0){if ($verbose and $verbose > 1){print$vout "Not writing $ext output file for $tagName\\n"}next TAG}my@groups=$et->GetGroup($tag);defined$outfile and close($fp),undef($tmpText);my$org=$et->GetValue('OriginalRawFileName')|| $et->GetValue('OriginalFileName');($fp,$outfile,$append)=OpenOutputFile($orig,$tagName,\\@groups,$ext,$org);$fp or ++$countBad,next TAG;$tmpText=$outfile unless$append}if ($binaryOutput){print$fp $val;print$fp $binTerm if defined$binTerm;if ($tagOut){if ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}close($fp);undef$tmpText;$verbose and print$vout "Wrote $tagName to $outfile\\n";undef$outfile;undef$fp;next TAG unless$valList and @$valList;$val=shift @$valList;next}next TAG}last}if ($csv){my$tn=$tagName;$tn .= '#' if$tag =~ /#/;my$gt=$group ? "$group:$tn" : $tn;my$lcTag=lc$gt;next if defined$csvInfo{$lcTag}and $tag =~ /\\(/;$csvInfo{$lcTag}=$val;if (defined$csvTags{$lcTag}){$csvTags{$lcTag}=$gt if defined $$info{$tag};next}if ($group and defined$csvTags[$i]and $csvTags[$i]=~ /^(.*):$tn$/i){next if$group eq 'Unknown';if ($1 eq 'unknown'){delete$csvTags{$csvTags[$i]};$csvTags{$lcTag}=defined($val)? $gt : '';$csvTags[$i]=$lcTag;next}}$csvTags{$lcTag}=defined($val)? $gt : '';if (@csvFiles==1){push@csvTags,$lcTag}elsif (@csvTags){undef@csvTags}next}my$desc=$outFormat > 0 ? $tagName : $et->GetDescription($tag);if ($xml){my$tok="$group:$tagName";if ($outFormat > 0){if ($structOpt and ref$val){$val=Image::ExifTool::XMP::SerializeStruct($et,$val)}if ($escapeHTML){$val =~ tr/\\0-\\x08\\x0b\\x0c\\x0e-\\x1f/./;Image::ExifTool::XMP::FixUTF8(\\$val)unless$altEnc;$val=Image::ExifTool::HTML::EscapeHTML($val,$altEnc)}else {CleanXML(\\$val)}unless ($noDups{$tok}){$isCRLF and $val =~ s/\\x0d\\x0a/\\x0a/g;print$fp "\\n $tok='\${val}'";$noDups{$tok}=1}next}my ($xtra,$valNum,$descClose);if ($showTagID){my ($id,$lang)=$et->GetTagID($tag);if ($id =~ /^\\d+$/){$id=sprintf("0x%.4x",$id)if$showTagID eq 'H'}else {$id=Image::ExifTool::XMP::FullEscapeXML($id)}$xtra=" et:id='\${id}'";$xtra .= " xml:lang='\${lang}'" if$lang}else {$xtra=''}if ($tabFormat){my$table=$et->GetTableName($tag);my$index=$et->GetTagIndex($tag);$xtra .= " et:table='\${table}'";$xtra .= " et:index='\${index}'" if defined$index}my$lastVal=$val;for ($valNum=0;$valNum<2;++$valNum){$val=FormatXML($val,$ind,$group);$isCRLF and $val =~ s/\\x0d\\x0a/\\x0a/g;if ($outFormat >= 0){print$fp "\\n <$tok$xtra$val</$tok>";last}elsif ($valNum==0){CleanXML(\\$desc);if ($xtra){print$fp "\\n <$tok>";print$fp "\\n  <rdf:Description$xtra>";$descClose="\\n  </rdf:Description>"}else {print$fp "\\n <$tok rdf:parseType='Resource'>";$descClose=''}print$fp "\\n   <et:desc>$desc</et:desc>";if ($printConv){print$fp "\\n   <et:prt$val</et:prt>";$val=$et->GetValue($tag,'ValueConv');$val='' unless defined$val;next unless IsEqual($val,$lastVal);print$fp "$descClose\\n </$tok>";last}}print$fp "\\n   <et:val$val</et:val>";print$fp "$descClose\\n </$tok>";last}next}elsif ($json){my$tok=$allGroup ? "$group:$tagName" : $tagName;next if$noDups{$tok};$noDups{$tok}=1;print$fp ',' if$comma;print$fp qq(\\n$ind"$tok"$sep );if ($showTagID or $outFormat < 0){$val={val=>$val };if ($showTagID){my ($id,$lang)=$et->GetTagID($tag);$id=sprintf('0x%.4x',$id)if$showTagID eq 'H' and $id =~ /^\\d+$/;$$val{lang}=$lang if$lang;$$val{id}=$id}if ($tabFormat){$$val{table}=$et->GetTableName($tag);my$index=$et->GetTagIndex($tag);$$val{index}=$index if defined$index}if ($outFormat < 0){$$val{desc}=$desc;if ($printConv){my$num=$et->GetValue($tag,'ValueConv');$$val{num}=$num if defined$num and not IsEqual($num,$$val{val})}my$ex=$$et{TAG_EXTRA}{$tag};$$val{'fmt'}=$$ex{G6}if defined $$ex{G6};if (defined $$ex{BinVal}){my$max=($$et{OPTIONS}{LimitLongValues}- 5)/ 3;if ($max >= 0 and length($$ex{BinVal})> int($max)){$max=int$max;$$val{'hex'}=join ' ',unpack("(H2)$max",$$ex{BinVal}),'[...]'}else {$$val{'hex'}=join ' ',unpack '(H2)*',$$ex{BinVal}}}}}FormatJSON($fp,$val,$ind,$quote);$comma=1;next}my$id;if ($showTagID){$id=$et->GetTagID($tag);if ($id =~ /^(\\d+)(\\.\\d+)?$/){$id=sprintf("0x%.4x",$1)if$showTagID eq 'H'}else {$id='-'}}if ($escapeC){$val =~ s/([\\0-\\x1f\\\\\\x7f])/$escC{$1} || sprintf('\\x%.2x', ord $1)/eg}else {$val =~ tr/\\x01-\\x1f\\x7f/./;$val =~ s/\\x00//g;$val =~ s/\\s+$//}if ($html){print$fp "<tr>";print$fp "<td>$group</td>" if defined$group;print$fp "<td>$id</td>" if$showTagID;print$fp "<td>$desc</td>" if$outFormat <= 1;print$fp "<td>$val</td></tr>\\n"}else {my$buff='';if ($tabFormat){$buff="$group\\t" if defined$group;$buff .= "$id\\t" if$showTagID;if ($outFormat <= 1){$buff .= "$desc\\t$val\\n"}elsif (defined$line){$line .= "\\t$val"}else {$line=$val}}elsif ($outFormat < 0){$buff="[$group] " if defined$group;$buff .= "$id " if$showTagID;$buff .= "$desc\\n      $val\\n"}elsif ($outFormat==0 or $outFormat==1){my$wid;my$len=0;if (defined$group){$buff=sprintf("%-15s ","[$group]");$len=16}if ($showTagID){$wid=($showTagID eq 'D')? 5 : 6;$len += $wid + 1;($wid=$len - length($buff)- 1)< 1 and $wid=1;$buff .= sprintf "%\${wid}s ",$id}$wid=32 - (length($buff)- $len);my$padLen=$wid - LengthUTF8($desc);$padLen=0 if$padLen < 0;$buff .= $desc .(' ' x $padLen).": $val\\n"}elsif ($outFormat==2){$buff="[$group] " if defined$group;$buff .= "$id " if$showTagID;$buff .= "$tagName: $val\\n"}elsif ($argFormat){$buff='-';$buff .= "$group:" if defined$group;$tagName .= '#' if$tag =~ /#/;$buff .= "$tagName=$val\\n"}else {$buff="$group " if defined$group;$buff .= "$id " if$showTagID;$buff .= "$val\\n"}print$fp $buff}if ($tagOut){if ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}close($fp);undef$tmpText;$verbose and print$vout "Wrote $tagName to $outfile\\n";undef$outfile;undef$fp}}if ($fp){if ($html){print$fp "</table>\\n"}elsif ($xml){print$fp $outFormat < 1 ? "\\n</rdf:Description>\\n" : "/>\\n"}elsif ($json){print$fp "\\n  $ket" if$lastGroup;print$fp "\\n$ket";$comma=1}elsif ($tabFormat and $outFormat > 1){print$fp "$line\\n" if defined$line}}}if (defined$outfile){if ($textOverwrite & 0x02){$outComma{$outfile}=$comma;$outTrailer{$outfile}='';$outTrailer{$outfile}.= $sectTrailer and $sectTrailer='' if$sectTrailer;$outTrailer{$outfile}.= $fileTrailer if$fileTrailer}else {print$fp $sectTrailer and $sectTrailer='' if$sectTrailer;print$fp $fileTrailer if$fileTrailer}close($fp);undef$tmpText;if ($lineCount){if ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}}else {$et->Unlink($outfile)unless$append}undef$comma}++$count}sub SetImageInfo($$$) {my ($et,$file,$orig)=@_;my ($outfile,$restored,$isTemporary,$isStdout,$outType,$tagsFromSrc);my ($hardLink,$symLink,$testName,$sameFile);my$infile=$file;if (defined$tmpFile){$et->Unlink($tmpFile);undef$tmpFile}delete $$et{VALUE}{Error};delete $$et{VALUE}{Warning};if (defined$outOpt){if ($outOpt =~ /^-(\\.\\w+)?$/){$outType=GetFileType($outOpt)if $1;$outfile='-';$isStdout=1}else {$outfile=FilenameSPrintf($outOpt,$orig);if ($outfile eq ''){Warn "Error: Can't create file with zero-length name from $orig\\n";EFile($infile);++$countBadCr;return 0}}if (not $isStdout and (($et->IsDirectory($outfile)and not $listDir)or $outfile =~ /\\/$/)){$outfile .= '/' unless$outfile =~ /\\/$/;my$name=$file;$name =~ s/^.*\\///s;$outfile .= $name}else {my$srcType=GetFileType($file)|| '';$outType or $outType=GetFileType($outfile);if ($outType and ($srcType ne $outType or $outType eq 'ICC')and $file ne '-'){unless (CanCreate($outType)){my$what=$srcType ? 'other types' : 'scratch';WarnOnce "Error: Can't create $outType files from $what\\n";EFile($infile);++$countBadCr;return 0}if ($file ne ''){$et->RestoreNewValues()unless$restored;$restored=1;my@setTags=@tags;for (@exclude){push@setTags,"-$_"}my%forceCopy=(ICC=>'ICC_Profile',VRD=>'CanonVRD',DR4=>'CanonDR4',);push@setTags,$forceCopy{$outType}if$forceCopy{$outType};if (not %setTags or (@setTags and not $setTags{'@'})){return 0 unless DoSetFromFile($et,$file,\\@setTags)}elsif (@setTags){push@setTags,@{$setTags{'@'}};$tagsFromSrc=\\@setTags}$file=''}}}unless ($isStdout){$outfile=NextUnusedFilename($outfile);if ($et->Exists($outfile,1)and not $doSetFileName){Warn "Error: '\${outfile}' already exists - $infile\\n";EFile($infile);++$countBadWr;return 0}}}elsif ($file eq '-'){$isStdout=1}if (@dynamicFiles){$et->RestoreNewValues()unless$restored;my ($dyFile,%setTagsIndex);for$dyFile (@dynamicFiles){if (not ref$dyFile){my ($fromFile,$setTags);if ($dyFile eq '@'){$fromFile=$orig;$setTags=$tagsFromSrc || $setTags{$dyFile}}else {$fromFile=FilenameSPrintf($dyFile,$orig);defined$fromFile or EFile($infile),++$countBadWr,return 0;$setTags=$setTags{$dyFile}}if ($setTagsList{$dyFile}){my$i=$setTagsIndex{$dyFile}|| 0;$setTagsIndex{$dyFile}=$i + 1;$setTags=$setTagsList{$dyFile}[$i]if$setTagsList{$dyFile}[$i]}return 0 unless DoSetFromFile($et,$fromFile,$setTags)}elsif (ref$dyFile eq 'ARRAY'){my$fname=FilenameSPrintf($$dyFile[1],$orig);my ($buff,$rtn,$wrn);my$opts=$$dyFile[2];if (defined$fname and SlurpFile($fname,\\$buff)){$verbose and print$vout "Reading $$dyFile[0] from $fname\\n";($rtn,$wrn)=$et->SetNewValue($$dyFile[0],$buff,%$opts);$wrn and Warn "$wrn\\n"}$rtn or $et->SetNewValue($$dyFile[0],undef,Replace=>2,ProtectSaved=>$$opts{ProtectSaved});next}elsif (ref$dyFile eq 'SCALAR'){my ($f,$found,$csvTag,$tryTag,$tg);undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my$old=$et->Options('Charset');$et->Options(Charset=>'UTF8')if$csv eq 'JSON';for$f ('*',MyConvertFileName($et,$file)){my$csvInfo=$database{$f};unless ($csvInfo){next if$f eq '*';my$absPath=AbsPath($f);next unless defined$absPath and $csvInfo=$database{$absPath}}$found=1;if ($verbose){print$vout "Setting new values from $csv database\\n";print$vout 'Including tags: ',join(' ',@tags),"\\n" if@tags;print$vout 'Excluding tags: ',join(' ',@exclude),"\\n" if@exclude}my@tryTags=(@exclude,@tags);for (@tryTags){tr/-0-9a-zA-Z_:#?*//dc;s/(^|:)(all:)+/$1/ig;s/(^|:)all(#?)$/$1*$2/i;tr/?/./;s/\\*/.*/g}for$csvTag (OrderedKeys($csvInfo)){next if$csvTag =~ /^([-_0-9A-Z]+:)*(SourceFile|Directory|FileName)$/i;if (@tryTags){my ($i,$tryGrp,$matched);TryMatch: for ($i=0;$i<@tryTags;++$i){$tryTag=$tryTags[$i];if ($tryTag =~ /:/){next unless$csvTag =~ /:/;my@csvGrps=split /:/,$csvTag;my@tryGrps=split /:/,$tryTag;my$tryName=pop@tryGrps;next unless pop(@csvGrps)=~ /^$tryName$/i;for$tryGrp (@tryGrps){next TryMatch unless grep /^$tryGrp$/i,@csvGrps}$matched=1;last}$csvTag =~ /^([-_0-9A-Z]+:)*$tryTag$/i and $matched=1,last}next if$matched ? $i < @exclude : @tags}my ($rtn,$wrn)=$et->SetNewValue($csvTag,$$csvInfo{$csvTag},Protected=>1,AddValue=>$csvAdd,ProtectSaved=>$csvSaveCount);$wrn and Warn "$wrn\\n" if$verbose}}$et->Options(Charset=>$old)if$csv eq 'JSON';unless ($found){Warn("No SourceFile '\${file}' in imported $csv database\\n");my$absPath=AbsPath($file);Warn("(full path: '\${absPath}')\\n")if defined$absPath and $absPath ne $file;return 0}}}}if ($isStdout){$outfile=\\*STDOUT;unless ($binaryStdout){binmode(STDOUT);$binaryStdout=1}}else {$hardLink=$et->GetNewValues('HardLink');$symLink=$et->GetNewValues('SymLink');$testName=$et->GetNewValues('TestName');$hardLink=FilenameSPrintf($hardLink,$orig)if defined$hardLink;$symLink=FilenameSPrintf($symLink,$orig)if defined$symLink;my$newFileName=$et->GetNewValues('FileName');my$newDir=$et->GetNewValues('Directory');if (defined$newFileName and not length$newFileName){Warning($et,"New file name is empty - $infile");undef$newFileName}if (defined$testName){my$err;$err="You shouldn't write FileName or Directory with TestFile" if defined$newFileName or defined$newDir;$err="The -o option shouldn't be used with TestFile" if defined$outfile;$err and Warn("Error: $err - $infile\\n"),EFile($infile),++$countBadWr,return 0;$testName=FilenameSPrintf($testName,$orig);$testName=Image::ExifTool::GetNewFileName($file,$testName)if$file ne ''}if (defined$newFileName or defined$newDir or ($doSetFileName and defined$outfile)){if ($newFileName){$newFileName=FilenameSPrintf($newFileName,$orig);if (defined$outfile){$outfile=Image::ExifTool::GetNewFileName($file,$outfile)if$file ne '';$outfile=Image::ExifTool::GetNewFileName($outfile,$newFileName)}elsif ($file ne ''){$outfile=Image::ExifTool::GetNewFileName($file,$newFileName)}}if ($newDir){$newDir=FilenameSPrintf($newDir,$orig);$outfile=Image::ExifTool::GetNewFileName(defined$outfile ? $outfile : $file,$newDir)}$outfile=NextUnusedFilename($outfile,$infile);if ($et->Exists($outfile,1)){if ($infile eq $outfile){undef$outfile}elsif ($et->IsSameFile($infile,$outfile)){$sameFile=$outfile}else {Warn "Error: '\${outfile}' already exists - $infile\\n";EFile($infile);++$countBadWr;return 0}}}if (defined$outfile){defined$verbose and print$vout "'\${infile}' --> '\${outfile}'\\n";CreateDirectory($outfile);$tmpFile=$outfile if defined$outOpt}unless (defined$tmpFile){my ($numSet,$numPseudo)=$et->CountNewValues();if ($numSet!=$numPseudo and $et->IsDirectory($file)){print$vout "Can't write real tags to a directory - $infile\\n" if defined$verbose;$numSet=$numPseudo}if ($et->Exists($file)){unless ($numSet){print$vout "Nothing changed in $file\\n" if defined$verbose;EFile($infile,1);++$countSameWr;return 1}}elsif (CanCreate($file)){if ($numSet==$numPseudo){Warn("Error: Nothing to write - $file\\n");EFile($infile,1);++$countBadWr;return 0}unless (defined$outfile){$outfile=$file;$file=''}}else {Warn "Error: File not found - $file\\n";EFile($infile);FileNotFound($file);++$countBadWr;return 0}if ($numSet==$numPseudo){my ($r0,$r1,$r2,$r3)=(0,0,0,0);if (defined$outfile){$r0=$et->SetFileName($file,$outfile);$file=$$et{NewName}if$r0 > 0}unless ($r0 < 0){$r1=$et->SetFileModifyDate($file,undef,'FileCreateDate');$r2=$et->SetFileModifyDate($file);$r3=$et->SetSystemTags($file)}if ($r0 > 0 or $r1 > 0 or $r2 > 0 or $r3 > 0){EFile($infile,3);++$countGoodWr}elsif ($r0 < 0 or $r1 < 0 or $r2 < 0 or $r3 < 0){EFile($infile);++$countBadWr;return 0}else {EFile($infile,1);++$countSameWr}if (defined$hardLink or defined$symLink or defined$testName){DoHardLink($et,$file,$hardLink,$symLink,$testName)}return 1}if (not defined$outfile or defined$sameFile){$outfile="\${file}_exiftool_tmp";if ($et->Exists($outfile)){Warn("Error: Temporary file already exists: $outfile\\n");EFile($infile);++$countBadWr;return 0}$isTemporary=1}$tmpFile=$outfile}}my$success=$et->WriteInfo(Infile($file),$outfile,$outType);if ($success and (defined$hardLink or defined$symLink or defined$testName)){my$src=defined$outfile ? $outfile : $file;DoHardLink($et,$src,$hardLink,$symLink,$testName)}my ($aTime,$mTime,$cTime,$doPreserve);$doPreserve=$preserveTime unless$file eq '';if ($doPreserve and $success){($aTime,$mTime,$cTime)=$et->GetFileTime($file);undef$cTime if $$et{WRITTEN}{FileCreateDate};if ($$et{WRITTEN}{FileModifyDate}or $doPreserve==2){if (defined$cTime){undef$aTime;undef$mTime}else {undef$doPreserve}}}if ($success==1){if (defined$tmpFile){if ($et->Exists($file)){$et->SetFileTime($tmpFile,$aTime,$mTime,$cTime)if$doPreserve;if ($isTemporary){$et->CopyFileAttrs($file,$outfile);my$original="\${file}_original";if (not $overwriteOrig and not $et->Exists($original)){if (not $et->Rename($file,$original)or $et->Exists($file)){Error "Error renaming $file\\n";return 0}}my$dstFile=defined$sameFile ? $sameFile : $file;if ($overwriteOrig > 1){my ($err,$buff);my$newFile=$tmpFile;$et->Open(\\*NEW_FILE,$newFile)or Error("Error opening $newFile\\n"),return 0;binmode(NEW_FILE);$critical=1;undef$tmpFile;if ($et->Open(\\*ORIG_FILE,$file,'+<')){binmode(ORIG_FILE);while (read(NEW_FILE,$buff,65536)){print ORIG_FILE$buff or $err=1}close(NEW_FILE);eval {truncate(ORIG_FILE,tell(ORIG_FILE))}or $err=1;close(ORIG_FILE)or $err=1;if ($err){Warn "Couldn't overwrite in place - $file\\n";unless ($et->Rename($newFile,$file)or ($et->Unlink($file)and $et->Rename($newFile,$file))){Error("Error renaming $newFile to $file\\n");undef$critical;SigInt()if$interrupted;return 0}}else {$et->SetFileModifyDate($file,$cTime,'FileCreateDate',1);$et->SetFileModifyDate($file,$mTime,'FileModifyDate',1);$et->Unlink($newFile);if ($doPreserve){$et->SetFileTime($file,$aTime,$mTime,$cTime);$preserveTime{$file}=[$aTime,$mTime,$cTime ]}}EFile($infile,3);++$countGoodWr}else {close(NEW_FILE);Warn "Error opening $file for writing\\n";EFile($infile);$et->Unlink($newFile);++$countBadWr}undef$critical;SigInt()if$interrupted}elsif ($et->Rename($tmpFile,$dstFile)){EFile($infile,3);++$countGoodWr}else {my$newFile=$tmpFile;undef$tmpFile;if (not $et->Unlink($file)){Warn "Error renaming temporary file to $dstFile\\n";EFile($infile);$et->Unlink($newFile);++$countBadWr}elsif (not $et->Rename($newFile,$dstFile)){Warn "Error renaming temporary file to $dstFile\\n";EFile($infile);++$countBadWr}else {EFile($infile,3);++$countGoodWr}}}elsif ($overwriteOrig){EFile($infile,3);$et->Unlink($file)or Warn "Error erasing original $file\\n";++$countGoodWr}else {EFile($infile,4);++$countGoodCr}}else {EFile($infile,4);++$countGoodCr}}else {EFile($infile,3);++$countGoodWr}}elsif ($success){EFile($infile,1);if ($isTemporary){$et->Unlink($tmpFile);++$countSameWr}else {$et->SetFileTime($outfile,$aTime,$mTime,$cTime)if$doPreserve;if ($overwriteOrig){$et->Unlink($file)or Warn "Error erasing original $file\\n"}++$countCopyWr}print$vout "Nothing changed in $file\\n" if defined$verbose}else {EFile($infile);$et->Unlink($tmpFile)if defined$tmpFile;++$countBadWr}undef$tmpFile;return$success}sub DoHardLink($$$$$) {my ($et,$src,$hardLink,$symLink,$testName)=@_;if (defined$hardLink){$hardLink=NextUnusedFilename($hardLink);if ($et->SetFileName($src,$hardLink,'Link')> 0){$countLink{Hard}=($countLink{Hard}|| 0)+ 1}else {$countLink{BadHard}=($countLink{BadHard}|| 0)+ 1}}if (defined$symLink){$symLink=NextUnusedFilename($symLink);if ($et->SetFileName($src,$symLink,'SymLink')> 0){$countLink{Sym}=($countLink{Sym}|| 0)+ 1}else {$countLink{BadSym}=($countLink{BadSym}|| 0)+ 1}}if (defined$testName){$testName=NextUnusedFilename($testName,$src);if ($usedFileName{$testName}){$et->Warn("File '\${testName}' would exist")}elsif ($et->SetFileName($src,$testName,'Test',$usedFileName{$testName})==1){$usedFileName{$testName}=1;$usedFileName{$src}=0}}}sub CleanXML($) {my$strPt=shift;$$strPt =~ tr/\\0-\\x08\\x0b\\x0c\\x0e-\\x1f/./;Image::ExifTool::XMP::FixUTF8($strPt)unless$altEnc;$$strPt=Image::ExifTool::XMP::EscapeXML($$strPt)}sub EncodeXML($) {my$strPt=shift;if ($$strPt =~ /[\\0-\\x08\\x0b\\x0c\\x0e-\\x1f]/ or (not $altEnc and Image::ExifTool::IsUTF8($strPt)< 0)){$$strPt=Image::ExifTool::XMP::EncodeBase64($$strPt);return 'http://www.w3.org/2001/XMLSchema#base64Binary'}elsif ($escapeHTML){$$strPt=Image::ExifTool::HTML::EscapeHTML($$strPt,$altEnc)}else {$$strPt=Image::ExifTool::XMP::EscapeXML($$strPt)}return ''}sub FormatXML($$$) {local $_;my ($val,$ind,$grp)=@_;my$gt='>';if (ref$val eq 'ARRAY'){my$val2="\\n$ind <rdf:Bag>";for (@$val){$val2 .= "\\n$ind  <rdf:li" .FormatXML($_,"$ind  ",$grp)."</rdf:li>"}$val="$val2\\n$ind </rdf:Bag>\\n$ind"}elsif (ref$val eq 'HASH'){$gt=" rdf:parseType='Resource'>";my$val2='';for (OrderedKeys($val)){my ($ns,$tg)=($grp,$_);if (/^(.*?):(.*)/){if ($grp eq 'JSON'){$tg =~ tr/:/_/}else {($ns,$tg)=($1,$2)}}my$name;for$name ($ns,$tg){$name =~ tr/-_A-Za-z0-9.//dc;$name='_' .$name if$name !~ /^[_A-Za-z]/}my$tok=$ns .':' .$tg;$val2 .= "\\n$ind <$tok" .FormatXML($$val{$_},"$ind ",$grp)."</$tok>"}$val="$val2\\n$ind"}else {my$enc=EncodeXML(\\$val);$gt=" rdf:datatype='\${enc}'>\\n" if$enc}return$gt .$val}sub EscapeJSON($;$) {my ($str,$quote)=@_;unless ($quote){return lc($str)if$str =~ /^(true|false)$/i and $json < 2;return$str if$str =~ /^-?(\\d|[1-9]\\d{1,14})(\\.\\d{1,16})?(e[-+]?\\d{1,3})?$/i}if ($json < 2 and defined$binaryOutput and Image::ExifTool::IsUTF8(\\$str)< 0){return '"base64:' .Image::ExifTool::XMP::EncodeBase64($str,1).'"'}$str =~ s/(["\\t\\n\\r\\\\])/\\\\$jsonChar{$1}/sg;if ($json < 2){$str =~ tr/\\0//d;$str =~ s/([\\0-\\x1f\\x7f])/sprintf("\\\\u%.4X",ord $1)/sge;Image::ExifTool::XMP::FixUTF8(\\$str)unless$altEnc}else {$str =~ s/\\0+$// unless$isBinary;$str =~ s/\\$/\\\\\\$/sg;$str =~ s/([\\0-\\x1f\\x7f])/sprintf("\\\\x%.2X",ord $1)/sge}return '"' .$str .'"'}sub FormatJSON($$$;$) {local $_;my ($fp,$val,$ind,$quote)=@_;my$comma;if (not ref$val){print$fp EscapeJSON($val,$quote)}elsif (ref$val eq 'ARRAY'){if ($joinLists and not ref $$val[0]){print$fp EscapeJSON(join($listSep,@$val),$quote)}else {my ($bra,$ket)=$json==1 ? ('[',']'): ('Array(',')');print$fp $bra;for (@$val){print$fp ',' if$comma;FormatJSON($fp,$_,$ind,$quote);$comma=1,}print$fp $ket,}}elsif (ref$val eq 'HASH'){my ($bra,$ket,$sep)=$json==1 ? ('{','}',':'): ('Array(',')',' =>');print$fp $bra;for (OrderedKeys($val)){print$fp ',' if$comma;my$key=EscapeJSON($_,1);print$fp qq(\\n$ind  $key$sep );if ($showTagID and $_ eq 'id' and $showTagID eq 'H' and $$val{$_}=~ /^\\d+\\.\\d+$/){print$fp qq{"$$val{$_}"}}else {FormatJSON($fp,$$val{$_},"$ind  ",$quote)}$comma=1,}print$fp "\\n$ind$ket",}else {print$fp '"<err>"'}}sub FormatCSV($) {my$val=shift;if ($setCharset and ($val =~ /[^\\x09\\x0a\\x0d\\x20-\\x7e\\x80-\\xff]/ or ($setCharset eq 'UTF8' and Image::ExifTool::IsUTF8(\\$val)< 0))){$val='base64:' .Image::ExifTool::XMP::EncodeBase64($val,1)}$val=qq{"$val"} if$val =~ s/"/""/g or $val =~ /(^\\s+|\\s+$)/ or $val =~ /[\\n\\r]|\\Q$csvDelim/;return$val}sub PrintCSV(;$) {my$fp=shift || \\*STDOUT;my ($file,$lcTag,@tags);@csvTags or @csvTags=sort keys%csvTags;for$lcTag (@csvTags){push@tags,FormatCSV($csvTags{$lcTag})if$csvTags{$lcTag}}print$fp join($csvDelim,'SourceFile',@tags),"\\n";my$empty=defined($forcePrint)? $forcePrint : '';for$file (@csvFiles){my@vals=(FormatCSV($file));my$csvInfo=$database{$file};for$lcTag (@csvTags){next unless$csvTags{$lcTag};my$val=$$csvInfo{$lcTag};defined$val or push(@vals,$empty),next;push@vals,FormatCSV($val)}print$fp join($csvDelim,@vals),"\\n"}}sub AddGroups($$$$) {my ($val,$grp,$groupHash,$groupList)=@_;my ($key,$val2);if (ref$val eq 'HASH'){for$key (sort keys %$val){if ($key =~ /^(.*?):/ and not $$groupHash{$1}and $grp ne 'JSON'){$$groupHash{$1}=$grp;push @$groupList,$1}AddGroups($$val{$key},$grp,$groupHash,$groupList)if ref $$val{$key}}}elsif (ref$val eq 'ARRAY'){for$val2 (@$val){AddGroups($val2,$grp,$groupHash,$groupList)if ref$val2}}}sub ConvertBinary($) {my$obj=shift;my ($key,$val);if (ref$obj eq 'HASH'){for$key (keys %$obj){next unless ref $$obj{$key};$$obj{$key}=ConvertBinary($$obj{$key});return undef unless defined $$obj{$key}}}elsif (ref$obj eq 'ARRAY'){for$val (@$obj){next unless ref$val;$val=ConvertBinary($val);return undef unless defined$val}}elsif (ref$obj eq 'SCALAR'){return undef if$noBinary;if (defined$binaryOutput){$obj=$$obj;if ($json==1 and ($obj =~ /[^\\x09\\x0a\\x0d\\x20-\\x7e\\x80-\\xf7]/ or Image::ExifTool::IsUTF8(\\$obj)< 0)){$obj='base64:' .Image::ExifTool::XMP::EncodeBase64($obj,1)}}else {my$bOpt=$html ? '' : ', use -b option to extract';if ($$obj =~ /^Binary data \\d+ bytes$/){$obj="($$obj$bOpt)"}else {$obj='(Binary data ' .length($$obj)." bytes$bOpt)"}}}return$obj}sub IsEqual($$) {my ($a,$b)=@_;return 1 if$a eq $b or ref$a eq 'SCALAR';if (ref$a eq 'HASH' and ref$b eq 'HASH'){return 0 if scalar(keys %$a)!=scalar(keys %$b);my$key;for$key (keys %$a){return 0 unless IsEqual($$a{$key},$$b{$key})}}else {return 0 if ref$a ne 'ARRAY' or ref$b ne 'ARRAY' or @$a!=@$b;my$i;for ($i=0;$i<scalar(@$a);++$i){return 0 unless IsEqual($$a[$i],$$b[$i])}}return 1}sub Printable($) {my$val=shift;if (ref$val){if ($structOpt){require Image::ExifTool::XMP;$val=Image::ExifTool::XMP::SerializeStruct($mt,$val)}elsif (ref$val eq 'ARRAY'){$val=join($listSep,@$val)}elsif (ref$val eq 'SCALAR'){$val='(Binary data '.length($$val).' bytes)'}}if ($escapeC){$val =~ s/([\\0-\\x1f\\\\\\x7f])/$escC{$1} || sprintf('\\x%.2x', ord $1)/eg}else {$val =~ tr/\\x01-\\x1f\\x7f/./;$val =~ s/\\x00//g;$val =~ s/\\s+$//}return$val}sub LengthUTF8($) {my$str=shift;return length$str unless$fixLen;local$SIG{'__WARN__'}=sub {};if (not $$mt{OPTIONS}{EncodeHangs}and eval {require Encode}){$str=Encode::decode_utf8($str)}else {$str=pack('U0C*',unpack 'C*',$str)}my$len;if ($fixLen==1){$len=length$str}else {my$gcstr=eval {Unicode::GCString->new($str)};if ($gcstr){$len=$gcstr->columns}else {$len=length$str;delete$SIG{'__WARN__'};Warning($mt,'Unicode::GCString problem.  Columns may be misaligned');$fixLen=1}}return$len}sub AddSetTagsFile($;$) {my ($setFile,$opts)=@_;if ($setTags{$setFile}){$setTagsList{$setFile}or $setTagsList{$setFile}=[];push @{$setTagsList{$setFile}},$setTags{$setFile}}$setTags{$setFile}=[];push@newValues,{SaveCount=>++$saveCount },"TagsFromFile=$setFile";$opts or $opts={};$$opts{ProtectSaved}=$saveCount;push @{$setTags{$setFile}},$opts}sub Infile($;$) {my ($file,$bufferStdin)=@_;if ($file eq '-' and ($bufferStdin or $rafStdin)){if ($rafStdin){$rafStdin->Seek(0)}elsif (open RAF_STDIN,'-'){$rafStdin=File::RandomAccess->new(\\*RAF_STDIN);$rafStdin->BinMode()}return$rafStdin if$rafStdin}return$file}sub Warning($$) {my ($et,$str)=@_;my$noWarn=$et->Options('NoWarning');if (not defined$noWarn or not eval {$str =~ /$noWarn/}){Warn "Warning: $str\\n"}}sub DoSetFromFile($$$) {local $_;my ($et,$file,$setTags)=@_;$verbose and print$vout "Setting new values from $file\\n";my$info=$et->SetNewValuesFromFile(Infile($file,1),@$setTags);my$numSet=scalar(keys %$info);if ($$info{Error}){my@warns=grep /^(Error|Warning)\\b/,keys %$info;$numSet -= scalar(@warns);my$err=$$info{Error};delete $$info{$_}foreach@warns;my$noWarn=$et->Options('NoWarning');$$info{Warning}=$err unless defined$noWarn and eval {$err =~ /$noWarn/}}elsif ($$info{Warning}){my$warns=1;++$warns while $$info{"Warning ($warns)"};$numSet -= $warns}PrintErrors($et,$info,$file)and EFile($file),++$countBadWr,return 0;Warning($et,"No writable tags set from $file")unless$numSet;return 1}sub CleanFilename($) {$_[0]=~ tr/\\\\/\\// if Image::ExifTool::IsPC()}sub HasWildcards($) {my$path=shift;return 0 if $^O eq 'MSWin32' and $path =~ m{^[\\\\/]{2}\\?[\\\\/]};return$path =~ /[*?]/}sub CheckUTF8($$) {my ($file,$enc)=@_;my$isUTF8=0;if ($file =~ /[\\x80-\\xff]/){$isUTF8=Image::ExifTool::IsUTF8(\\$file);if ($isUTF8 < 0){if ($enc){Warn("Invalid filename encoding for $file\\n")}elsif (not defined$enc){WarnOnce(qq{FileName encoding not specified.  Use "-charset FileName=CHARSET"\\n})}}}return$isUTF8}sub SetWindowTitle($) {my$title=shift;if ($curTitle ne $title){$curTitle=$title;if ($^O eq 'MSWin32'){$title =~ s/([&\\/\\?:|"<>])/^$1/g;eval {system qq{title $title}}}else {printf STDERR "\\033]0;%s\\007",$title}}}sub ProcessFiles($;$) {my ($et,$list)=@_;my$enc=$et->Options('CharsetFileName');my$file;for$file (@files){$et->Options(CharsetFileName=>'UTF8')if$utf8FileName{$file};if (defined$progressMax){unless (defined$progressNext){$progressNext=$progressCount + $progressIncr;$progressNext -= $progressNext % $progressIncr;$progressNext=$progressMax if$progressNext > $progressMax}++$progressCount;if ($progress){if ($progressCount >= $progressNext){$progStr=" [$progressCount/$progressMax]"}else {undef$progStr}}}if ($et->IsDirectory($file)and not $listDir){$multiFile=$validFile=1;ScanDir($et,$file,$list)}elsif ($filterFlag and not AcceptFile($file)){if ($et->Exists($file)){$filtered=1;Progress($vout,"-------- $file (wrong extension)")if$verbose}else {Error "Error: File not found - $file\\n";FileNotFound($file)}}else {$validFile=1;if ($list){push(@$list,$file)}else {if (%endDir){my ($d,$f)=Image::ExifTool::SplitFileName($file);next if$endDir{$d}}GetImageInfo($et,$file);$end and Warn("End called - $file\\n");if ($endDir){Warn("EndDir called - $file\\n");my ($d,$f)=Image::ExifTool::SplitFileName($file);$endDir{$d}=1;undef$endDir}}}$et->Options(CharsetFileName=>$enc)if$utf8FileName{$file};last if$end}}sub ScanDir($$;$) {local $_;my ($et,$dir,$list)=@_;my (@fileList,$done,$file,$utf8Name,$winSurrogate,$endThisDir);my$enc=$et->Options('CharsetFileName');if ($enc){unless ($enc eq 'UTF8'){$dir=$et->Decode($dir,$enc,undef,'UTF8');$et->Options(CharsetFileName=>'UTF8')}$utf8Name=1}return if$ignore{$dir};if ($^O eq 'MSWin32' and not HasWildcards($dir)){undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};;if (CheckUTF8($dir,$enc)>= 0){if (eval {require Win32::FindFile}){eval {@fileList=Win32::FindFile::ReadDir($dir);$_=$_->cFileName foreach@fileList};$@ and $evalWarning=$@;if ($evalWarning){chomp$evalWarning;$evalWarning =~ s/ at .*//s;Warning($et,"[Win32::FindFile] $evalWarning - $dir");$winSurrogate=1 if$evalWarning =~ /surrogate/}else {$et->Options(CharsetFileName=>'UTF8');$utf8Name=1;$done=1}}else {$done=0}}}unless ($done){unless (opendir(DIR_HANDLE,$dir)){Warn("Error opening directory $dir\\n");return}@fileList=readdir(DIR_HANDLE);closedir(DIR_HANDLE);if (defined$done){for$file ($dir,@fileList){next unless$file =~ /[\\?\\x80-\\xff]/;WarnOnce("Install Win32::FindFile to support Windows Unicode file names in directories\\n");last}}}$dir =~ /\\/$/ or $dir .= '/';for$file (@fileList){next if$file eq '.' or $file eq '..';my$path="$dir$file";if ($et->IsDirectory($path)){next unless$recurse;next if$file =~ /^\\./ and $recurse==1;next if$ignore{$file}or ($ignore{SYMLINKS}and -l $path);ScanDir($et,$path,$list);last if$end;next}next if$endThisDir;next if$ignoreHidden and $file =~ /^\\./;my$accepted;if ($filterFlag){$accepted=AcceptFile($file)or next;$accepted &= 0x01}unless ($accepted){if ($scanWritable){if ($scanWritable eq '1'){next unless CanWrite($file)}else {my$type=GetFileType($file);next unless defined$type and $type eq $scanWritable}}elsif (not GetFileType($file)){next unless$doUnzip;next unless$file =~ /\\.(gz|bz2)$/i}}if ($winSurrogate and $isWriting and (not $overwriteOrig or $overwriteOrig!=2)and not $doSetFileName and $file =~ /~/){Warn("Not writing $path\\n");WarnOnce("Use -overwrite_original_in_place to write files with Unicode surrogate characters\\n");EFile($file);++$countBad;next}$utf8FileName{$path}=1 if$utf8Name;if ($list){push(@$list,$path)}else {GetImageInfo($et,$path);if ($end){Warn("End called - $file\\n");last}if ($endDir){$path =~ s(/$)();Warn("EndDir called - $path\\n");$endDir{$path}=1;$endThisDir=1;undef$endDir}}}++$countDir;$et->Options(CharsetFileName=>$enc)}sub FindFileWindows($$) {my ($et,$wildfile)=@_;my$enc=$et->Options('CharsetFileName');$wildfile=$et->Decode($wildfile,$enc,undef,'UTF8')if$enc and $enc ne 'UTF8';$wildfile =~ tr/\\\\/\\//;my ($dir,$wildname)=($wildfile =~ m{(.*[:/])(.*)})? ($1,$2): ('',$wildfile);if (HasWildcards($dir)){Warn "Wildcards don't work in the directory specification\\n";return ()}CheckUTF8($wildfile,$enc)>= 0 or return ();undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my@files;eval {my@names=Win32::FindFile::FindFile($wildfile)or return;@names=sort {uc($a)cmp uc($b)}@names;my ($rname,$nm);($rname=quotemeta$wildname)=~ s/\\\\\\?/./g;$rname =~ s/\\\\\\*/.*/g;for$nm (@names){$nm=$nm->cFileName;next unless$nm =~ /^$rname$/i;next if$nm eq '.' or $nm eq '..';my$file="$dir$nm";push@files,$file;$utf8FileName{$file}=1}};$@ and $evalWarning=$@;if ($evalWarning){chomp$evalWarning;$evalWarning =~ s/ at .*//s;Warn "Error: [Win32::FindFile] $evalWarning - $wildfile\\n";undef@files;EFile($wildfile);++$countBad}return@files}sub FileNotFound($) {my$file=shift;if ($file =~ /^(DIR|FILE)$/){my$type={DIR=>'directory',FILE=>'file' }->{$file};Warn qq{You were meant to enter any valid $type name, not "$file" literally.\\n}}}sub PreserveTime() {local $_;$mt->SetFileTime($_,@{$preserveTime{$_}})foreach keys%preserveTime;undef%preserveTime}sub AbsPath($) {my$file=shift;my$path;if (defined$file){return undef if$file eq '*';if ($^O eq 'MSWin32' and $mt->Options('WindowsLongPath')){$path=$mt->WindowsLongPath($file)}elsif (eval {require Cwd}){local$SIG{'__WARN__'}=sub {};$path=eval {Cwd::abs_path($file)}}$path =~ tr/\\\\/\\// if $^O eq 'MSWin32' and defined$path}return$path}sub MyConvertFileName($$) {my ($et,$file)=@_;my$enc=$et->Options('CharsetFileName');$et->Options(CharsetFileName=>'UTF8')if$utf8FileName{$file};my$convFile=$et->ConvertFileName($file);$et->Options(CharsetFileName=>$enc)if$utf8FileName{$file};return$convFile}sub AddPrintFormat($) {my$expr=shift;my$type;if ($expr =~ /^#/){$expr =~ s/^#\\[(HEAD|SECT|IF|BODY|ENDS|TAIL)\\]// or return;$type=$1}else {$type='BODY'}$printFmt{$type}or $printFmt{$type}=[];push @{$printFmt{$type}},$expr;push@requestTags,$expr =~ /\\$\\{?((?:[-_0-9A-Z]+:)*[-_0-9A-Z?*]+)/ig;$printFmt{SetTags}=1 if$expr =~ /\\bSetTags\\b/}sub SuggestedExtension($$$) {my ($et,$valPt,$tag)=@_;my$ext;if (not $binaryOutput){$ext='txt'}elsif ($$valPt =~ /^\\xff\\xd8\\xff/){$ext='jpg'}elsif ($$valPt =~ /^(\\0\\0\\0\\x0cjP(  |\\x1a\\x1a)\\x0d\\x0a\\x87\\x0a|\\xff\\x4f\\xff\\x51\\0)/){$ext='jp2'}elsif ($$valPt =~ /^(\\x89P|\\x8aM|\\x8bJ)NG\\r\\n\\x1a\\n/){$ext='png'}elsif ($$valPt =~ /^GIF8[79]a/){$ext='gif'}elsif ($$valPt =~ /^<\\?xpacket/ or $tag eq 'XMP'){$ext='xmp'}elsif ($$valPt =~ /^<\\?xml/ or $tag eq 'XML'){$ext='xml'}elsif ($$valPt =~ /^RIFF....WAVE/s){$ext='wav'}elsif ($tag eq 'OriginalRawImage' and defined($ext=$et->GetValue('OriginalRawFileName'))){$ext =~ s/^.*\\.//s;$ext=$ext ? lc($ext): 'raw'}elsif ($tag eq 'EXIF'){$ext='exif'}elsif ($tag eq 'ICC_Profile'){$ext='icc'}elsif ($$valPt =~ /^(MM\\0\\x2a|II\\x2a\\0)/){$ext='tiff'}elsif ($$valPt =~ /^.{4}ftyp(3gp|mp4|f4v|qt  )/s){my%movType=('qt  '=>'mov');$ext=$movType{$1}|| $1}elsif ($$valPt !~ /^.{0,4096}\\0/s){$ext='txt'}elsif ($$valPt =~ /^BM.{15}\\0/s){$ext='bmp'}elsif ($$valPt =~ /^CANON OPTIONAL DATA\\0/){$ext='vrd'}elsif ($$valPt =~ /^IIII\\x04\\0\\x04\\0/){$ext='dr4'}elsif ($$valPt =~ /^(.{10}|.{522})(\\x11\\x01|\\x00\\x11)/s){$ext='pict'}elsif ($$valPt =~ /^\\xff\\x0a|\\0\\0\\0\\x0cJXL \\x0d\\x0a......ftypjxl/s){$ext='jxl'}elsif ($$valPt =~ /^.{4}jumb\\0.{3}jumdc2pa/s){$ext='c2pa'}elsif ($tag eq 'JUMBF'){$ext='jumbf'}else {$ext='dat'}return$ext}sub LoadPrintFormat($;$) {my ($arg,$noNL)=@_;if (not defined$arg){Error "Must specify file or expression for -p option\\n"}elsif ($arg !~ /\\n/ and -f $arg and $mt->Open(\\*FMT_FILE,$arg)){for (<FMT_FILE>){AddPrintFormat($_)}close(FMT_FILE)}else {$arg .= "\\n" unless$noNL;AddPrintFormat($arg)}}sub FilenameSPrintf($;$@) {my ($fmt,$file,@extra)=@_;local $_;return$fmt unless$fmt =~ /%[-+]?\\d*[.:]?\\d*[lu]?[dDfFeEtgso]/;return undef unless defined$file;CleanFilename($file);my%part;@part{qw(d f E)}=($file =~ /^(.*?)([^\\/]*?)(\\.[^.\\/]*)?$/);defined$part{f}or Warn("Error: Bad pattern match for file $file\\n"),return undef;if ($part{E}){$part{e}=substr($part{E},1)}else {@part{qw(e E)}=('','')}$part{F}=$part{f}.$part{E};($part{D}=$part{d})=~ s{/+$}{};@part{qw(t g s o)}=@extra;my ($filename,$pos)=('',0);while ($fmt =~ /(%([-+]?)(\\d*)([.:]?)(\\d*)([lu]?)([dDfFeEtgso]))/g){$filename .= substr($fmt,$pos,pos($fmt)- $pos - length($1));$pos=pos($fmt);my ($sign,$wid,$dot,$skip,$mod,$code)=($2,$3,$4,$5 || 0,$6,$7);my (@path,$part,$len,$groups);if (lc$code eq 'd' and $dot and $dot eq ':'){@path=split '/',$part{$code};$len=scalar@path}else {if ($code eq 'g'){$groups=$part{g}|| []unless defined$groups;$fmt =~ /\\G(\\d?)/g;$part{g}=$$groups[$1 || 0];$pos=pos($fmt)}$part{$code}='' unless defined$part{$code};$len=length$part{$code}}next unless$skip < $len;$wid=$len - $skip if$wid eq '' or $wid + $skip > $len;$skip=$len - $wid - $skip if$sign eq '-';if (@path){$part=join('/',@path[$skip..($skip+$wid-1)]);$part .= '/' unless$code eq 'D'}else {$part=substr($part{$code},$skip,$wid)}$part=($mod eq 'u')? uc($part): lc($part)if$mod;$filename .= $part}$filename .= substr($fmt,$pos);$filename =~ s{(?!^)//}{/}g;return$filename}sub Num2Alpha($) {my$num=shift;my$alpha=chr(97 + ($num % 26));while ($num >= 26){$num=int($num / 26)- 1;$alpha=chr(97 + ($num % 26)).$alpha}return$alpha}sub NextUnusedFilename($;$) {my ($fmt,$okfile)=@_;return$fmt unless$fmt =~ /%[-+]?\\d*[.:]?\\d*[lun]?[cC]/;my%sep=('-'=>'-','+'=>'_');my ($copy,$alpha)=(0,'a');my$lastFile;for (;;){my ($filename,$pos)=('',0);while ($fmt =~ /(%([-+]?)(\\d*)([.:]?)(\\d*)([lun]?)([cC]))/g){$filename .= substr($fmt,$pos,pos($fmt)- $pos - length($1));$pos=pos($fmt);my ($sign,$wid,$dec,$wid2,$mod,$tok)=($2,$3 || 0,$4,$5 || 0,$6,$7);my$seq;if ($tok eq 'C'){$sign eq '-' ? ++$seqFileDir : ++$seqFileNum if$copy and $dec eq ':';$seq=$wid + ($sign eq '-' ? $seqFileDir : $seqFileNum)- 1;$wid=$wid2}else {next unless$dec or $copy;$wid=$wid2 if$wid < $wid2;$filename .= $sep{$sign}if$sign}if ($mod and $mod ne 'n'){my$a=$tok eq 'C' ? Num2Alpha($seq): $alpha;my$str=($wid and $wid > length$a)? 'a' x ($wid - length($a)): '';$str .= $a;$str=uc$str if$mod eq 'u';$filename .= $str}else {my$c=$tok eq 'C' ? $seq : $copy;my$num=$c + ($mod ? 1 : 0);$filename .= $wid ? sprintf("%.\${wid}d",$num): $num}}$filename .= substr($fmt,$pos);return$filename unless ($mt->Exists($filename,1)and not defined$usedFileName{$filename})or $usedFileName{$filename};if (defined$okfile){return$filename if$filename eq $okfile;my ($fn,$ok)=(AbsPath($filename),AbsPath($okfile));return$okfile if defined$fn and defined$ok and $fn eq $ok}return$filename if defined$lastFile and $lastFile eq $filename;$lastFile=$filename;++$copy;++$alpha}}sub CreateDirectory($) {my$file=shift;my$err=$mt->CreateDirectory($file);if (defined$err){$err and Error("$err\\n"),return 0;if ($verbose){my$dir;($dir=$file)=~ s(/[^/]*$)();print$vout "Created directory $dir\\n"}++$countNewDir;return 1}return 0}sub OpenOutputFile($;@) {my ($file,@args)=@_;my ($fp,$outfile,$append);if ($textOut){$outfile=$file;CleanFilename($outfile);if ($textOut =~ /%[-+]?\\d*[.:]?\\d*[lun]?[dDfFeEtgsocC]/ or defined$tagOut){$outfile=FilenameSPrintf($textOut,$file,@args);return ()unless defined$outfile;$outfile=NextUnusedFilename($outfile);CreateDirectory($outfile)}else {$outfile =~ s/\\.[^.\\/]*$//;$outfile .= $textOut}my$mode='>';if ($mt->Exists($outfile,1)){unless ($textOverwrite){Warn "Output file $outfile already exists for $file\\n";return ()}if ($textOverwrite==2 or ($textOverwrite==3 and $created{$outfile})){$mode='>>';$append=1}}unless ($mt->Open(\\*OUTFILE,$outfile,$mode)){my$what=$mode eq '>' ? 'creating' : 'appending to';Error("Error $what $outfile\\n");return ()}binmode(OUTFILE)if$binaryOutput;$fp=\\*OUTFILE}else {$fp=\\*STDOUT}return($fp,$outfile,$append)}sub AcceptFile($) {my$file=shift;my$ext=($file =~ /^.*\\.(.+)$/s)? uc($1): '';return$filterExt{$ext}if defined$filterExt{$ext};return$filterExt{'*'}if defined$filterExt{'*'};return 0 if$filterFlag & 0x02;return 2}sub SlurpFile($$) {my ($file,$buffPt)=@_;$mt->Open(\\*INFILE,$file)or Warn("Error opening file $file\\n"),return 0;binmode(INFILE);undef $$buffPt;my$bsize=1024 * 1024;my$num=read(INFILE,$$buffPt,$bsize);unless (defined$num){close(INFILE);Warn("Error reading $file\\n");return 0}my$bmax=64 * $bsize;while ($num==$bsize){$bsize *= 2 if$bsize < $bmax;my$buff;$num=read(INFILE,$buff,$bsize);last unless$num;$$buffPt .= $buff}close(INFILE);return 1}sub FilterArgfileLine($) {my$arg=shift;if ($arg =~ /^#/){return undef unless$arg =~ s/^#\\[CSTR\\]//;$arg =~ s/[\\x0d\\x0a]+$//s;$arg =~ s{\\\\(.)|(["\\$\\@]|\\\\$)}{'\\\\'.($2 || $1)}sge;my%esc=(a=>"\\a",b=>"\\b",f=>"\\f",n=>"\\n",r=>"\\r",t=>"\\t",'"'=>'"','\\\\'=>'\\\\');$arg =~ s/\\\\(.)/$esc{$1}||'\\\\'.$1/egs}else {$arg =~ s/^\\s+//;$arg =~ s/[\\x0d\\x0a]+$//s;$arg =~ s/^(-[-_0-9A-Z:]+#?)\\s*([-+<]?=) ?/$1$2/i;return undef if$arg eq ''}return$arg}sub ReadStayOpen($) {my$args=shift;my (@newArgs,$processArgs,$result,$optArgs);my$lastOpt='';my$unparsed=length$stayOpenBuff;for (;;){if ($unparsed){$result=$unparsed;undef$unparsed}else {$result=sysread(STAYOPEN,$stayOpenBuff,65536,length($stayOpenBuff))}if ($result){my$pos=0;while ($stayOpenBuff =~ /\\n/g){my$len=pos($stayOpenBuff)- $pos;my$arg=substr($stayOpenBuff,$pos,$len);$pos += $len;$arg=FilterArgfileLine($arg);next unless defined$arg;push@newArgs,$arg;if ($optArgs){undef$optArgs;next unless$lastOpt eq '-stay_open' or $lastOpt eq '-@'}else {$lastOpt=lc$arg;$optArgs=$optArgs{$arg};unless (defined$optArgs){$optArgs=$optArgs{$lastOpt};$optArgs=$optArgs{"$1#$2"}if not defined$optArgs and $lastOpt =~ /^(.*?)\\d+(!?)$/}next unless$lastOpt =~ /^-execute\\d*$/}$processArgs=1;last}next unless$pos;$stayOpenBuff=substr($stayOpenBuff,$pos);if ($processArgs){unshift @$args,@newArgs;last}}elsif ($result==0){select(undef,undef,undef,0.01)}else {Warn "Error reading from ARGFILE\\n";close STAYOPEN;$stayOpen=0;last}}}sub EFile($$) {my$entry=shift;my$efile=$efile[shift || 0];if (defined$efile and length$entry and $entry ne '-'){my$err;CreateDirectory($efile);if ($mt->Open(\\*EFILE_FILE,$efile,'>>')){print EFILE_FILE$entry,"\\n" or Warn("Error writing to $efile\\n"),$err=1;close EFILE_FILE}else {Warn("Error opening '\${efile}' for append\\n");$err=1}if ($err){defined $_ and $_ eq $efile and undef $_ foreach@efile}}}sub Progress($$) {my ($file,$msg)=@_;if (defined$progStr){print$file $msg,$progStr,"\\n";undef$progressNext if defined$progressMax}}sub PrintTagList($@) {my$msg=shift;print$msg,":\\n" unless$quiet;my$tag;if (($outFormat < 0 or $verbose)and $msg =~ /file extensions$/ and @_){for$tag (@_){printf("  %-11s %s\\n",$tag,GetFileType($tag,1))}return}my ($len,$pad)=(0,$quiet ? '' : '  ');for$tag (@_){my$taglen=length($tag);if ($len + $taglen > 77){print "\\n";($len,$pad)=(0,$quiet ? '' : '  ')}print$pad,$tag;$len += $taglen + 1;$pad=' '}@_ or print$pad,'[empty list]';print "\\n"}sub PrintErrors($$$) {my ($et,$info,$file)=@_;my ($tag,$key);for$tag (qw(Warning Error)){next unless $$info{$tag};my@keys=($tag);push@keys,sort(grep /^$tag /,keys %$info)if$et->Options('Duplicates');for$key (@keys){Warn "$tag: $info->{$key} - $file\\n"}}return $$info{Error}}`,Vl=Ul,w=class Ut{static WASI_ESUCCESS=0;static WASI_ERRNO_BADF=8;static WASI_ENOSYS=52;static WASI_CLOCK_REALTIME=0;static WASI_CLOCK_MONOTONIC=1;static WASI_ERRNO_ISDIR=31;static WASI_ERRNO_INVAL=28;static WASI_ERRNO_NOTDIR=54;static WASI_ERRNO_NOENT=44;static WASI_ERRNO_EXIST=20;static WASI_ERRNO_IO=29;static WASI_FILETYPE_CHARACTER_DEVICE=2;static WASI_FILETYPE_DIRECTORY=3;static WASI_FILETYPE_REGULAR_FILE=4;static IMPORT_FUNCTIONS=["args_get","args_sizes_get","clock_res_get","clock_time_get","environ_get","environ_sizes_get","fd_advise","fd_allocate","fd_close","fd_datasync","fd_fdstat_get","fd_fdstat_set_flags","fd_fdstat_set_rights","fd_filestat_get","fd_filestat_set_size","fd_filestat_set_times","fd_pread","fd_prestat_dir_name","fd_prestat_get","fd_pwrite","fd_read","fd_readdir","fd_renumber","fd_seek","fd_sync","fd_tell","fd_write","path_create_directory","path_filestat_get","path_filestat_set_times","path_link","path_open","path_readlink","path_remove_directory","path_rename","path_symlink","path_unlink_file","poll_oneoff","proc_exit","proc_raise","random_get","sched_yield","sock_accept","sock_recv","sock_send","sock_shutdown"];encoder;decoder;constructor(){this.encoder=new TextEncoder,this.decoder=new TextDecoder}writeString(t,n,i){let r=this.encoder.encode(n);return new Uint8Array(t.buffer,i,r.length).set(r),r.length}readString(t,n,i){let r=new Uint8Array(t.buffer,n,i);return this.decoder.decode(r)}byteLength(t){return this.encoder.encode(t).length}static iovec_t={size:8,bufferOffset:0,lengthOffset:4};iovViews(t,n,i){let r=[],s=n;for(let o=0;o<i;o++){let l=t.getUint32(s+Ut.iovec_t.bufferOffset,!0),a=t.getUint32(s+Ut.iovec_t.lengthOffset,!0);r.push(new Uint8Array(t.buffer,l,a)),s+=Ut.iovec_t.size}return r}writeFilestat(t,n,i){t.setBigUint64(n,BigInt(0),!0),t.setBigUint64(n+8,BigInt(0),!0),t.setUint8(n+16,i),t.setUint32(n+24,0,!0),t.setBigUint64(n+32,BigInt(0),!0),t.setBigUint64(n+40,BigInt(0),!0),t.setBigUint64(n+48,BigInt(0),!0)}writeFdstat(t,n,i,r){t.setUint8(n,i),t.setUint16(n+2,r,!0),t.setBigUint64(n+8,BigInt(0),!0),t.setBigUint64(n+16,BigInt(0),!0)}},Mr=class{constructor(e){this.code=e}get exitCode(){return this.code}},Ai=class{constructor(e,t){this.handler=e,this.outputBuffers=t}decoder=new TextDecoder("utf-8");writev(e){let t=e.reduce((r,s)=>r+s.byteLength,0),n=0,i=new Uint8Array(t);for(let r of e)i.set(r,n),n+=r.byteLength;if(this.outputBuffers)this.handler(i);else{let r=this.decoder.decode(i);this.handler(r)}return i.length}readv(e){return 0}close(){}},Bl=class{constructor(e){this.consume=e}encoder=new TextEncoder;pending=null;writev(e){return 0}consumePending(e,t){if(e.byteLength<t)return this.pending=null,e;let n=e.slice(0,t);return this.pending=e.slice(t),n}readv(e){let t=0;for(let n of e){let i=n.byteLength;if(this.pending){let r=this.consumePending(this.pending,i);n.set(r,0),i-=r.byteLength,t+=r.byteLength}for(;i>0;){let r=this.consume(),s;if(r instanceof Uint8Array?s=r:s=this.encoder.encode(r),s.length===0)return t;s.length>i?(n.set(s.slice(0,i),n.byteLength-i),this.pending=s.slice(i),t+=i,i=0):(n.set(s,n.byteLength-i),t+=s.length,i-=s.length)}}return t}close(){}};function Hl(e={}){let t=e.outputBuffers||!1;return[new Bl(e.stdin||(()=>"")),new Ai(e.stdout||console.log,t),new Ai(e.stderr||console.error,t)]}var Ur=class{root;preopenPaths=[];constructor(e){if(this.root={type:"dir",entries:{}},this.ensureDir("/dev"),this.setNode("/dev/null",{type:"character",kind:"devnull"}),e)for(let t of Object.keys(e))this.ensureDir(t),this.preopenPaths.push(t);else this.preopenPaths.push("/")}removeFile(e){let t=this.normalizePath(e).split("/").filter(s=>s.length>0),n=t.pop(),i=`/${t.join("/")}`,r=this.ensureDir(i);n&&delete r.entries[n]}addFile(e,t){if(typeof t=="string"){let n=new TextEncoder().encode(t);this.createFile(e,n);return}this.createFile(e,t)}createFile(e,t){let n={type:"file",content:t};return this.setNode(e,n),n}setNode(e,t){let n=this.normalizePath(e).split("/").filter(o=>o.length>0);if(n.length===0){if(t.type!=="dir")throw new Error("Root must be a directory");this.root=t;return}let i=n.pop(),r=`/${n.join("/")}`,s=this.ensureDir(r);i&&(s.entries[i]=t)}getDevNull(){let e=this.lookup("/dev/null");if(!e)throw new Error("/dev/null not found");return e}getPreopenPaths(){return[...this.preopenPaths]}lookup(e){let t=this.normalizePath(e);if(t==="/")return this.root;let n=t.split("/").filter(r=>r.length>0),i=this.root;for(let r of n)if(i.type!=="dir"||(i=i.entries[r],!i))return null;return i}resolve(e,t){let n=this.normalizePath(t).split("/").filter(r=>r.length>0),i=e;for(let r of n)if(r!=="."){if(r===".."){i=this.root;continue}if(i.type!=="dir"||(i=i.entries[r],!i))return null}return i}ensureDir(e){let t=this.normalizePath(e).split("/").filter(i=>i.length>0),n=this.root;for(let i of t){n.entries[i]||(n.entries[i]={type:"dir",entries:{}});let r=n.entries[i];if(r.type!=="dir")throw new Error(`"${i}" is not a directory`);n=r}return n}createFileIn(e,t){let n=this.normalizePath(t).split("/").filter(o=>o.length>0);if(n.length===0)throw new Error("Cannot create a file with an empty name");let i=n.pop();if(!i)throw new Error("Cannot create a file with an empty name");let r=e;for(let o of n){r.entries[o]||(r.entries[o]={type:"dir",entries:{}});let l=r.entries[o];if(l.type!=="dir")throw new Error(`"${o}" is not a directory`);r=l}let s={type:"file",content:new Uint8Array(0)};return r.entries[i]=s,s}normalizePath(e){if(!e)return"/";let t=(e.startsWith("/")?e:`/${e}`).replace(/\/+/g,"/");return t==="/"?t:t.replace(/\/+$/,"")}};function jl(e={}){return(t,n,i)=>{let r=e.withFileSystem||new Ur(t.preopens),s={};Hl(e.withStdIo||{}).forEach((u,c)=>{s[c]={node:{type:"character",kind:"stdio",entry:u},position:0,isPreopen:!1,path:`/dev/fd/${c}`,fd:c}});let o=3;for(let u of r.getPreopenPaths()){let c=r.lookup(u);c&&c.type==="dir"&&(s[o]={node:c,position:0,isPreopen:!0,preopenPath:u,path:u,fd:o},o++)}function l(u){for(let c in s){let h=s[c];if(h.path===u)return h}return null}function a(u){return s[u]||null}function m(u){return u.content instanceof Blob?u.content.size:u.content.byteLength}return{fd_read:async(u,c,h,f)=>{let p=i(),y=n.iovViews(p,c,h),x=a(u);if(!x)return w.WASI_ERRNO_BADF;if(x.node.type==="character"&&x.node.kind==="stdio"){let L=x.node.entry.readv(y);return p.setUint32(f,L,!0),w.WASI_ESUCCESS}if(x.node.type==="dir")return w.WASI_ERRNO_ISDIR;if(x.node.type==="character"&&x.node.kind==="devnull")return p.setUint32(f,0,!0),w.WASI_ESUCCESS;let D=x.node,W=D.content,R=m(D)-x.position,E=0;if(R<=0)return p.setUint32(f,0,!0),w.WASI_ESUCCESS;if(D.content instanceof Blob){let L=D.content;for(let k of y){if(x.position>=L.size)break;let H=Math.min(k.byteLength,L.size-x.position);if(H<=0)break;let ee=await L.slice(x.position,x.position+H).arrayBuffer();k.set(new Uint8Array(ee)),E+=ee.byteLength,x.position+=ee.byteLength}}else if(ArrayBuffer.isView(W))for(let L of y){if(x.position>=W.byteLength)break;let k=Math.min(L.byteLength,W.byteLength-x.position);if(k<=0)break;L.set(W.slice(x.position,x.position+k)),E+=k,x.position+=k}return p.setUint32(f,E,!0),w.WASI_ESUCCESS},fd_write:(u,c,h,f)=>{let p=i(),y=n.iovViews(p,c,h),x=a(u);if(!x)return w.WASI_ERRNO_BADF;let D=0;if(x.node.type==="character"&&x.node.kind==="stdio"){let k=x.node.entry.writev(y);return p.setUint32(f,k,!0),w.WASI_ESUCCESS}if(x.node.type==="dir")return w.WASI_ERRNO_ISDIR;if(x.node.type==="character"&&x.node.kind==="devnull"){let k=y.reduce((H,ee)=>H+ee.byteLength,0);return p.setUint32(f,k,!0),w.WASI_ESUCCESS}if(x.node.content instanceof Blob)return w.WASI_ERRNO_INVAL;let W=x.position,R=y.reduce((k,H)=>k+H.byteLength,0),E=W+R,L;E>m(x.node)?(L=new Uint8Array(E),L.set(x.node.content,0)):L=x.node.content;for(let k of y)L.set(k,W),W+=k.byteLength,D+=k.byteLength;return x.node.content=L,x.position=W,p.setUint32(f,D,!0),w.WASI_ESUCCESS},fd_close:u=>{let c=a(u);return c?c.node.type==="character"&&c.node.kind==="stdio"?(c.node.entry.close(),w.WASI_ESUCCESS):(delete s[u],w.WASI_ESUCCESS):w.WASI_ERRNO_BADF},fd_seek:(u,c,h,f)=>{let p=i();if(u<3)return w.WASI_ERRNO_BADF;let y=a(u);if(!y||y.node.type!=="file")return w.WASI_ERRNO_BADF;let x=y.position,D=m(y.node);switch(h){case 0:x=Number(c);break;case 1:x=x+Number(c);break;case 2:x=D+Number(c);break;default:return w.WASI_ERRNO_INVAL}return x<0&&(x=0),y.position=x,p.setUint32(f,x,!0),w.WASI_ESUCCESS},fd_tell:(u,c)=>{let h=i();if(u<3)return w.WASI_ERRNO_BADF;let f=a(u);return f?(h.setBigUint64(c,BigInt(f.position),!0),w.WASI_ESUCCESS):w.WASI_ERRNO_BADF},fd_fdstat_get:(u,c)=>{let h=i(),f=a(u);if(!f)return w.WASI_ERRNO_BADF;let p;switch(f.node.type){case"character":p=w.WASI_FILETYPE_CHARACTER_DEVICE;break;case"dir":p=w.WASI_FILETYPE_DIRECTORY;break;case"file":p=w.WASI_FILETYPE_REGULAR_FILE;break}return n.writeFdstat(h,c,p,0),w.WASI_ESUCCESS},fd_filestat_get:(u,c)=>{let h=i(),f=a(u);if(!f)return w.WASI_ERRNO_BADF;let p,y=0;switch(f.node.type){case"character":p=w.WASI_FILETYPE_CHARACTER_DEVICE;break;case"dir":p=w.WASI_FILETYPE_DIRECTORY;break;case"file":p=w.WASI_FILETYPE_REGULAR_FILE,y=m(f.node);break}return n.writeFilestat(h,c,p),h.setBigUint64(c+32,BigInt(y),!0),w.WASI_ESUCCESS},fd_prestat_get:(u,c)=>{let h=i();if(u<3)return w.WASI_ERRNO_BADF;let f=a(u);if(!f||!f.isPreopen)return w.WASI_ERRNO_BADF;h.setUint8(c,0);let p=f.preopenPath||"";return h.setUint32(c+4,p.length,!0),w.WASI_ESUCCESS},fd_prestat_dir_name:(u,c,h)=>{if(u<3)return w.WASI_ERRNO_BADF;let f=a(u);if(!f||!f.isPreopen)return w.WASI_ERRNO_BADF;let p=f.preopenPath||"";if(p.length!==h)return w.WASI_ERRNO_INVAL;let y=i();for(let x=0;x<p.length;x++)y.setUint8(c+x,p.charCodeAt(x));return w.WASI_ESUCCESS},fd_open:(u,c,h,f,p,y,x,D)=>{let W=i();if(u<3)return w.WASI_ERRNO_NOTDIR;let R=a(u);if(!R||R.node.type!=="dir")return w.WASI_ERRNO_NOTDIR;let E=n.readString(W,c,h),L=(R.path.endsWith("/")?R.path:`${R.path}/`)+E,k=l(L);if(k)return W.setUint32(D,k.fd,!0),w.WASI_ESUCCESS;let H=r.resolve(R.node,E),ee=1,Ge=2,_e=4;if(H){if(f&Ge)return w.WASI_ERRNO_EXIST;if(f&_e){if(H.type!=="file")return w.WASI_ERRNO_INVAL;H.content=new Uint8Array(0)}}else{if(!(f&ee))return w.WASI_ERRNO_NOENT;H=r.createFileIn(R.node,E)}return s[o]={node:H,position:0,isPreopen:!1,path:L,fd:o},W.setUint32(D,o,!0),o++,w.WASI_ESUCCESS},path_open:(u,c,h,f,p,y,x,D,W)=>{let R=i();if(u<3)return w.WASI_ERRNO_NOTDIR;let E=a(u);if(!E||E.node.type!=="dir")return w.WASI_ERRNO_NOTDIR;let L=n.readString(R,h,f),k=(E.path.endsWith("/")?E.path:`${E.path}/`)+L,H=l(k);if(H)return R.setUint32(W,H.fd,!0),w.WASI_ESUCCESS;let ee=r.resolve(E.node,L),Ge=1,_e=2,Xe=4;if(ee){if(p&_e)return w.WASI_ERRNO_EXIST;if(p&Xe){if(ee.type!=="file")return w.WASI_ERRNO_INVAL;ee.content=new Uint8Array(0)}}else{if(!(p&Ge))return w.WASI_ERRNO_NOENT;ee=r.createFileIn(E.node,L)}return s[o]={node:ee,position:0,isPreopen:!1,path:k,fd:o},R.setUint32(W,o,!0),o++,w.WASI_ESUCCESS},path_filestat_get:(u,c,h,f,p)=>{let y=i(),x=a(u);if(!x)return w.WASI_ERRNO_BADF;if(x.node.type!=="dir")return w.WASI_ERRNO_NOTDIR;let D=n.readString(y,h,f),W=x.path,R=W.endsWith("/")?W+D:`${W}/${D}`,E=r.lookup(R);if(!E)return w.WASI_ERRNO_NOENT;if(E.type==="character"&&E.kind==="stdio")return w.WASI_ERRNO_INVAL;let L,k=0;return E.type==="dir"?L=w.WASI_FILETYPE_DIRECTORY:E.type==="character"&&E.kind==="devnull"?L=w.WASI_FILETYPE_CHARACTER_DEVICE:(L=w.WASI_FILETYPE_REGULAR_FILE,k=m(E)),n.writeFilestat(y,p,L),y.setBigUint64(p+32,BigInt(k),!0),w.WASI_ESUCCESS}}}}function zl(e,t,n){let i=e.args||[];return{args_get:(r,s)=>{let o=r,l=s,a=n();for(let m of i)a.setUint32(o,l,!0),o+=4,l+=t.writeString(a,`${m}\0`,l);return w.WASI_ESUCCESS},args_sizes_get:(r,s)=>{let o=n();o.setUint32(r,i.length,!0);let l=i.reduce((a,m)=>a+t.byteLength(m)+1,0);return o.setUint32(s,l,!0),w.WASI_ESUCCESS}}}function Xl(e,t,n){return{clock_res_get:(i,r)=>{let s;switch(i){case w.WASI_CLOCK_MONOTONIC:{s=5e3;break}case w.WASI_CLOCK_REALTIME:{s=1e3;break}default:return w.WASI_ENOSYS}return n().setUint32(r,s,!0),w.WASI_ESUCCESS},clock_time_get:(i,r,s)=>{let o=0;switch(i){case w.WASI_CLOCK_MONOTONIC:{o=performance.now();break}case w.WASI_CLOCK_REALTIME:{o=Date.now();break}default:return w.WASI_ENOSYS}let l=n();if(BigInt){let a=BigInt((m=>{let u=Math.trunc(m),c=BigInt(Math.round((m-u)*1e6));return BigInt(u)*BigInt(1e6)+c})(o));l.setBigUint64(s,a,!0)}else{let a=Date.now()*1e6;l.setUint32(s,a&65535,!0),l.setUint32(s+4,a&4294901760,!0)}return w.WASI_ESUCCESS}}}function Kl(e,t,n){return{environ_get:(i,r)=>{let s=i,o=r,l=n();for(let a in e.env){let m=e.env[a];l.setUint32(s,o,!0),s+=4,o+=t.writeString(l,`${a}=${m}\0`,o)}return w.WASI_ESUCCESS},environ_sizes_get:(i,r)=>{let s=n();return s.setUint32(i,Object.keys(e.env||{}).length,!0),s.setUint32(r,Object.entries(e.env||{}).reduce((o,[l,a])=>o+t.byteLength(l)+1+t.byteLength(a)+1,0),!0),w.WASI_ESUCCESS}}}function Yl(e,t,n){return{proc_exit:i=>{throw new Mr(i)},proc_raise:i=>w.WASI_ESUCCESS}}function Jl(e,t,n){return{random_get:(i,r)=>{let s=n(),o=new Uint8Array(s.buffer,i,r);return crypto.getRandomValues(o),w.WASI_ESUCCESS}}}var Zl=class{wasiImport;instance=null;isStarted=!1;abi;constructor(e){if(this.wasiImport={},this.abi=new w,e?.features){let t={};for(let n of e.features){let i=n.name||"Unknown feature",r=n(e,this.abi,this.view.bind(this));for(let s in r){if(s in this.wasiImport){let o=t[s]||"Unknown feature";throw new Error(`Import conflict: Function '${s}' is already provided by '${o}' and is being redefined by '${i}'`)}t[s]=i}this.wasiImport={...this.wasiImport,...r}}}for(let t of w.IMPORT_FUNCTIONS)t in this.wasiImport||(this.wasiImport[t]=()=>w.WASI_ENOSYS)}view(){if(!this.instance)throw new Error("wasi.start() or wasi.initialize() has not been called");if(!this.instance.exports.memory)throw new Error("instance.exports.memory is undefined");if(!(this.instance.exports.memory instanceof WebAssembly.Memory))throw new Error("instance.exports.memory is not a WebAssembly.Memory");return new DataView(this.instance.exports.memory.buffer)}async start(e){if(this.isStarted)throw new Error("wasi.start() or wasi.initialize() has already been called");if(this.isStarted=!0,this.instance=e,!this.instance.exports._start)throw new Error("instance.exports._start is undefined");if(typeof this.instance.exports._start!="function")throw new Error("instance.exports._start is not a function");try{return await this.instance.exports._start(),w.WASI_ESUCCESS}catch(t){if(t instanceof Mr)return t.code;throw t}}},Vt=new WeakMap;function Ql(e){return!!e&&(typeof e=="object"||typeof e=="function")&&typeof e.then=="function"}function Ni(e,t){return new Proxy(e,{get:(n,i)=>t(n[i])})}var Vr=class{value=void 0;exports=null;getState(){if(!this.exports)throw new Error("Exports not initialized");return this.exports.asyncify_get_state()}assertNoneState(){let e=this.getState();if(e!==0)throw new Error(`Invalid async state ${e}, expected 0.`)}wrapImportFn(e){return(...t)=>{if(this.getState()===2){if(!this.exports)throw new Error("Exports not initialized");return this.exports.asyncify_stop_rewind(),this.value}this.assertNoneState();let n=e(...t);if(!Ql(n))return n;if(!this.exports)throw new Error("Exports not initialized");this.exports.asyncify_start_unwind(16),this.value=n}}wrapModuleImports(e){return Ni(e,t=>typeof t=="function"?this.wrapImportFn(t):t)}wrapImports(e){if(e!==void 0)return Ni(e,(t=Object.create(null))=>this.wrapModuleImports(t))}wrapExportFn(e){let t=Vt.get(e);return t!==void 0||(t=async(...n)=>{this.assertNoneState();let i=e(...n);for(;this.getState()===1;){if(!this.exports)throw new Error("Exports not initialized");this.exports.asyncify_stop_unwind(),this.value=await this.value,this.assertNoneState(),this.exports.asyncify_start_rewind(16),i=e(...n)}return this.assertNoneState(),i},Vt.set(e,t)),t}wrapExports(e){let t=Object.create(null);for(let n in e){let i=e[n];typeof i=="function"&&!n.startsWith("asyncify_")&&(i=this.wrapExportFn(i)),Object.defineProperty(t,n,{enumerable:!0,value:i})}return Vt.set(e,t),t}init(e,t){let n=e.exports,i=n.memory||t?.env&&t.env.memory;if(!i)throw new Error("Memory not found in exports or imports.env");new Int32Array(i.buffer,16).set([24,1024]),this.exports=this.wrapExports(n),Object.setPrototypeOf(e,Br.prototype)}},Br=class extends WebAssembly.Instance{constructor(e,t){let n=new Vr;super(e,n.wrapImports(t)),n.init(this,t)}get exports(){return Vt.get(super.exports)}};Object.defineProperty(Br.prototype,"exports",{enumerable:!0});async function ea(e,t){let n=new Vr,i=await WebAssembly.instantiateStreaming(e,n.wrapImports(t));return n.init(i.instance,t),i}var qt=class{parts;constructor(e=""){this.parts=e?[e]:[]}append(e){return this.parts.push(e),this}appendLine(e=""){return this.parts.push(`${e}
`),this}get length(){return this.toString().length}toString(){return this.parts.join("")}static isMultiline(e){let t=0;for(let n=0;n<e.length;n++)(e[n]===`
`||e[n]==="\r"&&(n===e.length-1||e[n+1]!==`
`))&&t++;return t>0}},ta="https://perl.objex.ai/zeroperl-1.0.1.wasm",Di=new TextDecoder;async function na(e,t={}){let n=new Ur({"/":""});n.addFile("/exiftool",Vl),e instanceof File?n.addFile(`/${e.name}`,e):n.addFile(`/${e.name}`,e.data),t.config&&(t.config instanceof File?n.addFile(`/${t.config.name}`,t.config):n.addFile(`/${t.config.name}`,t.config.data),t.args=t.args||[],t.args.push(`-config=${t.config.name}`));let i=new qt,r=new qt,s=["zeroperl","exiftool"].concat(t.args||[]);s.push(`/${e.name}`);let o={env:{LC_ALL:"C",PERL_UNICODE:"SAD"},args:s,features:[Kl,zl,Jl,Xl,Yl,jl({withFileSystem:n,withStdIo:{stdout:h=>{let f;ArrayBuffer.isView(h)?f=Di.decode(h):f=h,qt.isMultiline(f)?i.append(f):i.appendLine(f)},stderr:h=>{let f;ArrayBuffer.isView(h)?f=Di.decode(h):f=h,qt.isMultiline(f)?r.append(f):r.appendLine(f)}}})]},l=new Zl(o),a=t.fetch??fetch,{instance:m}=await ea(a(ta),{wasi_snapshot_preview1:l.wasiImport}),u=await l.start(m);if(u!==0)return{success:!1,data:void 0,error:r.toString(),exitCode:u};let c;return t.transform?c=t.transform(i.toString()):c=i.toString(),{success:!0,data:c,error:r.toString(),exitCode:u}}const ia={saturation:0,hue:2,high_low_key:4,contrast:6,contrast_highlight:8,contrast_shadow:10,sharpness:12,shading:18,clarity:20,grain_effect:38,toning:26,filter_effect:34,filter_effect_red:35,filter_effect_green:36,filter_effect_blue:37,hdr_tone_level:32,hdr_toning:30,color_tone:42,retro_toning:16,bleach_bypass_toning:28},ra=["filter_effect","filter_effect_red","filter_effect_green","filter_effect_blue","hdr_tone_level","hdr_toning","color_tone","bleach_bypass_toning"],sa={grain_effect:{1:3,3:2,5:1,0:0}},oa=["saturation","hue","high_low_key","contrast","contrast_highlight","contrast_shadow","sharpness","toning","retro_toning","bleach_bypass_toning","shading","clarity","grain_effect","filter_effect","filter_effect_red","filter_effect_green","filter_effect_blue","hdr_toning","hdr_tone_level","color_tone"],la=async e=>{const n=await na(e,{args:["-U","-Pentax_0x0247","-WhiteBalance","-WBShiftAB","-WBShiftGM","-ImageTone","-ColorTemperature","-PeripheralIlluminationCorr","-ShadowCorrection","-DynamicRangeExpansion","-b","-json"]});if(!n.data)throw new Error("No valid EXIF data found for the file.");const i=JSON.parse(n.data);if(i.length===0||!i[0].Pentax_0x0247)throw new Error("No valid EXIF data found for the file.");const r=i[0].Pentax_0x0247.replace("base64:",""),s=aa(r);console.log("arrayBufffer",s);const o=$a(s.buffer);return{props:{image_control:i[0].ImageTone,white_balance:i[0].WhiteBalance,wb_shift_ab:i[0].WBShiftAB,wb_shift_gm:i[0].WBShiftGM,color_temperature:i[0].ColorTemperature,image_control_settings:o,peripheral_illumination_correction:i[0].PeripheralIlluminationCorr,shadow_correction:i[0].ShadowCorrection,dynamic_range_expansion:i[0].DynamicRangeExpansion}}};function aa(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))}function $a(e){const t=new DataView(e),n={};for(const i of oa){console.log("prop",i);const r=ia[i],s=t.getUint8(r);let o=0;!ra.includes(i)&&(o=t.getUint8(r+1));const a=fa(s,o);if(a!==null){const m=sa[i];m?n[i]=m[a]:n[i]=a}else console.warn(`Invalid control byte for ${i}: ${o}`)}return n}function fa(e,t){return t===255?e-256:t===0?e:null}const ua={class:"file-list-container"},da={class:"empty-state-content"},ca={class:"file-input"},pa={key:1,class:"active-state"},ma={class:"top-bar"},ga={class:"file-input"},ha={class:"panels-container"},ya={class:"file-list"},xa={class:"files-list"},_a=["onClick"],va={class:"file-info"},ba={class:"file-preview"},Fa={key:0,class:"preview-loading"},Ea=["src"],Ta={key:1,class:"preview-placeholder"},Sa={class:"file-type"},wa={class:"file-size"},Oa={key:0,class:"file-dimensions"},Ia={class:"file-name-container"},Ca={class:"file-details-container"},Aa={class:"file-name"},Na={class:"file-metadata"},Da={class:"file-size"},Wa={key:0,class:"file-dimensions"},Ra={class:"status-container"},La={key:0,class:"spinner"},Pa=["title"],qa=["onClick"],Ga={key:0,class:"selected-preview-container"},ka=["src","alt"],Ma={class:"file-details"},Ua={class:"details-content"},Va={key:0,class:"no-selection"},Ba={class:"detail-item"},Ha={key:0,class:"loading-container"},ja={key:1,class:"error-container"},za={class:"error-message"},Xa={key:2,class:"extracted-data"},Ka=zn({__name:"FileList",setup(e){const t=Ht([]),n=Ht(null),i=async f=>new Promise(p=>{const y=URL.createObjectURL(f);f.originalUrl=y;const x=new Image;x.onload=()=>{f.dimensions={width:x.naturalWidth,height:x.naturalHeight};const D=document.createElement("canvas"),W=300;let R=x.width,E=x.height;R>E?R>W&&(E=Math.round(E*W/R),R=W):E>W&&(R=Math.round(R*W/E),E=W),D.width=R,D.height=E,D.getContext("2d")?.drawImage(x,0,0,R,E),D.toBlob(k=>{if(k){const H=URL.createObjectURL(k);p(H)}else p(y)},"image/jpeg",.8)},x.src=y}),r=f=>{n.value=f,!f.extractedData&&!f.isLoading&&(f.isLoading=!0,t.value=[...t.value],la(f).then(p=>{f.extractedData=p,f.isLoading=!1,f.error=void 0,t.value=[...t.value]}).catch(p=>{console.error("Error extracting data:",p),f.isLoading=!1,f.error=p.message||"Failed to extract data",t.value=[...t.value]}))},s=async f=>{const p=f.target;if(p.files){const y=Array.from(p.files);y.forEach(x=>{x.isPreviewLoading=!0}),t.value.push(...y);for(const x of y)try{x.preview=await i(x)}finally{x.isPreviewLoading=!1,t.value=[...t.value]}}p.value=""},o=f=>{const p=t.value.indexOf(f);t.value.indexOf(n.value),f.preview&&URL.revokeObjectURL(f.preview),f.originalUrl&&URL.revokeObjectURL(f.originalUrl),t.value.splice(p,1),n.value===f&&(n.value=null)},l=f=>{if(f===0)return"0 Bytes";const p=1024,y=["Bytes","KB","MB","GB"],x=Math.floor(Math.log(f)/Math.log(p));return parseFloat((f/Math.pow(p,x)).toFixed(2))+" "+y[x]},a=async f=>{f.preventDefault(),f.stopPropagation();const p=new DataTransfer;Array.from(f.dataTransfer?.files||[]).filter(x=>x.type.startsWith("image/")).forEach(x=>p.items.add(x)),await s({target:{files:p.files}}),h()},m=f=>{f.preventDefault(),f.stopPropagation(),c()},u=f=>{f.preventDefault(),f.stopPropagation(),h()},c=()=>{const f=document.querySelector(".empty-state, .files-container");f&&f.classList.add("drag-over")},h=()=>{const f=document.querySelector(".empty-state, .files-container");f&&f.classList.remove("drag-over")};return(f,p)=>(Y(),J("div",ua,[t.value.length===0?(Y(),J("div",{key:0,class:"empty-state",onDrop:a,onDragover:m,onDragleave:u},[S("div",da,[S("div",ca,[p[1]||(p[1]=S("label",{for:"file-upload",class:"file-label"},"Add images",-1)),S("input",{type:"file",id:"file-upload",multiple:"",accept:"image/*",onChange:s,class:"file-input-hidden"},null,32)]),p[2]||(p[2]=S("p",{class:"empty-state-text"},"Drag and drop images here or click to browse",-1))])],32)):(Y(),J("div",pa,[S("div",ma,[S("div",ga,[p[3]||(p[3]=S("label",{for:"file-upload-more",class:"file-label"},"Add more images",-1)),S("input",{type:"file",id:"file-upload-more",multiple:"",accept:"image/*",onChange:s,class:"file-input-hidden"},null,32)])]),S("div",ha,[S("div",ya,[S("div",{class:"files-container",onDrop:a,onDragover:m,onDragleave:u},[S("ul",xa,[(Y(!0),J(me,null,gr(t.value,(y,x)=>(Y(),J("li",{key:x,class:pe(["file-item",{"file-item-selected":n.value===y}]),onClick:D=>r(y)},[S("div",va,[S("div",ba,[y.isPreviewLoading?(Y(),J("div",Fa,p[4]||(p[4]=[S("div",{class:"preview-spinner"},null,-1)]))):(Y(),J(me,{key:1},[y.preview?(Y(),J("img",{key:0,src:y.preview,alt:"Preview",class:"preview-image"},null,8,Ea)):(Y(),J("div",Ta,[S("span",Sa,te(y.type||"Unknown type"),1),S("span",wa,te(l(y.size)),1),y.dimensions?(Y(),J("span",Oa,te(y.dimensions.width)+"×"+te(y.dimensions.height),1)):et("",!0)]))],64))]),S("div",Ia,[S("div",Ca,[S("span",Aa,te(y.name),1),S("div",Na,[S("span",Da,te(l(y.size)),1),y.dimensions?(Y(),J("span",Wa,te(y.dimensions.width)+"×"+te(y.dimensions.height),1)):et("",!0)])]),S("div",Ra,[y.isLoading?(Y(),J("div",La)):et("",!0),S("div",{class:pe(["extraction-status",[y.isLoading?"loading":y.error?"error":y.extractedData?"extracted":"not-extracted"]]),title:y.error?"Error extracting data":y.extractedData?"Data extracted":y.isLoading?"Extracting data...":"Data not extracted"},null,10,Pa)])])]),S("button",{onClick:pl(D=>o(y),["stop"]),class:"remove-button"},"Remove",8,qa)],10,_a))),128))])],32),n.value&&(n.value.originalUrl||n.value.preview)?(Y(),J("div",Ga,[S("img",{src:n.value.originalUrl||n.value.preview,alt:n.value.name,class:"selected-preview-image"},null,8,ka)])):et("",!0)]),S("div",Ma,[S("div",Ua,[n.value===null?(Y(),J("div",Va,p[5]||(p[5]=[S("p",null,"Select a file to view its details",-1)]))):(Y(),J(me,{key:1},[S("p",Ba,te(n.value.name),1),n.value.isLoading?(Y(),J("div",Ha,p[6]||(p[6]=[S("div",{class:"spinner"},null,-1),S("p",null,"Extracting data from image...",-1)]))):n.value.error?(Y(),J("div",ja,[p[7]||(p[7]=S("div",{class:"error-icon"},"!",-1)),S("p",za,te(n.value.error),1),S("button",{class:"retry-button",onClick:p[0]||(p[0]=y=>r(n.value))},"Try Again")])):n.value.extractedData?(Y(),J("div",Xa,[be(Ml,{data:n.value.extractedData},null,8,["data"])])):et("",!0)],64))])])])]))]))}}),Ya=kr(Ka,[["__scopeId","data-v-78df1051"]]),Ja={class:"app-container"},Za={class:"app-main"},Qa=zn({__name:"App",setup(e){return(t,n)=>(Y(),J("div",Ja,[n[0]||(n[0]=S("header",{class:"app-header"},[S("h1",null,"Ricoh GR III/x Recipe Decoder")],-1)),S("main",Za,[be(Ya)]),n[1]||(n[1]=S("footer",{class:"footer"},[S("a",{href:"https://github.com/ovibobi/ricoh-recipe-decoder",target:"_blank",rel:"noopener noreferrer"},"View on GitHub")],-1))]))}}),Hr=hl(Qa);Hr.use(vl());Hr.mount("#app");
