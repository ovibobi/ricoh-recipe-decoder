(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function i(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(n){if(n.ep)return;n.ep=!0;const s=i(n);fetch(n.href,s)}})();/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Gi(e){const t=Object.create(null);for(const i of e.split(","))t[i]=1;return i=>i in t}const J={},at=[],Ne=()=>{},us=()=>!1,ti=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),Ui=e=>e.startsWith("onUpdate:"),$e=Object.assign,Vi=(e,t)=>{const i=e.indexOf(t);i>-1&&e.splice(i,1)},ds=Object.prototype.hasOwnProperty,B=(e,t)=>ds.call(e,t),k=Array.isArray,$t=e=>ii(e)==="[object Map]",Jr=e=>ii(e)==="[object Set]",q=e=>typeof e=="function",se=e=>typeof e=="string",Ye=e=>typeof e=="symbol",te=e=>e!==null&&typeof e=="object",Zr=e=>(te(e)||q(e))&&q(e.then)&&q(e.catch),Qr=Object.prototype.toString,ii=e=>Qr.call(e),cs=e=>ii(e).slice(8,-1),en=e=>ii(e)==="[object Object]",Mi=e=>se(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,_t=Gi(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),ri=e=>{const t=Object.create(null);return i=>t[i]||(t[i]=e(i))},ps=/-(\w)/g,je=ri(e=>e.replace(ps,(t,i)=>i?i.toUpperCase():"")),ms=/\B([A-Z])/g,nt=ri(e=>e.replace(ms,"-$1").toLowerCase()),tn=ri(e=>e.charAt(0).toUpperCase()+e.slice(1)),ci=ri(e=>e?`on${tn(e)}`:""),He=(e,t)=>!Object.is(e,t),pi=(e,...t)=>{for(let i=0;i<e.length;i++)e[i](...t)},Ei=(e,t,i,r=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:r,value:i})},gs=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let mr;const ni=()=>mr||(mr=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Bi(e){if(k(e)){const t={};for(let i=0;i<e.length;i++){const r=e[i],n=se(r)?_s(r):Bi(r);if(n)for(const s in n)t[s]=n[s]}return t}else if(se(e)||te(e))return e}const hs=/;(?![^(]*\))/g,ys=/:([^]+)/,xs=/\/\*[^]*?\*\//g;function _s(e){const t={};return e.replace(xs,"").split(hs).forEach(i=>{if(i){const r=i.split(ys);r.length>1&&(t[r[0].trim()]=r[1].trim())}}),t}function he(e){let t="";if(se(e))t=e;else if(k(e))for(let i=0;i<e.length;i++){const r=he(e[i]);r&&(t+=r+" ")}else if(te(e))for(const i in e)e[i]&&(t+=i+" ");return t.trim()}const vs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",bs=Gi(vs);function rn(e){return!!e||e===""}const nn=e=>!!(e&&e.__v_isRef===!0),ie=e=>se(e)?e:e==null?"":k(e)||te(e)&&(e.toString===Qr||!q(e.toString))?nn(e)?ie(e.value):JSON.stringify(e,sn,2):String(e),sn=(e,t)=>nn(t)?sn(e,t.value):$t(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((i,[r,n],s)=>(i[mi(r,s)+" =>"]=n,i),{})}:Jr(t)?{[`Set(${t.size})`]:[...t.values()].map(i=>mi(i))}:Ye(t)?mi(t):te(t)&&!k(t)&&!en(t)?String(t):t,mi=(e,t="")=>{var i;return Ye(e)?`Symbol(${(i=e.description)!=null?i:t})`:e};/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ge;class on{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=ge,!t&&ge&&(this.index=(ge.scopes||(ge.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,i;if(this.scopes)for(t=0,i=this.scopes.length;t<i;t++)this.scopes[t].pause();for(t=0,i=this.effects.length;t<i;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,i;if(this.scopes)for(t=0,i=this.scopes.length;t<i;t++)this.scopes[t].resume();for(t=0,i=this.effects.length;t<i;t++)this.effects[t].resume()}}run(t){if(this._active){const i=ge;try{return ge=this,t()}finally{ge=i}}}on(){++this._on===1&&(this.prevScope=ge,ge=this)}off(){this._on>0&&--this._on===0&&(ge=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let i,r;for(i=0,r=this.effects.length;i<r;i++)this.effects[i].stop();for(this.effects.length=0,i=0,r=this.cleanups.length;i<r;i++)this.cleanups[i]();if(this.cleanups.length=0,this.scopes){for(i=0,r=this.scopes.length;i<r;i++)this.scopes[i].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const n=this.parent.scopes.pop();n&&n!==this&&(this.parent.scopes[this.index]=n,n.index=this.index)}this.parent=void 0}}}function ws(e){return new on(e)}function Fs(){return ge}let Y;const gi=new WeakSet;class ln{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,ge&&ge.active&&ge.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,gi.has(this)&&(gi.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||$n(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,gr(this),fn(this);const t=Y,i=Ee;Y=this,Ee=!0;try{return this.fn()}finally{un(this),Y=t,Ee=i,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)ji(t);this.deps=this.depsTail=void 0,gr(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?gi.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Si(this)&&this.run()}get dirty(){return Si(this)}}let an=0,vt,bt;function $n(e,t=!1){if(e.flags|=8,t){e.next=bt,bt=e;return}e.next=vt,vt=e}function zi(){an++}function Hi(){if(--an>0)return;if(bt){let t=bt;for(bt=void 0;t;){const i=t.next;t.next=void 0,t.flags&=-9,t=i}}let e;for(;vt;){let t=vt;for(vt=void 0;t;){const i=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(r){e||(e=r)}t=i}}if(e)throw e}function fn(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function un(e){let t,i=e.depsTail,r=i;for(;r;){const n=r.prevDep;r.version===-1?(r===i&&(i=n),ji(r),Es(r)):t=r,r.dep.activeLink=r.prevActiveLink,r.prevActiveLink=void 0,r=n}e.deps=t,e.depsTail=i}function Si(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(dn(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function dn(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===Ot)||(e.globalVersion=Ot,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Si(e))))return;e.flags|=2;const t=e.dep,i=Y,r=Ee;Y=e,Ee=!0;try{fn(e);const n=e.fn(e._value);(t.version===0||He(n,e._value))&&(e.flags|=128,e._value=n,t.version++)}catch(n){throw t.version++,n}finally{Y=i,Ee=r,un(e),e.flags&=-3}}function ji(e,t=!1){const{dep:i,prevSub:r,nextSub:n}=e;if(r&&(r.nextSub=n,e.prevSub=void 0),n&&(n.prevSub=r,e.nextSub=void 0),i.subs===e&&(i.subs=r,!r&&i.computed)){i.computed.flags&=-5;for(let s=i.computed.deps;s;s=s.nextDep)ji(s,!0)}!t&&!--i.sc&&i.map&&i.map.delete(i.key)}function Es(e){const{prevDep:t,nextDep:i}=e;t&&(t.nextDep=i,e.prevDep=void 0),i&&(i.prevDep=t,e.nextDep=void 0)}let Ee=!0;const cn=[];function Ge(){cn.push(Ee),Ee=!1}function Ue(){const e=cn.pop();Ee=e===void 0?!0:e}function gr(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const i=Y;Y=void 0;try{t()}finally{Y=i}}}let Ot=0;class Ss{constructor(t,i){this.sub=t,this.dep=i,this.version=i.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Xi{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){if(!Y||!Ee||Y===this.computed)return;let i=this.activeLink;if(i===void 0||i.sub!==Y)i=this.activeLink=new Ss(Y,this),Y.deps?(i.prevDep=Y.depsTail,Y.depsTail.nextDep=i,Y.depsTail=i):Y.deps=Y.depsTail=i,pn(i);else if(i.version===-1&&(i.version=this.version,i.nextDep)){const r=i.nextDep;r.prevDep=i.prevDep,i.prevDep&&(i.prevDep.nextDep=r),i.prevDep=Y.depsTail,i.nextDep=void 0,Y.depsTail.nextDep=i,Y.depsTail=i,Y.deps===i&&(Y.deps=r)}return i}trigger(t){this.version++,Ot++,this.notify(t)}notify(t){zi();try{for(let i=this.subs;i;i=i.prevSub)i.sub.notify()&&i.sub.dep.notify()}finally{Hi()}}}function pn(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let r=t.deps;r;r=r.nextDep)pn(r)}const i=e.dep.subs;i!==e&&(e.prevSub=i,i&&(i.nextSub=e)),e.dep.subs=e}}const Ti=new WeakMap,rt=Symbol(""),Oi=Symbol(""),It=Symbol("");function le(e,t,i){if(Ee&&Y){let r=Ti.get(e);r||Ti.set(e,r=new Map);let n=r.get(i);n||(r.set(i,n=new Xi),n.map=r,n.key=i),n.track()}}function qe(e,t,i,r,n,s){const o=Ti.get(e);if(!o){Ot++;return}const l=a=>{a&&a.trigger()};if(zi(),t==="clear")o.forEach(l);else{const a=k(e),p=a&&Mi(i);if(a&&i==="length"){const f=Number(r);o.forEach((c,h)=>{(h==="length"||h===It||!Ye(h)&&h>=f)&&l(c)})}else switch((i!==void 0||o.has(void 0))&&l(o.get(i)),p&&l(o.get(It)),t){case"add":a?p&&l(o.get("length")):(l(o.get(rt)),$t(e)&&l(o.get(Oi)));break;case"delete":a||(l(o.get(rt)),$t(e)&&l(o.get(Oi)));break;case"set":$t(e)&&l(o.get(rt));break}}Hi()}function ot(e){const t=M(e);return t===e?t:(le(t,"iterate",It),we(e)?t:t.map(oe))}function si(e){return le(e=M(e),"iterate",It),e}const Ts={__proto__:null,[Symbol.iterator](){return hi(this,Symbol.iterator,oe)},concat(...e){return ot(this).concat(...e.map(t=>k(t)?ot(t):t))},entries(){return hi(this,"entries",e=>(e[1]=oe(e[1]),e))},every(e,t){return Le(this,"every",e,t,void 0,arguments)},filter(e,t){return Le(this,"filter",e,t,i=>i.map(oe),arguments)},find(e,t){return Le(this,"find",e,t,oe,arguments)},findIndex(e,t){return Le(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return Le(this,"findLast",e,t,oe,arguments)},findLastIndex(e,t){return Le(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return Le(this,"forEach",e,t,void 0,arguments)},includes(...e){return yi(this,"includes",e)},indexOf(...e){return yi(this,"indexOf",e)},join(e){return ot(this).join(e)},lastIndexOf(...e){return yi(this,"lastIndexOf",e)},map(e,t){return Le(this,"map",e,t,void 0,arguments)},pop(){return ht(this,"pop")},push(...e){return ht(this,"push",e)},reduce(e,...t){return hr(this,"reduce",e,t)},reduceRight(e,...t){return hr(this,"reduceRight",e,t)},shift(){return ht(this,"shift")},some(e,t){return Le(this,"some",e,t,void 0,arguments)},splice(...e){return ht(this,"splice",e)},toReversed(){return ot(this).toReversed()},toSorted(e){return ot(this).toSorted(e)},toSpliced(...e){return ot(this).toSpliced(...e)},unshift(...e){return ht(this,"unshift",e)},values(){return hi(this,"values",oe)}};function hi(e,t,i){const r=si(e),n=r[t]();return r!==e&&!we(e)&&(n._next=n.next,n.next=()=>{const s=n._next();return s.value&&(s.value=i(s.value)),s}),n}const Os=Array.prototype;function Le(e,t,i,r,n,s){const o=si(e),l=o!==e&&!we(e),a=o[t];if(a!==Os[t]){const c=a.apply(e,s);return l?oe(c):c}let p=i;o!==e&&(l?p=function(c,h){return i.call(this,oe(c),h,e)}:i.length>2&&(p=function(c,h){return i.call(this,c,h,e)}));const f=a.call(o,p,r);return l&&n?n(f):f}function hr(e,t,i,r){const n=si(e);let s=i;return n!==e&&(we(e)?i.length>3&&(s=function(o,l,a){return i.call(this,o,l,a,e)}):s=function(o,l,a){return i.call(this,o,oe(l),a,e)}),n[t](s,...r)}function yi(e,t,i){const r=M(e);le(r,"iterate",It);const n=r[t](...i);return(n===-1||n===!1)&&Zi(i[0])?(i[0]=M(i[0]),r[t](...i)):n}function ht(e,t,i=[]){Ge(),zi();const r=M(e)[t].apply(e,i);return Hi(),Ue(),r}const Is=Gi("__proto__,__v_isRef,__isVue"),mn=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(Ye));function Cs(e){Ye(e)||(e=String(e));const t=M(this);return le(t,"has",e),t.hasOwnProperty(e)}class gn{constructor(t=!1,i=!1){this._isReadonly=t,this._isShallow=i}get(t,i,r){if(i==="__v_skip")return t.__v_skip;const n=this._isReadonly,s=this._isShallow;if(i==="__v_isReactive")return!n;if(i==="__v_isReadonly")return n;if(i==="__v_isShallow")return s;if(i==="__v_raw")return r===(n?s?Gs:_n:s?xn:yn).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(r)?t:void 0;const o=k(t);if(!n){let a;if(o&&(a=Ts[i]))return a;if(i==="hasOwnProperty")return Cs}const l=Reflect.get(t,i,ae(t)?t:r);return(Ye(i)?mn.has(i):Is(i))||(n||le(t,"get",i),s)?l:ae(l)?o&&Mi(i)?l:l.value:te(l)?n?vn(l):Yi(l):l}}class hn extends gn{constructor(t=!1){super(!1,t)}set(t,i,r,n){let s=t[i];if(!this._isShallow){const a=Xe(s);if(!we(r)&&!Xe(r)&&(s=M(s),r=M(r)),!k(t)&&ae(s)&&!ae(r))return a?!1:(s.value=r,!0)}const o=k(t)&&Mi(i)?Number(i)<t.length:B(t,i),l=Reflect.set(t,i,r,ae(t)?t:n);return t===M(n)&&(o?He(r,s)&&qe(t,"set",i,r):qe(t,"add",i,r)),l}deleteProperty(t,i){const r=B(t,i);t[i];const n=Reflect.deleteProperty(t,i);return n&&r&&qe(t,"delete",i,void 0),n}has(t,i){const r=Reflect.has(t,i);return(!Ye(i)||!mn.has(i))&&le(t,"has",i),r}ownKeys(t){return le(t,"iterate",k(t)?"length":rt),Reflect.ownKeys(t)}}class As extends gn{constructor(t=!1){super(!0,t)}set(t,i){return!0}deleteProperty(t,i){return!0}}const Ds=new hn,Ps=new As,Ns=new hn(!0);const Ii=e=>e,kt=e=>Reflect.getPrototypeOf(e);function Rs(e,t,i){return function(...r){const n=this.__v_raw,s=M(n),o=$t(s),l=e==="entries"||e===Symbol.iterator&&o,a=e==="keys"&&o,p=n[e](...r),f=i?Ii:t?Ht:oe;return!t&&le(s,"iterate",a?Oi:rt),{next(){const{value:c,done:h}=p.next();return h?{value:c,done:h}:{value:l?[f(c[0]),f(c[1])]:f(c),done:h}},[Symbol.iterator](){return this}}}}function qt(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function Ws(e,t){const i={get(n){const s=this.__v_raw,o=M(s),l=M(n);e||(He(n,l)&&le(o,"get",n),le(o,"get",l));const{has:a}=kt(o),p=t?Ii:e?Ht:oe;if(a.call(o,n))return p(s.get(n));if(a.call(o,l))return p(s.get(l));s!==o&&s.get(n)},get size(){const n=this.__v_raw;return!e&&le(M(n),"iterate",rt),Reflect.get(n,"size",n)},has(n){const s=this.__v_raw,o=M(s),l=M(n);return e||(He(n,l)&&le(o,"has",n),le(o,"has",l)),n===l?s.has(n):s.has(n)||s.has(l)},forEach(n,s){const o=this,l=o.__v_raw,a=M(l),p=t?Ii:e?Ht:oe;return!e&&le(a,"iterate",rt),l.forEach((f,c)=>n.call(s,p(f),p(c),o))}};return $e(i,e?{add:qt("add"),set:qt("set"),delete:qt("delete"),clear:qt("clear")}:{add(n){!t&&!we(n)&&!Xe(n)&&(n=M(n));const s=M(this);return kt(s).has.call(s,n)||(s.add(n),qe(s,"add",n,n)),this},set(n,s){!t&&!we(s)&&!Xe(s)&&(s=M(s));const o=M(this),{has:l,get:a}=kt(o);let p=l.call(o,n);p||(n=M(n),p=l.call(o,n));const f=a.call(o,n);return o.set(n,s),p?He(s,f)&&qe(o,"set",n,s):qe(o,"add",n,s),this},delete(n){const s=M(this),{has:o,get:l}=kt(s);let a=o.call(s,n);a||(n=M(n),a=o.call(s,n)),l&&l.call(s,n);const p=s.delete(n);return a&&qe(s,"delete",n,void 0),p},clear(){const n=M(this),s=n.size!==0,o=n.clear();return s&&qe(n,"clear",void 0,void 0),o}}),["keys","values","entries",Symbol.iterator].forEach(n=>{i[n]=Rs(n,e,t)}),i}function Ki(e,t){const i=Ws(e,t);return(r,n,s)=>n==="__v_isReactive"?!e:n==="__v_isReadonly"?e:n==="__v_raw"?r:Reflect.get(B(i,n)&&n in r?i:r,n,s)}const Ls={get:Ki(!1,!1)},ks={get:Ki(!1,!0)},qs={get:Ki(!0,!1)};const yn=new WeakMap,xn=new WeakMap,_n=new WeakMap,Gs=new WeakMap;function Us(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Vs(e){return e.__v_skip||!Object.isExtensible(e)?0:Us(cs(e))}function Yi(e){return Xe(e)?e:Ji(e,!1,Ds,Ls,yn)}function Ms(e){return Ji(e,!1,Ns,ks,xn)}function vn(e){return Ji(e,!0,Ps,qs,_n)}function Ji(e,t,i,r,n){if(!te(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=Vs(e);if(s===0)return e;const o=n.get(e);if(o)return o;const l=new Proxy(e,s===2?r:i);return n.set(e,l),l}function ft(e){return Xe(e)?ft(e.__v_raw):!!(e&&e.__v_isReactive)}function Xe(e){return!!(e&&e.__v_isReadonly)}function we(e){return!!(e&&e.__v_isShallow)}function Zi(e){return e?!!e.__v_raw:!1}function M(e){const t=e&&e.__v_raw;return t?M(t):e}function bn(e){return!B(e,"__v_skip")&&Object.isExtensible(e)&&Ei(e,"__v_skip",!0),e}const oe=e=>te(e)?Yi(e):e,Ht=e=>te(e)?vn(e):e;function ae(e){return e?e.__v_isRef===!0:!1}function jt(e){return Bs(e,!1)}function Bs(e,t){return ae(e)?e:new zs(e,t)}class zs{constructor(t,i){this.dep=new Xi,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=i?t:M(t),this._value=i?t:oe(t),this.__v_isShallow=i}get value(){return this.dep.track(),this._value}set value(t){const i=this._rawValue,r=this.__v_isShallow||we(t)||Xe(t);t=r?t:M(t),He(t,i)&&(this._rawValue=t,this._value=r?t:oe(t),this.dep.trigger())}}function Hs(e){return ae(e)?e.value:e}const js={get:(e,t,i)=>t==="__v_raw"?e:Hs(Reflect.get(e,t,i)),set:(e,t,i,r)=>{const n=e[t];return ae(n)&&!ae(i)?(n.value=i,!0):Reflect.set(e,t,i,r)}};function wn(e){return ft(e)?e:new Proxy(e,js)}class Xs{constructor(t,i,r){this.fn=t,this.setter=i,this._value=void 0,this.dep=new Xi(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Ot-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!i,this.isSSR=r}notify(){if(this.flags|=16,!(this.flags&8)&&Y!==this)return $n(this,!0),!0}get value(){const t=this.dep.track();return dn(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter&&this.setter(t)}}function Ks(e,t,i=!1){let r,n;return q(e)?r=e:(r=e.get,n=e.set),new Xs(r,n,i)}const Gt={},Xt=new WeakMap;let tt;function Ys(e,t=!1,i=tt){if(i){let r=Xt.get(i);r||Xt.set(i,r=[]),r.push(e)}}function Js(e,t,i=J){const{immediate:r,deep:n,once:s,scheduler:o,augmentJob:l,call:a}=i,p=C=>n?C:we(C)||n===!1||n===0?ze(C,1):ze(C);let f,c,h,m,d=!1,g=!1;if(ae(e)?(c=()=>e.value,d=we(e)):ft(e)?(c=()=>p(e),d=!0):k(e)?(g=!0,d=e.some(C=>ft(C)||we(C)),c=()=>e.map(C=>{if(ae(C))return C.value;if(ft(C))return p(C);if(q(C))return a?a(C,2):C()})):q(e)?t?c=a?()=>a(e,2):e:c=()=>{if(h){Ge();try{h()}finally{Ue()}}const C=tt;tt=f;try{return a?a(e,3,[m]):e(m)}finally{tt=C}}:c=Ne,t&&n){const C=c,P=n===!0?1/0:n;c=()=>ze(C(),P)}const F=Fs(),_=()=>{f.stop(),F&&F.active&&Vi(F.effects,f)};if(s&&t){const C=t;t=(...P)=>{C(...P),_()}}let D=g?new Array(e.length).fill(Gt):Gt;const W=C=>{if(!(!(f.flags&1)||!f.dirty&&!C))if(t){const P=f.run();if(n||d||(g?P.some((U,G)=>He(U,D[G])):He(P,D))){h&&h();const U=tt;tt=f;try{const G=[P,D===Gt?void 0:g&&D[0]===Gt?[]:D,m];D=P,a?a(t,3,G):t(...G)}finally{tt=U}}}else f.run()};return l&&l(W),f=new ln(c),f.scheduler=o?()=>o(W,!1):W,m=C=>Ys(C,!1,f),h=f.onStop=()=>{const C=Xt.get(f);if(C){if(a)a(C,4);else for(const P of C)P();Xt.delete(f)}},t?r?W(!0):D=f.run():o?o(W.bind(null,!0),!0):f.run(),_.pause=f.pause.bind(f),_.resume=f.resume.bind(f),_.stop=_,_}function ze(e,t=1/0,i){if(t<=0||!te(e)||e.__v_skip||(i=i||new Set,i.has(e)))return e;if(i.add(e),t--,ae(e))ze(e.value,t,i);else if(k(e))for(let r=0;r<e.length;r++)ze(e[r],t,i);else if(Jr(e)||$t(e))e.forEach(r=>{ze(r,t,i)});else if(en(e)){for(const r in e)ze(e[r],t,i);for(const r of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,r)&&ze(e[r],t,i)}return e}/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Pt(e,t,i,r){try{return r?e(...r):e()}catch(n){oi(n,t,i)}}function Re(e,t,i,r){if(q(e)){const n=Pt(e,t,i,r);return n&&Zr(n)&&n.catch(s=>{oi(s,t,i)}),n}if(k(e)){const n=[];for(let s=0;s<e.length;s++)n.push(Re(e[s],t,i,r));return n}}function oi(e,t,i,r=!0){const n=t?t.vnode:null,{errorHandler:s,throwUnhandledErrorInProduction:o}=t&&t.appContext.config||J;if(t){let l=t.parent;const a=t.proxy,p=`https://vuejs.org/error-reference/#runtime-${i}`;for(;l;){const f=l.ec;if(f){for(let c=0;c<f.length;c++)if(f[c](e,a,p)===!1)return}l=l.parent}if(s){Ge(),Pt(s,null,10,[e,a,p]),Ue();return}}Zs(e,i,n,r,o)}function Zs(e,t,i,r=!0,n=!1){if(n)throw e;console.error(e)}const de=[];let Ae=-1;const ut=[];let Me=null,lt=0;const Fn=Promise.resolve();let Kt=null;function En(e){const t=Kt||Fn;return e?t.then(this?e.bind(this):e):t}function Qs(e){let t=Ae+1,i=de.length;for(;t<i;){const r=t+i>>>1,n=de[r],s=Ct(n);s<e||s===e&&n.flags&2?t=r+1:i=r}return t}function Qi(e){if(!(e.flags&1)){const t=Ct(e),i=de[de.length-1];!i||!(e.flags&2)&&t>=Ct(i)?de.push(e):de.splice(Qs(t),0,e),e.flags|=1,Sn()}}function Sn(){Kt||(Kt=Fn.then(On))}function eo(e){k(e)?ut.push(...e):Me&&e.id===-1?Me.splice(lt+1,0,e):e.flags&1||(ut.push(e),e.flags|=1),Sn()}function yr(e,t,i=Ae+1){for(;i<de.length;i++){const r=de[i];if(r&&r.flags&2){if(e&&r.id!==e.uid)continue;de.splice(i,1),i--,r.flags&4&&(r.flags&=-2),r(),r.flags&4||(r.flags&=-2)}}}function Tn(e){if(ut.length){const t=[...new Set(ut)].sort((i,r)=>Ct(i)-Ct(r));if(ut.length=0,Me){Me.push(...t);return}for(Me=t,lt=0;lt<Me.length;lt++){const i=Me[lt];i.flags&4&&(i.flags&=-2),i.flags&8||i(),i.flags&=-2}Me=null,lt=0}}const Ct=e=>e.id==null?e.flags&2?-1:1/0:e.id;function On(e){try{for(Ae=0;Ae<de.length;Ae++){const t=de[Ae];t&&!(t.flags&8)&&(t.flags&4&&(t.flags&=-2),Pt(t,t.i,t.i?15:14),t.flags&4||(t.flags&=-2))}}finally{for(;Ae<de.length;Ae++){const t=de[Ae];t&&(t.flags&=-2)}Ae=-1,de.length=0,Tn(),Kt=null,(de.length||ut.length)&&On()}}let Pe=null,In=null;function Yt(e){const t=Pe;return Pe=e,In=e&&e.type.__scopeId||null,t}function to(e,t=Pe,i){if(!t||e._n)return e;const r=(...n)=>{r._d&&Tr(-1);const s=Yt(t);let o;try{o=e(...n)}finally{Yt(s),r._d&&Tr(1)}return o};return r._n=!0,r._c=!0,r._d=!0,r}function Qe(e,t,i,r){const n=e.dirs,s=t&&t.dirs;for(let o=0;o<n.length;o++){const l=n[o];s&&(l.oldValue=s[o].value);let a=l.dir[r];a&&(Ge(),Re(a,i,8,[e.el,l,e,t]),Ue())}}const io=Symbol("_vte"),ro=e=>e.__isTeleport;function er(e,t){e.shapeFlag&6&&e.component?(e.transition=t,er(e.component.subTree,t)):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}/*! #__NO_SIDE_EFFECTS__ */function tr(e,t){return q(e)?$e({name:e.name},t,{setup:e}):e}function Cn(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}function wt(e,t,i,r,n=!1){if(k(e)){e.forEach((d,g)=>wt(d,t&&(k(t)?t[g]:t),i,r,n));return}if(Ft(r)&&!n){r.shapeFlag&512&&r.type.__asyncResolved&&r.component.subTree.component&&wt(e,t,i,r.component.subTree);return}const s=r.shapeFlag&4?lr(r.component):r.el,o=n?null:s,{i:l,r:a}=e,p=t&&t.r,f=l.refs===J?l.refs={}:l.refs,c=l.setupState,h=M(c),m=c===J?()=>!1:d=>B(h,d);if(p!=null&&p!==a&&(se(p)?(f[p]=null,m(p)&&(c[p]=null)):ae(p)&&(p.value=null)),q(a))Pt(a,l,12,[o,f]);else{const d=se(a),g=ae(a);if(d||g){const F=()=>{if(e.f){const _=d?m(a)?c[a]:f[a]:a.value;n?k(_)&&Vi(_,s):k(_)?_.includes(s)||_.push(s):d?(f[a]=[s],m(a)&&(c[a]=f[a])):(a.value=[s],e.k&&(f[e.k]=a.value))}else d?(f[a]=o,m(a)&&(c[a]=o)):g&&(a.value=o,e.k&&(f[e.k]=o))};o?(F.id=-1,ve(F,i)):F()}}}ni().requestIdleCallback;ni().cancelIdleCallback;const Ft=e=>!!e.type.__asyncLoader,An=e=>e.type.__isKeepAlive;function no(e,t){Dn(e,"a",t)}function so(e,t){Dn(e,"da",t)}function Dn(e,t,i=ce){const r=e.__wdc||(e.__wdc=()=>{let n=i;for(;n;){if(n.isDeactivated)return;n=n.parent}return e()});if(li(t,r,i),i){let n=i.parent;for(;n&&n.parent;)An(n.parent.vnode)&&oo(r,t,i,n),n=n.parent}}function oo(e,t,i,r){const n=li(t,e,r,!0);rr(()=>{Vi(r[t],n)},i)}function li(e,t,i=ce,r=!1){if(i){const n=i[e]||(i[e]=[]),s=t.__weh||(t.__weh=(...o)=>{Ge();const l=Nt(i),a=Re(t,i,e,o);return l(),Ue(),a});return r?n.unshift(s):n.push(s),s}}const Ve=e=>(t,i=ce)=>{(!Dt||e==="sp")&&li(e,(...r)=>t(...r),i)},lo=Ve("bm"),ir=Ve("m"),ao=Ve("bu"),$o=Ve("u"),fo=Ve("bum"),rr=Ve("um"),uo=Ve("sp"),co=Ve("rtg"),po=Ve("rtc");function mo(e,t=ce){li("ec",e,t)}const go=Symbol.for("v-ndc");function Pn(e,t,i,r){let n;const s=i,o=k(e);if(o||se(e)){const l=o&&ft(e);let a=!1,p=!1;l&&(a=!we(e),p=Xe(e),e=si(e)),n=new Array(e.length);for(let f=0,c=e.length;f<c;f++)n[f]=t(a?p?Ht(oe(e[f])):oe(e[f]):e[f],f,void 0,s)}else if(typeof e=="number"){n=new Array(e);for(let l=0;l<e;l++)n[l]=t(l+1,l,void 0,s)}else if(te(e))if(e[Symbol.iterator])n=Array.from(e,(l,a)=>t(l,a,void 0,s));else{const l=Object.keys(e);n=new Array(l.length);for(let a=0,p=l.length;a<p;a++){const f=l[a];n[a]=t(e[f],f,a,s)}}else n=[];return n}const Ci=e=>e?es(e)?lr(e):Ci(e.parent):null,Et=$e(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Ci(e.parent),$root:e=>Ci(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>Rn(e),$forceUpdate:e=>e.f||(e.f=()=>{Qi(e.update)}),$nextTick:e=>e.n||(e.n=En.bind(e.proxy)),$watch:e=>ko.bind(e)}),xi=(e,t)=>e!==J&&!e.__isScriptSetup&&B(e,t),ho={get({_:e},t){if(t==="__v_skip")return!0;const{ctx:i,setupState:r,data:n,props:s,accessCache:o,type:l,appContext:a}=e;let p;if(t[0]!=="$"){const m=o[t];if(m!==void 0)switch(m){case 1:return r[t];case 2:return n[t];case 4:return i[t];case 3:return s[t]}else{if(xi(r,t))return o[t]=1,r[t];if(n!==J&&B(n,t))return o[t]=2,n[t];if((p=e.propsOptions[0])&&B(p,t))return o[t]=3,s[t];if(i!==J&&B(i,t))return o[t]=4,i[t];Ai&&(o[t]=0)}}const f=Et[t];let c,h;if(f)return t==="$attrs"&&le(e.attrs,"get",""),f(e);if((c=l.__cssModules)&&(c=c[t]))return c;if(i!==J&&B(i,t))return o[t]=4,i[t];if(h=a.config.globalProperties,B(h,t))return h[t]},set({_:e},t,i){const{data:r,setupState:n,ctx:s}=e;return xi(n,t)?(n[t]=i,!0):r!==J&&B(r,t)?(r[t]=i,!0):B(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(s[t]=i,!0)},has({_:{data:e,setupState:t,accessCache:i,ctx:r,appContext:n,propsOptions:s}},o){let l;return!!i[o]||e!==J&&B(e,o)||xi(t,o)||(l=s[0])&&B(l,o)||B(r,o)||B(Et,o)||B(n.config.globalProperties,o)},defineProperty(e,t,i){return i.get!=null?e._.accessCache[t]=0:B(i,"value")&&this.set(e,t,i.value,null),Reflect.defineProperty(e,t,i)}};function xr(e){return k(e)?e.reduce((t,i)=>(t[i]=null,t),{}):e}let Ai=!0;function yo(e){const t=Rn(e),i=e.proxy,r=e.ctx;Ai=!1,t.beforeCreate&&_r(t.beforeCreate,e,"bc");const{data:n,computed:s,methods:o,watch:l,provide:a,inject:p,created:f,beforeMount:c,mounted:h,beforeUpdate:m,updated:d,activated:g,deactivated:F,beforeDestroy:_,beforeUnmount:D,destroyed:W,unmounted:C,render:P,renderTracked:U,renderTriggered:G,errorCaptured:H,serverPrefetch:ne,expose:xe,inheritAttrs:We,components:st,directives:Rt,filters:ui}=t;if(p&&xo(p,r,null),o)for(const ee in o){const X=o[ee];q(X)&&(r[ee]=X.bind(i))}if(n){const ee=n.call(i,i);te(ee)&&(e.data=Yi(ee))}if(Ai=!0,s)for(const ee in s){const X=s[ee],Je=q(X)?X.bind(i,i):q(X.get)?X.get.bind(i,i):Ne,Wt=!q(X)&&q(X.set)?X.set.bind(i):Ne,Ze=ll({get:Je,set:Wt});Object.defineProperty(r,ee,{enumerable:!0,configurable:!0,get:()=>Ze.value,set:Se=>Ze.value=Se})}if(l)for(const ee in l)Nn(l[ee],r,i,ee);if(a){const ee=q(a)?a.call(i):a;Reflect.ownKeys(ee).forEach(X=>{Eo(X,ee[X])})}f&&_r(f,e,"c");function fe(ee,X){k(X)?X.forEach(Je=>ee(Je.bind(i))):X&&ee(X.bind(i))}if(fe(lo,c),fe(ir,h),fe(ao,m),fe($o,d),fe(no,g),fe(so,F),fe(mo,H),fe(po,U),fe(co,G),fe(fo,D),fe(rr,C),fe(uo,ne),k(xe))if(xe.length){const ee=e.exposed||(e.exposed={});xe.forEach(X=>{Object.defineProperty(ee,X,{get:()=>i[X],set:Je=>i[X]=Je})})}else e.exposed||(e.exposed={});P&&e.render===Ne&&(e.render=P),We!=null&&(e.inheritAttrs=We),st&&(e.components=st),Rt&&(e.directives=Rt),ne&&Cn(e)}function xo(e,t,i=Ne){k(e)&&(e=Di(e));for(const r in e){const n=e[r];let s;te(n)?"default"in n?s=Ut(n.from||r,n.default,!0):s=Ut(n.from||r):s=Ut(n),ae(s)?Object.defineProperty(t,r,{enumerable:!0,configurable:!0,get:()=>s.value,set:o=>s.value=o}):t[r]=s}}function _r(e,t,i){Re(k(e)?e.map(r=>r.bind(t.proxy)):e.bind(t.proxy),t,i)}function Nn(e,t,i,r){let n=r.includes(".")?Xn(i,r):()=>i[r];if(se(e)){const s=t[e];q(s)&&vi(n,s)}else if(q(e))vi(n,e.bind(i));else if(te(e))if(k(e))e.forEach(s=>Nn(s,t,i,r));else{const s=q(e.handler)?e.handler.bind(i):t[e.handler];q(s)&&vi(n,s,e)}}function Rn(e){const t=e.type,{mixins:i,extends:r}=t,{mixins:n,optionsCache:s,config:{optionMergeStrategies:o}}=e.appContext,l=s.get(t);let a;return l?a=l:!n.length&&!i&&!r?a=t:(a={},n.length&&n.forEach(p=>Jt(a,p,o,!0)),Jt(a,t,o)),te(t)&&s.set(t,a),a}function Jt(e,t,i,r=!1){const{mixins:n,extends:s}=t;s&&Jt(e,s,i,!0),n&&n.forEach(o=>Jt(e,o,i,!0));for(const o in t)if(!(r&&o==="expose")){const l=_o[o]||i&&i[o];e[o]=l?l(e[o],t[o]):t[o]}return e}const _o={data:vr,props:br,emits:br,methods:xt,computed:xt,beforeCreate:ue,created:ue,beforeMount:ue,mounted:ue,beforeUpdate:ue,updated:ue,beforeDestroy:ue,beforeUnmount:ue,destroyed:ue,unmounted:ue,activated:ue,deactivated:ue,errorCaptured:ue,serverPrefetch:ue,components:xt,directives:xt,watch:bo,provide:vr,inject:vo};function vr(e,t){return t?e?function(){return $e(q(e)?e.call(this,this):e,q(t)?t.call(this,this):t)}:t:e}function vo(e,t){return xt(Di(e),Di(t))}function Di(e){if(k(e)){const t={};for(let i=0;i<e.length;i++)t[e[i]]=e[i];return t}return e}function ue(e,t){return e?[...new Set([].concat(e,t))]:t}function xt(e,t){return e?$e(Object.create(null),e,t):t}function br(e,t){return e?k(e)&&k(t)?[...new Set([...e,...t])]:$e(Object.create(null),xr(e),xr(t??{})):t}function bo(e,t){if(!e)return t;if(!t)return e;const i=$e(Object.create(null),e);for(const r in t)i[r]=ue(e[r],t[r]);return i}function Wn(){return{app:null,config:{isNativeTag:us,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let wo=0;function Fo(e,t){return function(r,n=null){q(r)||(r=$e({},r)),n!=null&&!te(n)&&(n=null);const s=Wn(),o=new WeakSet,l=[];let a=!1;const p=s.app={_uid:wo++,_component:r,_props:n,_container:null,_context:s,_instance:null,version:al,get config(){return s.config},set config(f){},use(f,...c){return o.has(f)||(f&&q(f.install)?(o.add(f),f.install(p,...c)):q(f)&&(o.add(f),f(p,...c))),p},mixin(f){return s.mixins.includes(f)||s.mixins.push(f),p},component(f,c){return c?(s.components[f]=c,p):s.components[f]},directive(f,c){return c?(s.directives[f]=c,p):s.directives[f]},mount(f,c,h){if(!a){const m=p._ceVNode||Fe(r,n);return m.appContext=s,h===!0?h="svg":h===!1&&(h=void 0),e(m,f,h),a=!0,p._container=f,f.__vue_app__=p,lr(m.component)}},onUnmount(f){l.push(f)},unmount(){a&&(Re(l,p._instance,16),e(null,p._container),delete p._container.__vue_app__)},provide(f,c){return s.provides[f]=c,p},runWithContext(f){const c=dt;dt=p;try{return f()}finally{dt=c}}};return p}}let dt=null;function Eo(e,t){if(ce){let i=ce.provides;const r=ce.parent&&ce.parent.provides;r===i&&(i=ce.provides=Object.create(r)),i[e]=t}}function Ut(e,t,i=!1){const r=ce||Pe;if(r||dt){let n=dt?dt._context.provides:r?r.parent==null||r.ce?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides:void 0;if(n&&e in n)return n[e];if(arguments.length>1)return i&&q(t)?t.call(r&&r.proxy):t}}const Ln={},kn=()=>Object.create(Ln),qn=e=>Object.getPrototypeOf(e)===Ln;function So(e,t,i,r=!1){const n={},s=kn();e.propsDefaults=Object.create(null),Gn(e,t,n,s);for(const o in e.propsOptions[0])o in n||(n[o]=void 0);i?e.props=r?n:Ms(n):e.type.props?e.props=n:e.props=s,e.attrs=s}function To(e,t,i,r){const{props:n,attrs:s,vnode:{patchFlag:o}}=e,l=M(n),[a]=e.propsOptions;let p=!1;if((r||o>0)&&!(o&16)){if(o&8){const f=e.vnode.dynamicProps;for(let c=0;c<f.length;c++){let h=f[c];if(ai(e.emitsOptions,h))continue;const m=t[h];if(a)if(B(s,h))m!==s[h]&&(s[h]=m,p=!0);else{const d=je(h);n[d]=Pi(a,l,d,m,e,!1)}else m!==s[h]&&(s[h]=m,p=!0)}}}else{Gn(e,t,n,s)&&(p=!0);let f;for(const c in l)(!t||!B(t,c)&&((f=nt(c))===c||!B(t,f)))&&(a?i&&(i[c]!==void 0||i[f]!==void 0)&&(n[c]=Pi(a,l,c,void 0,e,!0)):delete n[c]);if(s!==l)for(const c in s)(!t||!B(t,c))&&(delete s[c],p=!0)}p&&qe(e.attrs,"set","")}function Gn(e,t,i,r){const[n,s]=e.propsOptions;let o=!1,l;if(t)for(let a in t){if(_t(a))continue;const p=t[a];let f;n&&B(n,f=je(a))?!s||!s.includes(f)?i[f]=p:(l||(l={}))[f]=p:ai(e.emitsOptions,a)||(!(a in r)||p!==r[a])&&(r[a]=p,o=!0)}if(s){const a=M(i),p=l||J;for(let f=0;f<s.length;f++){const c=s[f];i[c]=Pi(n,a,c,p[c],e,!B(p,c))}}return o}function Pi(e,t,i,r,n,s){const o=e[i];if(o!=null){const l=B(o,"default");if(l&&r===void 0){const a=o.default;if(o.type!==Function&&!o.skipFactory&&q(a)){const{propsDefaults:p}=n;if(i in p)r=p[i];else{const f=Nt(n);r=p[i]=a.call(null,t),f()}}else r=a;n.ce&&n.ce._setProp(i,r)}o[0]&&(s&&!l?r=!1:o[1]&&(r===""||r===nt(i))&&(r=!0))}return r}const Oo=new WeakMap;function Un(e,t,i=!1){const r=i?Oo:t.propsCache,n=r.get(e);if(n)return n;const s=e.props,o={},l=[];let a=!1;if(!q(e)){const f=c=>{a=!0;const[h,m]=Un(c,t,!0);$e(o,h),m&&l.push(...m)};!i&&t.mixins.length&&t.mixins.forEach(f),e.extends&&f(e.extends),e.mixins&&e.mixins.forEach(f)}if(!s&&!a)return te(e)&&r.set(e,at),at;if(k(s))for(let f=0;f<s.length;f++){const c=je(s[f]);wr(c)&&(o[c]=J)}else if(s)for(const f in s){const c=je(f);if(wr(c)){const h=s[f],m=o[c]=k(h)||q(h)?{type:h}:$e({},h),d=m.type;let g=!1,F=!0;if(k(d))for(let _=0;_<d.length;++_){const D=d[_],W=q(D)&&D.name;if(W==="Boolean"){g=!0;break}else W==="String"&&(F=!1)}else g=q(d)&&d.name==="Boolean";m[0]=g,m[1]=F,(g||B(m,"default"))&&l.push(c)}}const p=[o,l];return te(e)&&r.set(e,p),p}function wr(e){return e[0]!=="$"&&!_t(e)}const nr=e=>e[0]==="_"||e==="$stable",sr=e=>k(e)?e.map(De):[De(e)],Io=(e,t,i)=>{if(t._n)return t;const r=to((...n)=>sr(t(...n)),i);return r._c=!1,r},Vn=(e,t,i)=>{const r=e._ctx;for(const n in e){if(nr(n))continue;const s=e[n];if(q(s))t[n]=Io(n,s,r);else if(s!=null){const o=sr(s);t[n]=()=>o}}},Mn=(e,t)=>{const i=sr(t);e.slots.default=()=>i},Bn=(e,t,i)=>{for(const r in t)(i||!nr(r))&&(e[r]=t[r])},Co=(e,t,i)=>{const r=e.slots=kn();if(e.vnode.shapeFlag&32){const n=t.__;n&&Ei(r,"__",n,!0);const s=t._;s?(Bn(r,t,i),i&&Ei(r,"_",s,!0)):Vn(t,r)}else t&&Mn(e,t)},Ao=(e,t,i)=>{const{vnode:r,slots:n}=e;let s=!0,o=J;if(r.shapeFlag&32){const l=t._;l?i&&l===1?s=!1:Bn(n,t,i):(s=!t.$stable,Vn(t,n)),o=t}else t&&(Mn(e,t),o={default:1});if(s)for(const l in n)!nr(l)&&o[l]==null&&delete n[l]},ve=zo;function Do(e){return Po(e)}function Po(e,t){const i=ni();i.__VUE__=!0;const{insert:r,remove:n,patchProp:s,createElement:o,createText:l,createComment:a,setText:p,setElementText:f,parentNode:c,nextSibling:h,setScopeId:m=Ne,insertStaticContent:d}=e,g=($,u,y,b=null,x=null,v=null,I=void 0,T=null,S=!!u.dynamicChildren)=>{if($===u)return;$&&!yt($,u)&&(b=Lt($),Se($,x,v,!0),$=null),u.patchFlag===-2&&(S=!1,u.dynamicChildren=null);const{type:w,ref:R,shapeFlag:A}=u;switch(w){case $i:F($,u,y,b);break;case Ke:_($,u,y,b);break;case Vt:$==null&&D(u,y,b,I);break;case ye:st($,u,y,b,x,v,I,T,S);break;default:A&1?P($,u,y,b,x,v,I,T,S):A&6?Rt($,u,y,b,x,v,I,T,S):(A&64||A&128)&&w.process($,u,y,b,x,v,I,T,S,mt)}R!=null&&x?wt(R,$&&$.ref,v,u||$,!u):R==null&&$&&$.ref!=null&&wt($.ref,null,v,$,!0)},F=($,u,y,b)=>{if($==null)r(u.el=l(u.children),y,b);else{const x=u.el=$.el;u.children!==$.children&&p(x,u.children)}},_=($,u,y,b)=>{$==null?r(u.el=a(u.children||""),y,b):u.el=$.el},D=($,u,y,b)=>{[$.el,$.anchor]=d($.children,u,y,b,$.el,$.anchor)},W=({el:$,anchor:u},y,b)=>{let x;for(;$&&$!==u;)x=h($),r($,y,b),$=x;r(u,y,b)},C=({el:$,anchor:u})=>{let y;for(;$&&$!==u;)y=h($),n($),$=y;n(u)},P=($,u,y,b,x,v,I,T,S)=>{u.type==="svg"?I="svg":u.type==="math"&&(I="mathml"),$==null?U(u,y,b,x,v,I,T,S):ne($,u,x,v,I,T,S)},U=($,u,y,b,x,v,I,T)=>{let S,w;const{props:R,shapeFlag:A,transition:N,dirs:L}=$;if(S=$.el=o($.type,v,R&&R.is,R),A&8?f(S,$.children):A&16&&H($.children,S,null,b,x,_i($,v),I,T),L&&Qe($,null,b,"created"),G(S,$,$.scopeId,I,b),R){for(const K in R)K!=="value"&&!_t(K)&&s(S,K,null,R[K],v,b);"value"in R&&s(S,"value",null,R.value,v),(w=R.onVnodeBeforeMount)&&Ce(w,b,$)}L&&Qe($,null,b,"beforeMount");const V=No(x,N);V&&N.beforeEnter(S),r(S,u,y),((w=R&&R.onVnodeMounted)||V||L)&&ve(()=>{w&&Ce(w,b,$),V&&N.enter(S),L&&Qe($,null,b,"mounted")},x)},G=($,u,y,b,x)=>{if(y&&m($,y),b)for(let v=0;v<b.length;v++)m($,b[v]);if(x){let v=x.subTree;if(u===v||Yn(v.type)&&(v.ssContent===u||v.ssFallback===u)){const I=x.vnode;G($,I,I.scopeId,I.slotScopeIds,x.parent)}}},H=($,u,y,b,x,v,I,T,S=0)=>{for(let w=S;w<$.length;w++){const R=$[w]=T?Be($[w]):De($[w]);g(null,R,u,y,b,x,v,I,T)}},ne=($,u,y,b,x,v,I)=>{const T=u.el=$.el;let{patchFlag:S,dynamicChildren:w,dirs:R}=u;S|=$.patchFlag&16;const A=$.props||J,N=u.props||J;let L;if(y&&et(y,!1),(L=N.onVnodeBeforeUpdate)&&Ce(L,y,u,$),R&&Qe(u,$,y,"beforeUpdate"),y&&et(y,!0),(A.innerHTML&&N.innerHTML==null||A.textContent&&N.textContent==null)&&f(T,""),w?xe($.dynamicChildren,w,T,y,b,_i(u,x),v):I||X($,u,T,null,y,b,_i(u,x),v,!1),S>0){if(S&16)We(T,A,N,y,x);else if(S&2&&A.class!==N.class&&s(T,"class",null,N.class,x),S&4&&s(T,"style",A.style,N.style,x),S&8){const V=u.dynamicProps;for(let K=0;K<V.length;K++){const z=V[K],pe=A[z],me=N[z];(me!==pe||z==="value")&&s(T,z,pe,me,x,y)}}S&1&&$.children!==u.children&&f(T,u.children)}else!I&&w==null&&We(T,A,N,y,x);((L=N.onVnodeUpdated)||R)&&ve(()=>{L&&Ce(L,y,u,$),R&&Qe(u,$,y,"updated")},b)},xe=($,u,y,b,x,v,I)=>{for(let T=0;T<u.length;T++){const S=$[T],w=u[T],R=S.el&&(S.type===ye||!yt(S,w)||S.shapeFlag&198)?c(S.el):y;g(S,w,R,null,b,x,v,I,!0)}},We=($,u,y,b,x)=>{if(u!==y){if(u!==J)for(const v in u)!_t(v)&&!(v in y)&&s($,v,u[v],null,x,b);for(const v in y){if(_t(v))continue;const I=y[v],T=u[v];I!==T&&v!=="value"&&s($,v,T,I,x,b)}"value"in y&&s($,"value",u.value,y.value,x)}},st=($,u,y,b,x,v,I,T,S)=>{const w=u.el=$?$.el:l(""),R=u.anchor=$?$.anchor:l("");let{patchFlag:A,dynamicChildren:N,slotScopeIds:L}=u;L&&(T=T?T.concat(L):L),$==null?(r(w,y,b),r(R,y,b),H(u.children||[],y,R,x,v,I,T,S)):A>0&&A&64&&N&&$.dynamicChildren?(xe($.dynamicChildren,N,y,x,v,I,T),(u.key!=null||x&&u===x.subTree)&&zn($,u,!0)):X($,u,y,R,x,v,I,T,S)},Rt=($,u,y,b,x,v,I,T,S)=>{u.slotScopeIds=T,$==null?u.shapeFlag&512?x.ctx.activate(u,y,b,I,S):ui(u,y,b,x,v,I,S):fr($,u,S)},ui=($,u,y,b,x,v,I)=>{const T=$.component=tl($,b,x);if(An($)&&(T.ctx.renderer=mt),il(T,!1,I),T.asyncDep){if(x&&x.registerDep(T,fe,I),!$.el){const S=T.subTree=Fe(Ke);_(null,S,u,y)}}else fe(T,$,u,y,x,v,I)},fr=($,u,y)=>{const b=u.component=$.component;if(Mo($,u,y))if(b.asyncDep&&!b.asyncResolved){ee(b,u,y);return}else b.next=u,b.update();else u.el=$.el,b.vnode=u},fe=($,u,y,b,x,v,I)=>{const T=()=>{if($.isMounted){let{next:A,bu:N,u:L,parent:V,vnode:K}=$;{const Oe=Hn($);if(Oe){A&&(A.el=K.el,ee($,A,I)),Oe.asyncDep.then(()=>{$.isUnmounted||T()});return}}let z=A,pe;et($,!1),A?(A.el=K.el,ee($,A,I)):A=K,N&&pi(N),(pe=A.props&&A.props.onVnodeBeforeUpdate)&&Ce(pe,V,A,K),et($,!0);const me=Er($),Te=$.subTree;$.subTree=me,g(Te,me,c(Te.el),Lt(Te),$,x,v),A.el=me.el,z===null&&Bo($,me.el),L&&ve(L,x),(pe=A.props&&A.props.onVnodeUpdated)&&ve(()=>Ce(pe,V,A,K),x)}else{let A;const{el:N,props:L}=u,{bm:V,m:K,parent:z,root:pe,type:me}=$,Te=Ft(u);et($,!1),V&&pi(V),!Te&&(A=L&&L.onVnodeBeforeMount)&&Ce(A,z,u),et($,!0);{pe.ce&&pe.ce._def.shadowRoot!==!1&&pe.ce._injectChildStyle(me);const Oe=$.subTree=Er($);g(null,Oe,y,b,$,x,v),u.el=Oe.el}if(K&&ve(K,x),!Te&&(A=L&&L.onVnodeMounted)){const Oe=u;ve(()=>Ce(A,z,Oe),x)}(u.shapeFlag&256||z&&Ft(z.vnode)&&z.vnode.shapeFlag&256)&&$.a&&ve($.a,x),$.isMounted=!0,u=y=b=null}};$.scope.on();const S=$.effect=new ln(T);$.scope.off();const w=$.update=S.run.bind(S),R=$.job=S.runIfDirty.bind(S);R.i=$,R.id=$.uid,S.scheduler=()=>Qi(R),et($,!0),w()},ee=($,u,y)=>{u.component=$;const b=$.vnode.props;$.vnode=u,$.next=null,To($,u.props,b,y),Ao($,u.children,y),Ge(),yr($),Ue()},X=($,u,y,b,x,v,I,T,S=!1)=>{const w=$&&$.children,R=$?$.shapeFlag:0,A=u.children,{patchFlag:N,shapeFlag:L}=u;if(N>0){if(N&128){Wt(w,A,y,b,x,v,I,T,S);return}else if(N&256){Je(w,A,y,b,x,v,I,T,S);return}}L&8?(R&16&&pt(w,x,v),A!==w&&f(y,A)):R&16?L&16?Wt(w,A,y,b,x,v,I,T,S):pt(w,x,v,!0):(R&8&&f(y,""),L&16&&H(A,y,b,x,v,I,T,S))},Je=($,u,y,b,x,v,I,T,S)=>{$=$||at,u=u||at;const w=$.length,R=u.length,A=Math.min(w,R);let N;for(N=0;N<A;N++){const L=u[N]=S?Be(u[N]):De(u[N]);g($[N],L,y,null,x,v,I,T,S)}w>R?pt($,x,v,!0,!1,A):H(u,y,b,x,v,I,T,S,A)},Wt=($,u,y,b,x,v,I,T,S)=>{let w=0;const R=u.length;let A=$.length-1,N=R-1;for(;w<=A&&w<=N;){const L=$[w],V=u[w]=S?Be(u[w]):De(u[w]);if(yt(L,V))g(L,V,y,null,x,v,I,T,S);else break;w++}for(;w<=A&&w<=N;){const L=$[A],V=u[N]=S?Be(u[N]):De(u[N]);if(yt(L,V))g(L,V,y,null,x,v,I,T,S);else break;A--,N--}if(w>A){if(w<=N){const L=N+1,V=L<R?u[L].el:b;for(;w<=N;)g(null,u[w]=S?Be(u[w]):De(u[w]),y,V,x,v,I,T,S),w++}}else if(w>N)for(;w<=A;)Se($[w],x,v,!0),w++;else{const L=w,V=w,K=new Map;for(w=V;w<=N;w++){const _e=u[w]=S?Be(u[w]):De(u[w]);_e.key!=null&&K.set(_e.key,w)}let z,pe=0;const me=N-V+1;let Te=!1,Oe=0;const gt=new Array(me);for(w=0;w<me;w++)gt[w]=0;for(w=L;w<=A;w++){const _e=$[w];if(pe>=me){Se(_e,x,v,!0);continue}let Ie;if(_e.key!=null)Ie=K.get(_e.key);else for(z=V;z<=N;z++)if(gt[z-V]===0&&yt(_e,u[z])){Ie=z;break}Ie===void 0?Se(_e,x,v,!0):(gt[Ie-V]=w+1,Ie>=Oe?Oe=Ie:Te=!0,g(_e,u[Ie],y,null,x,v,I,T,S),pe++)}const cr=Te?Ro(gt):at;for(z=cr.length-1,w=me-1;w>=0;w--){const _e=V+w,Ie=u[_e],pr=_e+1<R?u[_e+1].el:b;gt[w]===0?g(null,Ie,y,pr,x,v,I,T,S):Te&&(z<0||w!==cr[z]?Ze(Ie,y,pr,2):z--)}}},Ze=($,u,y,b,x=null)=>{const{el:v,type:I,transition:T,children:S,shapeFlag:w}=$;if(w&6){Ze($.component.subTree,u,y,b);return}if(w&128){$.suspense.move(u,y,b);return}if(w&64){I.move($,u,y,mt);return}if(I===ye){r(v,u,y);for(let A=0;A<S.length;A++)Ze(S[A],u,y,b);r($.anchor,u,y);return}if(I===Vt){W($,u,y);return}if(b!==2&&w&1&&T)if(b===0)T.beforeEnter(v),r(v,u,y),ve(()=>T.enter(v),x);else{const{leave:A,delayLeave:N,afterLeave:L}=T,V=()=>{$.ctx.isUnmounted?n(v):r(v,u,y)},K=()=>{A(v,()=>{V(),L&&L()})};N?N(v,V,K):K()}else r(v,u,y)},Se=($,u,y,b=!1,x=!1)=>{const{type:v,props:I,ref:T,children:S,dynamicChildren:w,shapeFlag:R,patchFlag:A,dirs:N,cacheIndex:L}=$;if(A===-2&&(x=!1),T!=null&&(Ge(),wt(T,null,y,$,!0),Ue()),L!=null&&(u.renderCache[L]=void 0),R&256){u.ctx.deactivate($);return}const V=R&1&&N,K=!Ft($);let z;if(K&&(z=I&&I.onVnodeBeforeUnmount)&&Ce(z,u,$),R&6)fs($.component,y,b);else{if(R&128){$.suspense.unmount(y,b);return}V&&Qe($,null,u,"beforeUnmount"),R&64?$.type.remove($,u,y,mt,b):w&&!w.hasOnce&&(v!==ye||A>0&&A&64)?pt(w,u,y,!1,!0):(v===ye&&A&384||!x&&R&16)&&pt(S,u,y),b&&ur($)}(K&&(z=I&&I.onVnodeUnmounted)||V)&&ve(()=>{z&&Ce(z,u,$),V&&Qe($,null,u,"unmounted")},y)},ur=$=>{const{type:u,el:y,anchor:b,transition:x}=$;if(u===ye){$s(y,b);return}if(u===Vt){C($);return}const v=()=>{n(y),x&&!x.persisted&&x.afterLeave&&x.afterLeave()};if($.shapeFlag&1&&x&&!x.persisted){const{leave:I,delayLeave:T}=x,S=()=>I(y,v);T?T($.el,v,S):S()}else v()},$s=($,u)=>{let y;for(;$!==u;)y=h($),n($),$=y;n(u)},fs=($,u,y)=>{const{bum:b,scope:x,job:v,subTree:I,um:T,m:S,a:w,parent:R,slots:{__:A}}=$;Fr(S),Fr(w),b&&pi(b),R&&k(A)&&A.forEach(N=>{R.renderCache[N]=void 0}),x.stop(),v&&(v.flags|=8,Se(I,$,u,y)),T&&ve(T,u),ve(()=>{$.isUnmounted=!0},u),u&&u.pendingBranch&&!u.isUnmounted&&$.asyncDep&&!$.asyncResolved&&$.suspenseId===u.pendingId&&(u.deps--,u.deps===0&&u.resolve())},pt=($,u,y,b=!1,x=!1,v=0)=>{for(let I=v;I<$.length;I++)Se($[I],u,y,b,x)},Lt=$=>{if($.shapeFlag&6)return Lt($.component.subTree);if($.shapeFlag&128)return $.suspense.next();const u=h($.anchor||$.el),y=u&&u[io];return y?h(y):u};let di=!1;const dr=($,u,y)=>{$==null?u._vnode&&Se(u._vnode,null,null,!0):g(u._vnode||null,$,u,null,null,null,y),u._vnode=$,di||(di=!0,yr(),Tn(),di=!1)},mt={p:g,um:Se,m:Ze,r:ur,mt:ui,mc:H,pc:X,pbc:xe,n:Lt,o:e};return{render:dr,hydrate:void 0,createApp:Fo(dr)}}function _i({type:e,props:t},i){return i==="svg"&&e==="foreignObject"||i==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:i}function et({effect:e,job:t},i){i?(e.flags|=32,t.flags|=4):(e.flags&=-33,t.flags&=-5)}function No(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function zn(e,t,i=!1){const r=e.children,n=t.children;if(k(r)&&k(n))for(let s=0;s<r.length;s++){const o=r[s];let l=n[s];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=n[s]=Be(n[s]),l.el=o.el),!i&&l.patchFlag!==-2&&zn(o,l)),l.type===$i&&(l.el=o.el),l.type===Ke&&!l.el&&(l.el=o.el)}}function Ro(e){const t=e.slice(),i=[0];let r,n,s,o,l;const a=e.length;for(r=0;r<a;r++){const p=e[r];if(p!==0){if(n=i[i.length-1],e[n]<p){t[r]=n,i.push(r);continue}for(s=0,o=i.length-1;s<o;)l=s+o>>1,e[i[l]]<p?s=l+1:o=l;p<e[i[s]]&&(s>0&&(t[r]=i[s-1]),i[s]=r)}}for(s=i.length,o=i[s-1];s-- >0;)i[s]=o,o=t[o];return i}function Hn(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:Hn(t)}function Fr(e){if(e)for(let t=0;t<e.length;t++)e[t].flags|=8}const Wo=Symbol.for("v-scx"),Lo=()=>Ut(Wo);function vi(e,t,i){return jn(e,t,i)}function jn(e,t,i=J){const{immediate:r,deep:n,flush:s,once:o}=i,l=$e({},i),a=t&&r||!t&&s!=="post";let p;if(Dt){if(s==="sync"){const m=Lo();p=m.__watcherHandles||(m.__watcherHandles=[])}else if(!a){const m=()=>{};return m.stop=Ne,m.resume=Ne,m.pause=Ne,m}}const f=ce;l.call=(m,d,g)=>Re(m,f,d,g);let c=!1;s==="post"?l.scheduler=m=>{ve(m,f&&f.suspense)}:s!=="sync"&&(c=!0,l.scheduler=(m,d)=>{d?m():Qi(m)}),l.augmentJob=m=>{t&&(m.flags|=4),c&&(m.flags|=2,f&&(m.id=f.uid,m.i=f))};const h=Js(e,t,l);return Dt&&(p?p.push(h):a&&h()),h}function ko(e,t,i){const r=this.proxy,n=se(e)?e.includes(".")?Xn(r,e):()=>r[e]:e.bind(r,r);let s;q(t)?s=t:(s=t.handler,i=t);const o=Nt(this),l=jn(n,s.bind(r),i);return o(),l}function Xn(e,t){const i=t.split(".");return()=>{let r=e;for(let n=0;n<i.length&&r;n++)r=r[i[n]];return r}}const qo=(e,t)=>t==="modelValue"||t==="model-value"?e.modelModifiers:e[`${t}Modifiers`]||e[`${je(t)}Modifiers`]||e[`${nt(t)}Modifiers`];function Go(e,t,...i){if(e.isUnmounted)return;const r=e.vnode.props||J;let n=i;const s=t.startsWith("update:"),o=s&&qo(r,t.slice(7));o&&(o.trim&&(n=i.map(f=>se(f)?f.trim():f)),o.number&&(n=i.map(gs)));let l,a=r[l=ci(t)]||r[l=ci(je(t))];!a&&s&&(a=r[l=ci(nt(t))]),a&&Re(a,e,6,n);const p=r[l+"Once"];if(p){if(!e.emitted)e.emitted={};else if(e.emitted[l])return;e.emitted[l]=!0,Re(p,e,6,n)}}function Kn(e,t,i=!1){const r=t.emitsCache,n=r.get(e);if(n!==void 0)return n;const s=e.emits;let o={},l=!1;if(!q(e)){const a=p=>{const f=Kn(p,t,!0);f&&(l=!0,$e(o,f))};!i&&t.mixins.length&&t.mixins.forEach(a),e.extends&&a(e.extends),e.mixins&&e.mixins.forEach(a)}return!s&&!l?(te(e)&&r.set(e,null),null):(k(s)?s.forEach(a=>o[a]=null):$e(o,s),te(e)&&r.set(e,o),o)}function ai(e,t){return!e||!ti(t)?!1:(t=t.slice(2).replace(/Once$/,""),B(e,t[0].toLowerCase()+t.slice(1))||B(e,nt(t))||B(e,t))}function Er(e){const{type:t,vnode:i,proxy:r,withProxy:n,propsOptions:[s],slots:o,attrs:l,emit:a,render:p,renderCache:f,props:c,data:h,setupState:m,ctx:d,inheritAttrs:g}=e,F=Yt(e);let _,D;try{if(i.shapeFlag&4){const C=n||r,P=C;_=De(p.call(P,C,f,c,m,h,d)),D=l}else{const C=t;_=De(C.length>1?C(c,{attrs:l,slots:o,emit:a}):C(c,null)),D=t.props?l:Uo(l)}}catch(C){St.length=0,oi(C,e,1),_=Fe(Ke)}let W=_;if(D&&g!==!1){const C=Object.keys(D),{shapeFlag:P}=W;C.length&&P&7&&(s&&C.some(Ui)&&(D=Vo(D,s)),W=ct(W,D,!1,!0))}return i.dirs&&(W=ct(W,null,!1,!0),W.dirs=W.dirs?W.dirs.concat(i.dirs):i.dirs),i.transition&&er(W,i.transition),_=W,Yt(F),_}const Uo=e=>{let t;for(const i in e)(i==="class"||i==="style"||ti(i))&&((t||(t={}))[i]=e[i]);return t},Vo=(e,t)=>{const i={};for(const r in e)(!Ui(r)||!(r.slice(9)in t))&&(i[r]=e[r]);return i};function Mo(e,t,i){const{props:r,children:n,component:s}=e,{props:o,children:l,patchFlag:a}=t,p=s.emitsOptions;if(t.dirs||t.transition)return!0;if(i&&a>=0){if(a&1024)return!0;if(a&16)return r?Sr(r,o,p):!!o;if(a&8){const f=t.dynamicProps;for(let c=0;c<f.length;c++){const h=f[c];if(o[h]!==r[h]&&!ai(p,h))return!0}}}else return(n||l)&&(!l||!l.$stable)?!0:r===o?!1:r?o?Sr(r,o,p):!0:!!o;return!1}function Sr(e,t,i){const r=Object.keys(t);if(r.length!==Object.keys(e).length)return!0;for(let n=0;n<r.length;n++){const s=r[n];if(t[s]!==e[s]&&!ai(i,s))return!0}return!1}function Bo({vnode:e,parent:t},i){for(;t;){const r=t.subTree;if(r.suspense&&r.suspense.activeBranch===e&&(r.el=e.el),r===e)(e=t.vnode).el=i,t=t.parent;else break}}const Yn=e=>e.__isSuspense;function zo(e,t){t&&t.pendingBranch?k(e)?t.effects.push(...e):t.effects.push(e):eo(e)}const ye=Symbol.for("v-fgt"),$i=Symbol.for("v-txt"),Ke=Symbol.for("v-cmt"),Vt=Symbol.for("v-stc"),St=[];let be=null;function Z(e=!1){St.push(be=e?null:[])}function Ho(){St.pop(),be=St[St.length-1]||null}let At=1;function Tr(e,t=!1){At+=e,e<0&&be&&t&&(be.hasOnce=!0)}function Jn(e){return e.dynamicChildren=At>0?be||at:null,Ho(),At>0&&be&&be.push(e),e}function Q(e,t,i,r,n,s){return Jn(O(e,t,i,r,n,s,!0))}function jo(e,t,i,r,n){return Jn(Fe(e,t,i,r,n,!0))}function Zn(e){return e?e.__v_isVNode===!0:!1}function yt(e,t){return e.type===t.type&&e.key===t.key}const Qn=({key:e})=>e??null,Mt=({ref:e,ref_key:t,ref_for:i})=>(typeof e=="number"&&(e=""+e),e!=null?se(e)||ae(e)||q(e)?{i:Pe,r:e,k:t,f:!!i}:e:null);function O(e,t=null,i=null,r=0,n=null,s=e===ye?0:1,o=!1,l=!1){const a={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&Qn(t),ref:t&&Mt(t),scopeId:In,slotScopeIds:null,children:i,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:s,patchFlag:r,dynamicProps:n,dynamicChildren:null,appContext:null,ctx:Pe};return l?(or(a,i),s&128&&e.normalize(a)):i&&(a.shapeFlag|=se(i)?8:16),At>0&&!o&&be&&(a.patchFlag>0||s&6)&&a.patchFlag!==32&&be.push(a),a}const Fe=Xo;function Xo(e,t=null,i=null,r=0,n=null,s=!1){if((!e||e===go)&&(e=Ke),Zn(e)){const l=ct(e,t,!0);return i&&or(l,i),At>0&&!s&&be&&(l.shapeFlag&6?be[be.indexOf(e)]=l:be.push(l)),l.patchFlag=-2,l}if(ol(e)&&(e=e.__vccOpts),t){t=Ko(t);let{class:l,style:a}=t;l&&!se(l)&&(t.class=he(l)),te(a)&&(Zi(a)&&!k(a)&&(a=$e({},a)),t.style=Bi(a))}const o=se(e)?1:Yn(e)?128:ro(e)?64:te(e)?4:q(e)?2:0;return O(e,t,i,r,n,o,s,!0)}function Ko(e){return e?Zi(e)||qn(e)?$e({},e):e:null}function ct(e,t,i=!1,r=!1){const{props:n,ref:s,patchFlag:o,children:l,transition:a}=e,p=t?Zo(n||{},t):n,f={__v_isVNode:!0,__v_skip:!0,type:e.type,props:p,key:p&&Qn(p),ref:t&&t.ref?i&&s?k(s)?s.concat(Mt(t)):[s,Mt(t)]:Mt(t):s,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:l,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==ye?o===-1?16:o|16:o,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:a,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&ct(e.ssContent),ssFallback:e.ssFallback&&ct(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return a&&r&&er(f,a.clone(f)),f}function Yo(e=" ",t=0){return Fe($i,null,e,t)}function Jo(e,t){const i=Fe(Vt,null,e);return i.staticCount=t,i}function it(e="",t=!1){return t?(Z(),jo(Ke,null,e)):Fe(Ke,null,e)}function De(e){return e==null||typeof e=="boolean"?Fe(Ke):k(e)?Fe(ye,null,e.slice()):Zn(e)?Be(e):Fe($i,null,String(e))}function Be(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:ct(e)}function or(e,t){let i=0;const{shapeFlag:r}=e;if(t==null)t=null;else if(k(t))i=16;else if(typeof t=="object")if(r&65){const n=t.default;n&&(n._c&&(n._d=!1),or(e,n()),n._c&&(n._d=!0));return}else{i=32;const n=t._;!n&&!qn(t)?t._ctx=Pe:n===3&&Pe&&(Pe.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else q(t)?(t={default:t,_ctx:Pe},i=32):(t=String(t),r&64?(i=16,t=[Yo(t)]):i=8);e.children=t,e.shapeFlag|=i}function Zo(...e){const t={};for(let i=0;i<e.length;i++){const r=e[i];for(const n in r)if(n==="class")t.class!==r.class&&(t.class=he([t.class,r.class]));else if(n==="style")t.style=Bi([t.style,r.style]);else if(ti(n)){const s=t[n],o=r[n];o&&s!==o&&!(k(s)&&s.includes(o))&&(t[n]=s?[].concat(s,o):o)}else n!==""&&(t[n]=r[n])}return t}function Ce(e,t,i,r=null){Re(e,t,7,[i,r])}const Qo=Wn();let el=0;function tl(e,t,i){const r=e.type,n=(t?t.appContext:e.appContext)||Qo,s={uid:el++,vnode:e,type:r,parent:t,appContext:n,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new on(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(n.provides),ids:t?t.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Un(r,n),emitsOptions:Kn(r,n),emit:null,emitted:null,propsDefaults:J,inheritAttrs:r.inheritAttrs,ctx:J,data:J,props:J,attrs:J,slots:J,refs:J,setupState:J,setupContext:null,suspense:i,suspenseId:i?i.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return s.ctx={_:s},s.root=t?t.root:s,s.emit=Go.bind(null,s),e.ce&&e.ce(s),s}let ce=null,Zt,Ni;{const e=ni(),t=(i,r)=>{let n;return(n=e[i])||(n=e[i]=[]),n.push(r),s=>{n.length>1?n.forEach(o=>o(s)):n[0](s)}};Zt=t("__VUE_INSTANCE_SETTERS__",i=>ce=i),Ni=t("__VUE_SSR_SETTERS__",i=>Dt=i)}const Nt=e=>{const t=ce;return Zt(e),e.scope.on(),()=>{e.scope.off(),Zt(t)}},Or=()=>{ce&&ce.scope.off(),Zt(null)};function es(e){return e.vnode.shapeFlag&4}let Dt=!1;function il(e,t=!1,i=!1){t&&Ni(t);const{props:r,children:n}=e.vnode,s=es(e);So(e,r,s,t),Co(e,n,i||t);const o=s?rl(e,t):void 0;return t&&Ni(!1),o}function rl(e,t){const i=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,ho);const{setup:r}=i;if(r){Ge();const n=e.setupContext=r.length>1?sl(e):null,s=Nt(e),o=Pt(r,e,0,[e.props,n]),l=Zr(o);if(Ue(),s(),(l||e.sp)&&!Ft(e)&&Cn(e),l){if(o.then(Or,Or),t)return o.then(a=>{Ir(e,a)}).catch(a=>{oi(a,e,0)});e.asyncDep=o}else Ir(e,o)}else ts(e)}function Ir(e,t,i){q(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:te(t)&&(e.setupState=wn(t)),ts(e)}function ts(e,t,i){const r=e.type;e.render||(e.render=r.render||Ne);{const n=Nt(e);Ge();try{yo(e)}finally{Ue(),n()}}}const nl={get(e,t){return le(e,"get",""),e[t]}};function sl(e){const t=i=>{e.exposed=i||{}};return{attrs:new Proxy(e.attrs,nl),slots:e.slots,emit:e.emit,expose:t}}function lr(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(wn(bn(e.exposed)),{get(t,i){if(i in t)return t[i];if(i in Et)return Et[i](e)},has(t,i){return i in t||i in Et}})):e.proxy}function ol(e){return q(e)&&"__vccOpts"in e}const ll=(e,t)=>Ks(e,t,Dt),al="3.5.17";/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Ri;const Cr=typeof window<"u"&&window.trustedTypes;if(Cr)try{Ri=Cr.createPolicy("vue",{createHTML:e=>e})}catch{}const is=Ri?e=>Ri.createHTML(e):e=>e,$l="http://www.w3.org/2000/svg",fl="http://www.w3.org/1998/Math/MathML",ke=typeof document<"u"?document:null,Ar=ke&&ke.createElement("template"),ul={insert:(e,t,i)=>{t.insertBefore(e,i||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,i,r)=>{const n=t==="svg"?ke.createElementNS($l,e):t==="mathml"?ke.createElementNS(fl,e):i?ke.createElement(e,{is:i}):ke.createElement(e);return e==="select"&&r&&r.multiple!=null&&n.setAttribute("multiple",r.multiple),n},createText:e=>ke.createTextNode(e),createComment:e=>ke.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>ke.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,i,r,n,s){const o=i?i.previousSibling:t.lastChild;if(n&&(n===s||n.nextSibling))for(;t.insertBefore(n.cloneNode(!0),i),!(n===s||!(n=n.nextSibling)););else{Ar.innerHTML=is(r==="svg"?`<svg>${e}</svg>`:r==="mathml"?`<math>${e}</math>`:e);const l=Ar.content;if(r==="svg"||r==="mathml"){const a=l.firstChild;for(;a.firstChild;)l.appendChild(a.firstChild);l.removeChild(a)}t.insertBefore(l,i)}return[o?o.nextSibling:t.firstChild,i?i.previousSibling:t.lastChild]}},dl=Symbol("_vtc");function cl(e,t,i){const r=e[dl];r&&(t=(t?[t,...r]:[...r]).join(" ")),t==null?e.removeAttribute("class"):i?e.setAttribute("class",t):e.className=t}const Dr=Symbol("_vod"),pl=Symbol("_vsh"),ml=Symbol(""),gl=/(^|;)\s*display\s*:/;function hl(e,t,i){const r=e.style,n=se(i);let s=!1;if(i&&!n){if(t)if(se(t))for(const o of t.split(";")){const l=o.slice(0,o.indexOf(":")).trim();i[l]==null&&Bt(r,l,"")}else for(const o in t)i[o]==null&&Bt(r,o,"");for(const o in i)o==="display"&&(s=!0),Bt(r,o,i[o])}else if(n){if(t!==i){const o=r[ml];o&&(i+=";"+o),r.cssText=i,s=gl.test(i)}}else t&&e.removeAttribute("style");Dr in e&&(e[Dr]=s?r.display:"",e[pl]&&(r.display="none"))}const Pr=/\s*!important$/;function Bt(e,t,i){if(k(i))i.forEach(r=>Bt(e,t,r));else if(i==null&&(i=""),t.startsWith("--"))e.setProperty(t,i);else{const r=yl(e,t);Pr.test(i)?e.setProperty(nt(r),i.replace(Pr,""),"important"):e[r]=i}}const Nr=["Webkit","Moz","ms"],bi={};function yl(e,t){const i=bi[t];if(i)return i;let r=je(t);if(r!=="filter"&&r in e)return bi[t]=r;r=tn(r);for(let n=0;n<Nr.length;n++){const s=Nr[n]+r;if(s in e)return bi[t]=s}return t}const Rr="http://www.w3.org/1999/xlink";function Wr(e,t,i,r,n,s=bs(t)){r&&t.startsWith("xlink:")?i==null?e.removeAttributeNS(Rr,t.slice(6,t.length)):e.setAttributeNS(Rr,t,i):i==null||s&&!rn(i)?e.removeAttribute(t):e.setAttribute(t,s?"":Ye(i)?String(i):i)}function Lr(e,t,i,r,n){if(t==="innerHTML"||t==="textContent"){i!=null&&(e[t]=t==="innerHTML"?is(i):i);return}const s=e.tagName;if(t==="value"&&s!=="PROGRESS"&&!s.includes("-")){const l=s==="OPTION"?e.getAttribute("value")||"":e.value,a=i==null?e.type==="checkbox"?"on":"":String(i);(l!==a||!("_value"in e))&&(e.value=a),i==null&&e.removeAttribute(t),e._value=i;return}let o=!1;if(i===""||i==null){const l=typeof e[t];l==="boolean"?i=rn(i):i==null&&l==="string"?(i="",o=!0):l==="number"&&(i=0,o=!0)}try{e[t]=i}catch{}o&&e.removeAttribute(n||t)}function xl(e,t,i,r){e.addEventListener(t,i,r)}function _l(e,t,i,r){e.removeEventListener(t,i,r)}const kr=Symbol("_vei");function vl(e,t,i,r,n=null){const s=e[kr]||(e[kr]={}),o=s[t];if(r&&o)o.value=r;else{const[l,a]=bl(t);if(r){const p=s[t]=El(r,n);xl(e,l,p,a)}else o&&(_l(e,l,o,a),s[t]=void 0)}}const qr=/(?:Once|Passive|Capture)$/;function bl(e){let t;if(qr.test(e)){t={};let r;for(;r=e.match(qr);)e=e.slice(0,e.length-r[0].length),t[r[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):nt(e.slice(2)),t]}let wi=0;const wl=Promise.resolve(),Fl=()=>wi||(wl.then(()=>wi=0),wi=Date.now());function El(e,t){const i=r=>{if(!r._vts)r._vts=Date.now();else if(r._vts<=i.attached)return;Re(Sl(r,i.value),t,5,[r])};return i.value=e,i.attached=Fl(),i}function Sl(e,t){if(k(t)){const i=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{i.call(e),e._stopped=!0},t.map(r=>n=>!n._stopped&&r&&r(n))}else return t}const Gr=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,Tl=(e,t,i,r,n,s)=>{const o=n==="svg";t==="class"?cl(e,r,o):t==="style"?hl(e,i,r):ti(t)?Ui(t)||vl(e,t,i,r,s):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):Ol(e,t,r,o))?(Lr(e,t,r),!e.tagName.includes("-")&&(t==="value"||t==="checked"||t==="selected")&&Wr(e,t,r,o,s,t!=="value")):e._isVueCE&&(/[A-Z]/.test(t)||!se(r))?Lr(e,je(t),r,s,t):(t==="true-value"?e._trueValue=r:t==="false-value"&&(e._falseValue=r),Wr(e,t,r,o))};function Ol(e,t,i,r){if(r)return!!(t==="innerHTML"||t==="textContent"||t in e&&Gr(t)&&q(i));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="autocorrect"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const n=e.tagName;if(n==="IMG"||n==="VIDEO"||n==="CANVAS"||n==="SOURCE")return!1}return Gr(t)&&se(i)?!1:t in e}const Il=["ctrl","shift","alt","meta"],Cl={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,t)=>Il.some(i=>e[`${i}Key`]&&!t.includes(i))},Al=(e,t)=>{const i=e._withMods||(e._withMods={}),r=t.join(".");return i[r]||(i[r]=(n,...s)=>{for(let o=0;o<t.length;o++){const l=Cl[t[o]];if(l&&l(n,t))return}return e(n,...s)})},Dl=$e({patchProp:Tl},ul);let Ur;function Pl(){return Ur||(Ur=Do(Dl))}const Nl=(...e)=>{const t=Pl().createApp(...e),{mount:i}=t;return t.mount=r=>{const n=Wl(r);if(!n)return;const s=t._component;!q(s)&&!s.render&&!s.template&&(s.template=n.innerHTML),n.nodeType===1&&(n.textContent="");const o=i(n,!1,Rl(n));return n instanceof Element&&(n.removeAttribute("v-cloak"),n.setAttribute("data-v-app","")),o},t};function Rl(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function Wl(e){return se(e)?document.querySelector(e):e}/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */const Ll=Symbol();var Vr;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(Vr||(Vr={}));function kl(){const e=ws(!0),t=e.run(()=>jt({}));let i=[],r=[];const n=bn({install(s){n._a=s,s.provide(Ll,n),s.config.globalProperties.$pinia=n,r.forEach(o=>i.push(o)),r=[]},use(s){return this._a?i.push(s):r.push(s),this},_p:i,_a:null,_e:e,_s:new Map,state:t});return n}const ql={class:"extracted-data-viewer"},Gl={class:"data-section"},Ul={class:"data-grid"},Vl={class:"data-item"},Ml={class:"data-item"},Bl={class:"data-item"},zl={class:"data-item"},Hl={class:"data-item"},jl={class:"data-section"},Xl={class:"data-grid"},Kl={key:0,class:"data-item"},Yl={class:"label"},Jl={class:"data-section"},Zl={class:"data-grid"},Ql={class:"data-item"},ea={class:"data-item"},ta={class:"data-item"},ia={key:0,class:"data-section"},ra=tr({__name:"ExtractedDataViewer",props:{data:{}},setup(e){const t=e,i={shadow_correction:m=>({Weak:"Low",Normal:"Medium",Strong:"High"})[m]??m,dynamic_range_expansion:m=>{const d=m.split(";")[1]?.trim();return{Auto:"Auto",0:"Off",Enabled:"On"}[d||""]??m},wb_shift_ab:m=>{const d=parseFloat(m);return d===0?"0":d<0?`A${-d}`:`B${d}`},wb_shift_gm:m=>{const d=parseFloat(m);return d===0?"0":d<0?`M${-d}`:`G${d}`},image_control:m=>({"Bleach Bypass 2":"Bleach Bypass","Cross Processing 2":"Cross Processing"})[m]??m},r={toning:m=>({0:"--",1:"S",2:"R",3:"G",4:"B",5:"P"})[m]??String(m),filter_effect:m=>m>0?"ON":"--",filter_effect_red:m=>m>0?`R+${m}%`:"--",filter_effect_green:m=>m>0?`G+${m}%`:"--",filter_effect_blue:m=>m>0?`B-${m}%`:"--",hdr_toning:m=>({0:"--",1:"BW",2:"S"})[m]??String(m),color_tone:m=>({1:"B",2:"M",3:"Y"})[m]??String(m),bleach_bypass_toning:m=>({0:"--",1:"C",2:"W"})[m]??String(m)},n={saturation:!1,hue:!1,grain_effect:!0,filter_effect:!0,filter_effect_red:!0,filter_effect_green:!0,filter_effect_blue:!0,toning:!0},s={default:{saturation:!0,hue:!0,high_low_key:!0,contrast:!0,contrast_highlight:!0,contrast_shadow:!0,sharpness:!0,shading:!0,clarity:!0,grain_effect:!1,toning:!1,filter_effect:!1,filter_effect_red:!1,filter_effect_green:!1,filter_effect_blue:!1,hdr_tone_level:!1,hdr_toning:!1,color_tone:!1,retro_toning:!1,bleach_bypass_toning:!1},Monotone:{...n},"Soft Monotone":{...n,clarity:!1},"HDR Tone":{hdr_tone_level:!0,hdr_toning:!0,shading:!1},"Cross Processing 2":{color_tone:!0},Retro:{retro_toning:!0},"Bleach Bypass 2":{bleach_bypass_toning:!0}},o=m=>{const d=t.data.props[m];if(i[m])return i[m](d);if(d===void 0)return"N/A";const g=m==="color_temperature"?"K":"";return String(d)+g},l=m=>({saturation:"Saturation",hue:"Hue",high_low_key:"High/Low Key Adjustment",contrast:"Contrast",contrast_highlight:"Contrast (Highlight)",contrast_shadow:"Contrast (Shadow)",sharpness:"Sharpness",shading:"Shading",clarity:"Clarity",grain_effect:"Grain Effect",toning:"Toning",filter_effect:"Filter Effect",filter_effect_red:"Filter Effect Red",filter_effect_green:"Filter Effect Green",filter_effect_blue:"Filter Effect Blue",hdr_tone_level:"HDR Tone Level",hdr_toning:"Toning",color_tone:"Color Tone",retro_toning:"Toning",bleach_bypass_toning:"Toning"})[m],a=m=>{const d=s[t.data.props.image_control]?.[m];return d!==void 0?d:s.default[m]},p=(m,d)=>{if(d===void 0)return"--";const g=r[m];return g!==void 0?g(d):String(d)},f=m=>({image_control:"",white_balance:"Auto",wb_shift_ab:"0",wb_shift_gm:"0",color_temperature:"5200",peripheral_illumination_correction:"",shadow_correction:"",dynamic_range_expansion:""})[m]||"",c=m=>t.data.props[m]===void 0?!1:o(m)!==f(m),h=jt(!1);return ir(()=>{const m=new URLSearchParams(window.location.search);h.value=m.has("debug")}),(m,d)=>(Z(),Q("div",ql,[O("section",Gl,[d[5]||(d[5]=O("h3",null,"Image Settings",-1)),O("div",Ul,[O("div",Vl,[d[0]||(d[0]=O("span",{class:"label"},"Image Control:",-1)),O("span",{class:he(["value",{"value-nonzero":c("image_control")}])},ie(o("image_control")),3)]),O("div",Ml,[d[1]||(d[1]=O("span",{class:"label"},"White Balance:",-1)),O("span",{class:he(["value",{"value-nonzero":c("white_balance")}])},ie(o("white_balance")),3)]),O("div",Bl,[d[2]||(d[2]=O("span",{class:"label"},"WB Shift GM:",-1)),O("span",{class:he(["value",{"value-nonzero":c("wb_shift_gm")}])},ie(o("wb_shift_gm")),3)]),O("div",zl,[d[3]||(d[3]=O("span",{class:"label"},"WB Shift AB:",-1)),O("span",{class:he(["value",{"value-nonzero":c("wb_shift_ab")}])},ie(o("wb_shift_ab")),3)]),O("div",Hl,[d[4]||(d[4]=O("span",{class:"label"},"Color Temperature:",-1)),O("span",{class:he(["value",{"value-nonzero":c("color_temperature")}])},ie(o("color_temperature")),3)])])]),O("section",jl,[d[6]||(d[6]=O("h3",null,"Image Control Settings",-1)),O("div",Xl,[(Z(!0),Q(ye,null,Pn(m.data.props.image_control_settings,(g,F)=>(Z(),Q(ye,{key:F},[a(F)?(Z(),Q("div",Kl,[O("span",Yl,ie(l(F))+":",1),O("span",{class:he(["value",{"value-nonzero":g!==0}])},ie(p(F,g)),3)])):it("",!0)],64))),128))])]),O("section",Jl,[d[10]||(d[10]=O("h3",null,"Additional Corrections",-1)),O("div",Zl,[O("div",Ql,[d[7]||(d[7]=O("span",{class:"label"},"Peripheral Illumination:",-1)),O("span",{class:he(["value",{"value-nonzero":c("peripheral_illumination_correction")}])},ie(o("peripheral_illumination_correction")),3)]),O("div",ea,[d[8]||(d[8]=O("span",{class:"label"},"D-Range Shadow Correction:",-1)),O("span",{class:he(["value",{"value-nonzero":c("shadow_correction")}])},ie(o("shadow_correction")),3)]),O("div",ta,[d[9]||(d[9]=O("span",{class:"label"},"D-Range Highlight Correction:",-1)),O("span",{class:he(["value",{"value-nonzero":c("dynamic_range_expansion")}])},ie(o("dynamic_range_expansion")),3)])])]),h.value?(Z(),Q("section",ia,[d[11]||(d[11]=O("h3",null,"Debug Data",-1)),O("pre",null,ie(m.data),1)])):it("",!0)]))}}),rs=(e,t)=>{const i=e.__vccOpts||e;for(const[r,n]of t)i[r]=n;return i},na=rs(ra,[["__scopeId","data-v-863b3195"]]),sa="modulepreload",oa=function(e,t){return new URL(e,t).href},Mr={},la=function(t,i,r){let n=Promise.resolve();if(i&&i.length>0){let p=function(f){return Promise.all(f.map(c=>Promise.resolve(c).then(h=>({status:"fulfilled",value:h}),h=>({status:"rejected",reason:h}))))};const o=document.getElementsByTagName("link"),l=document.querySelector("meta[property=csp-nonce]"),a=l?.nonce||l?.getAttribute("nonce");n=p(i.map(f=>{if(f=oa(f,r),f in Mr)return;Mr[f]=!0;const c=f.endsWith(".css"),h=c?'[rel="stylesheet"]':"";if(!!r)for(let g=o.length-1;g>=0;g--){const F=o[g];if(F.href===f&&(!c||F.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${f}"]${h}`))return;const d=document.createElement("link");if(d.rel=c?"stylesheet":sa,c||(d.as="script"),d.crossOrigin="",d.href=f,a&&d.setAttribute("nonce",a),document.head.appendChild(d),c)return new Promise((g,F)=>{d.addEventListener("load",g),d.addEventListener("error",()=>F(new Error(`Unable to preload CSS for ${f}`)))})}))}function s(o){const l=new Event("vite:preloadError",{cancelable:!0});if(l.payload=o,window.dispatchEvent(l),!l.defaultPrevented)throw o}return n.then(o=>{for(const l of o||[])l.status==="rejected"&&s(l.reason);return t().catch(s)})};(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,i)=>(typeof require<"u"?require:t)[i]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});class E{static WASI_ESUCCESS=0;static WASI_ERRNO_BADF=8;static WASI_ENOSYS=52;static WASI_CLOCK_REALTIME=0;static WASI_CLOCK_MONOTONIC=1;static WASI_ERRNO_ISDIR=31;static WASI_ERRNO_INVAL=28;static WASI_ERRNO_NOTDIR=54;static WASI_ERRNO_NOENT=44;static WASI_ERRNO_EXIST=20;static WASI_ERRNO_IO=29;static WASI_FILETYPE_CHARACTER_DEVICE=2;static WASI_FILETYPE_DIRECTORY=3;static WASI_FILETYPE_REGULAR_FILE=4;static IMPORT_FUNCTIONS=["args_get","args_sizes_get","clock_res_get","clock_time_get","environ_get","environ_sizes_get","fd_advise","fd_allocate","fd_close","fd_datasync","fd_fdstat_get","fd_fdstat_set_flags","fd_fdstat_set_rights","fd_filestat_get","fd_filestat_set_size","fd_filestat_set_times","fd_pread","fd_prestat_dir_name","fd_prestat_get","fd_pwrite","fd_read","fd_readdir","fd_renumber","fd_seek","fd_sync","fd_tell","fd_write","path_create_directory","path_filestat_get","path_filestat_set_times","path_link","path_open","path_readlink","path_remove_directory","path_rename","path_symlink","path_unlink_file","poll_oneoff","proc_exit","proc_raise","random_get","sched_yield","sock_accept","sock_recv","sock_send","sock_shutdown"];encoder;decoder;constructor(){this.encoder=new TextEncoder,this.decoder=new TextDecoder}stringArraySize(t){let i=t.length*4,r=t.reduce((n,s)=>n+this.byteLength(s)+1,0);return{pointerArraySize:i,bufferSize:r,totalSize:i+r}}writeStringArray(t,i,r,n){let s=r,o=n;for(let l of i)t.setUint32(s,o,!0),s+=4,o+=this.writeString(t,`${l}\0`,o);return o-n}writeString(t,i,r){let n=this.encoder.encode(i);return new Uint8Array(t.buffer,r,n.length).set(n),n.length}readString(t,i,r){let n=new Uint8Array(t.buffer,i,r);return this.decoder.decode(n)}byteLength(t){return this.encoder.encode(t).length}static iovec_t={size:8,bufferOffset:0,lengthOffset:4};iovViews(t,i,r){let n=[],s=i;for(let o=0;o<r;o++){let l=t.getUint32(s+E.iovec_t.bufferOffset,!0),a=t.getUint32(s+E.iovec_t.lengthOffset,!0);n.push(new Uint8Array(t.buffer,l,a)),s+=E.iovec_t.size}return n}writeFilestat(t,i,r,n=0n,s=0n,o=0n,l=0n){t.setBigUint64(i,0n,!0),t.setBigUint64(i+8,0n,!0),t.setUint8(i+16,r),t.setBigUint64(i+24,1n,!0),t.setBigUint64(i+32,n,!0),t.setBigUint64(i+40,s,!0),t.setBigUint64(i+48,o,!0),t.setBigUint64(i+56,l,!0)}writeFdstat(t,i,r,n,s,o){t.setUint8(i,r),t.setUint16(i+2,n,!0),t.setBigUint64(i+8,s,!0),t.setBigUint64(i+16,o,!0)}}let Tt=class{code;constructor(t){this.code=t}get exitCode(){return this.code}};function aa(e,t,i){let r=e.args||[];return{args_get:(n,s)=>{let o=i();return t.writeStringArray(o,r,n,s),E.WASI_ESUCCESS},args_sizes_get:(n,s)=>{let o=i();o.setUint32(n,r.length,!0);let l=t.stringArraySize(r);return o.setUint32(s,l.bufferSize,!0),E.WASI_ESUCCESS}}}function $a(e,t,i){return{clock_res_get:(r,n)=>{let s;switch(r){case E.WASI_CLOCK_MONOTONIC:{s=5e3;break}case E.WASI_CLOCK_REALTIME:{s=1e3;break}default:return E.WASI_ENOSYS}return i().setUint32(n,s,!0),E.WASI_ESUCCESS},clock_time_get:(r,n,s)=>{let o=0;switch(r){case E.WASI_CLOCK_MONOTONIC:{o=performance.now();break}case E.WASI_CLOCK_REALTIME:{o=Date.now();break}default:return E.WASI_ENOSYS}let l=i();if(BigInt){let a=BigInt((p=>{let f=Math.trunc(p),c=BigInt(Math.round((p-f)*1e6));return BigInt(f)*BigInt(1e6)+c})(o));l.setBigUint64(s,a,!0)}else{let a=Date.now()*1e6;l.setUint32(s,a&65535,!0),l.setUint32(s+4,a&4294901760,!0)}return E.WASI_ESUCCESS}}}function fa(e,t,i){return{environ_get:(r,n)=>{let s=r,o=n,l=i();for(let a in e.env){let p=e.env[a];l.setUint32(s,o,!0),s+=4,o+=t.writeString(l,`${a}=${p}\0`,o)}return E.WASI_ESUCCESS},environ_sizes_get:(r,n)=>{let s=i();return s.setUint32(r,Object.keys(e.env||{}).length,!0),s.setUint32(n,Object.entries(e.env||{}).reduce((o,[l,a])=>o+t.byteLength(l)+1+t.byteLength(a)+1,0),!0),E.WASI_ESUCCESS}}}let Br=class{handler;outputBuffers;decoder=new TextDecoder("utf-8");constructor(t,i){this.handler=t,this.outputBuffers=i}writev(t){let i=t.reduce((s,o)=>s+o.byteLength,0),r=0,n=new Uint8Array(i);for(let s of t)n.set(s,r),r+=s.byteLength;if(this.outputBuffers)this.handler(n);else{let s=this.decoder.decode(n);this.handler(s)}return n.length}readv(t){return 0}close(){}};class ua{consume;encoder=new TextEncoder;pending=null;constructor(t){this.consume=t}writev(t){return 0}consumePending(t,i){if(t.byteLength<i)return this.pending=null,t;let r=t.slice(0,i);return this.pending=t.slice(i),r}readv(t){let i=0;for(let r of t){let n=r.byteLength;if(this.pending){let s=this.consumePending(this.pending,n);r.set(s,0),n-=s.byteLength,i+=s.byteLength}for(;n>0;){let s=this.consume(),o;if(s instanceof Uint8Array?o=s:o=this.encoder.encode(s),o.length===0)return i;o.length>n?(r.set(o.slice(0,n),r.byteLength-n),this.pending=o.slice(n),i+=n,n=0):(r.set(o,r.byteLength-n),i+=o.length,n-=o.length)}}return i}close(){}}function da(e={}){let t=e.outputBuffers||!1;return[new ua(e.stdin||(()=>"")),new Br(e.stdout||console.log,t),new Br(e.stderr||console.error,t)]}class ar{root;preopenPaths=[];constructor(t){if(this.root={type:"dir",entries:{}},this.ensureDir("/dev"),this.setNode("/dev/null",{type:"character",kind:"devnull"}),t)for(let i of Object.keys(t))this.ensureDir(i),this.preopenPaths.push(i);else this.preopenPaths.push("/")}removeFile(t){let i=this.normalizePath(t).split("/").filter(o=>o.length>0),r=i.pop(),n=`/${i.join("/")}`,s=this.ensureDir(n);r&&delete s.entries[r]}addFile(t,i){if(typeof i=="string"){let r=new TextEncoder().encode(i);this.createFile(t,r);return}this.createFile(t,i)}createFile(t,i){let r={type:"file",content:i};return this.setNode(t,r),r}setNode(t,i){let r=this.normalizePath(t).split("/").filter(l=>l.length>0);if(r.length===0){if(i.type!=="dir")throw Error("Root must be a directory");this.root=i;return}let n=r.pop(),s=`/${r.join("/")}`,o=this.ensureDir(s);n&&(o.entries[n]=i)}getDevNull(){let t=this.lookup("/dev/null");if(!t)throw Error("/dev/null not found");return t}getPreopenPaths(){return[...this.preopenPaths]}lookup(t){let i=this.normalizePath(t);if(i==="/")return this.root;let r=i.split("/").filter(s=>s.length>0),n=this.root;for(let s of r)if(n.type!=="dir"||(n=n.entries[s],!n))return null;return n}resolve(t,i){let r=this.normalizePath(i).split("/").filter(s=>s.length>0),n=t;for(let s of r)if(s!=="."){if(s===".."){n=this.root;continue}if(n.type!=="dir"||(n=n.entries[s],!n))return null}return n}ensureDir(t){let i=this.normalizePath(t).split("/").filter(n=>n.length>0),r=this.root;for(let n of i){r.entries[n]||(r.entries[n]={type:"dir",entries:{}});let s=r.entries[n];if(s.type!=="dir")throw Error(`"${n}" is not a directory`);r=s}return r}createFileIn(t,i){let r=this.normalizePath(i).split("/").filter(l=>l.length>0);if(r.length===0)throw Error("Cannot create a file with an empty name");let n=r.pop();if(!n)throw Error("Cannot create a file with an empty name");let s=t;for(let l of r){s.entries[l]||(s.entries[l]={type:"dir",entries:{}});let a=s.entries[l];if(a.type!=="dir")throw Error(`"${l}" is not a directory`);s=a}let o={type:"file",content:new Uint8Array(0)};return s.entries[n]=o,o}normalizePath(t){if(!t)return"/";let i=(t.startsWith("/")?t:`/${t}`).replace(/\/+/g,"/");return i==="/"?i:i.replace(/\/+$/,"")}}function ca(e={}){return(t,i,r)=>{let n=e.withFileSystem||new ar(t.preopens),s={};function o(c){if(c.type==="file"&&c.content instanceof Blob){let h=BigInt(c.content.lastModified??Date.now())*1000000n;return{atim:h,mtim:h,ctim:h}}return{atim:0n,mtim:0n,ctim:0n}}da(e.withStdIo||{}).forEach((c,h)=>{s[h]={node:{type:"character",kind:"stdio",entry:c},position:0,isPreopen:!1,path:`/dev/fd/${h}`,fd:h}});let l=3;for(let c of n.getPreopenPaths()){let h=n.lookup(c);h&&h.type==="dir"&&(s[l]={node:h,position:0,isPreopen:!0,preopenPath:c,path:c,fd:l},l++)}function a(c){for(let h in s){let m=s[h];if(m?.path===c)return m}return null}function p(c){return s[c]||null}function f(c){return c.content instanceof Blob?c.content.size:c.content.byteLength}return{fd_read:async(c,h,m,d)=>{let g=r(),F=i.iovViews(g,h,m),_=p(c);if(!_)return E.WASI_ERRNO_BADF;if(_.node.type==="character"&&_.node.kind==="stdio"){let U=_.node.entry.readv(F);return g.setUint32(d,U,!0),E.WASI_ESUCCESS}if(_.node.type==="dir")return E.WASI_ERRNO_ISDIR;if(_.node.type==="character"&&_.node.kind==="devnull")return g.setUint32(d,0,!0),E.WASI_ESUCCESS;let D=_.node,W=D.content,C=f(D)-_.position,P=0;if(C<=0)return g.setUint32(d,0,!0),E.WASI_ESUCCESS;if(D.content instanceof Blob){let U=D.content;for(let G of F){if(_.position>=U.size)break;let H=Math.min(G.byteLength,U.size-_.position);if(H<=0)break;let ne=await U.slice(_.position,_.position+H).arrayBuffer();G.set(new Uint8Array(ne)),P+=ne.byteLength,_.position+=ne.byteLength}}else if(ArrayBuffer.isView(W))for(let U of F){if(_.position>=W.byteLength)break;let G=Math.min(U.byteLength,W.byteLength-_.position);if(G<=0)break;U.set(W.slice(_.position,_.position+G)),P+=G,_.position+=G}return g.setUint32(d,P,!0),E.WASI_ESUCCESS},fd_write:(c,h,m,d)=>{let g=r(),F=i.iovViews(g,h,m),_=p(c);if(!_)return E.WASI_ERRNO_BADF;let D=0;if(_.node.type==="character"&&_.node.kind==="stdio"){let G=_.node.entry.writev(F);return g.setUint32(d,G,!0),E.WASI_ESUCCESS}if(_.node.type==="dir")return E.WASI_ERRNO_ISDIR;if(_.node.type==="character"&&_.node.kind==="devnull"){let G=F.reduce((H,ne)=>H+ne.byteLength,0);return g.setUint32(d,G,!0),E.WASI_ESUCCESS}if(_.node.content instanceof Blob)return E.WASI_ERRNO_INVAL;let W=_.position,C=F.reduce((G,H)=>G+H.byteLength,0),P=W+C,U;P>f(_.node)?(U=new Uint8Array(P),U.set(_.node.content,0)):U=_.node.content;for(let G of F)U.set(G,W),W+=G.byteLength,D+=G.byteLength;return _.node.content=U,_.position=W,g.setUint32(d,D,!0),E.WASI_ESUCCESS},fd_close:c=>{let h=p(c);return h?h.node.type==="character"&&h.node.kind==="stdio"?(h.node.entry.close(),E.WASI_ESUCCESS):(delete s[c],E.WASI_ESUCCESS):E.WASI_ERRNO_BADF},fd_seek:(c,h,m,d)=>{let g=r(),F=p(c);if(!F)return E.WASI_ERRNO_BADF;if(F.node.type==="dir")return E.WASI_ERRNO_ISDIR;if(F.node.type==="character")return E.WASI_ERRNO_IO;let _=f(F.node),D;switch(m){case 0:D=Number(h);break;case 1:D=F.position+Number(h);break;case 2:D=_+Number(h);break;default:return E.WASI_ERRNO_INVAL}return D<0?E.WASI_ERRNO_INVAL:(F.position=D,g.setBigUint64(d,BigInt(D),!0),E.WASI_ESUCCESS)},fd_tell:(c,h)=>{let m=r(),d=p(c);return d?d.node.type==="dir"||d.node.type==="character"?E.WASI_ERRNO_IO:(m.setBigUint64(h,BigInt(d.position),!0),E.WASI_ESUCCESS):E.WASI_ERRNO_BADF},fd_fdstat_get:(c,h)=>{let m=r(),d=p(c);if(!d)return E.WASI_ERRNO_BADF;let g;switch(d.node.type){case"character":g=E.WASI_FILETYPE_CHARACTER_DEVICE;break;case"dir":g=E.WASI_FILETYPE_DIRECTORY;break;case"file":g=E.WASI_FILETYPE_REGULAR_FILE;break}let F=0x1fffffffn;return i.writeFdstat(m,h,g,0,F,F),E.WASI_ESUCCESS},fd_filestat_get:(c,h)=>{let m=r(),d=p(c);if(!d)return E.WASI_ERRNO_BADF;let g,F=0;switch(d.node.type){case"character":g=E.WASI_FILETYPE_CHARACTER_DEVICE;break;case"dir":g=E.WASI_FILETYPE_DIRECTORY;break;case"file":g=E.WASI_FILETYPE_REGULAR_FILE,F=f(d.node);break}let{atim:_,mtim:D,ctim:W}=o(d.node);return i.writeFilestat(m,h,g,BigInt(F),_,D,W),E.WASI_ESUCCESS},fd_prestat_get:(c,h)=>{let m=r();if(c<3)return E.WASI_ERRNO_BADF;let d=p(c);if(!d||!d.isPreopen)return E.WASI_ERRNO_BADF;m.setUint8(h,0);let g=d.preopenPath||"";return m.setUint32(h+4,g.length,!0),E.WASI_ESUCCESS},fd_prestat_dir_name:(c,h,m)=>{if(c<3)return E.WASI_ERRNO_BADF;let d=p(c);if(!d||!d.isPreopen)return E.WASI_ERRNO_BADF;let g=d.preopenPath||"",F=r(),_=Math.min(g.length,m);for(let D=0;D<_;D++)F.setUint8(h+D,g.charCodeAt(D));return E.WASI_ESUCCESS},fd_open:(c,h,m,d,g,F,_,D)=>{let W=r();if(c<3)return E.WASI_ERRNO_NOTDIR;let C=p(c);if(!C||C.node.type!=="dir")return E.WASI_ERRNO_NOTDIR;let P=i.readString(W,h,m),U=(C.path.endsWith("/")?C.path:`${C.path}/`)+P,G=a(U);if(G)return W.setUint32(D,G.fd,!0),E.WASI_ESUCCESS;let H=n.resolve(C.node,P),ne=1,xe=2,We=4;if(H){if(d&xe)return E.WASI_ERRNO_EXIST;if(d&We){if(H.type!=="file")return E.WASI_ERRNO_INVAL;H.content=new Uint8Array(0)}}else{if(!(d&ne))return E.WASI_ERRNO_NOENT;H=n.createFileIn(C.node,P)}return s[l]={node:H,position:0,isPreopen:!1,path:U,fd:l},W.setUint32(D,l,!0),l++,E.WASI_ESUCCESS},path_open:(c,h,m,d,g,F,_,D,W)=>{let C=r();if(c<3)return E.WASI_ERRNO_NOTDIR;let P=p(c);if(!P||P.node.type!=="dir")return E.WASI_ERRNO_NOTDIR;let U=i.readString(C,m,d),G=(P.path.endsWith("/")?P.path:`${P.path}/`)+U,H=a(G);if(H)return C.setUint32(W,H.fd,!0),E.WASI_ESUCCESS;let ne=n.resolve(P.node,U),xe=1,We=2,st=4;if(ne){if(g&We)return E.WASI_ERRNO_EXIST;if(g&st){if(ne.type!=="file")return E.WASI_ERRNO_INVAL;ne.content=new Uint8Array(0)}}else{if(!(g&xe))return E.WASI_ERRNO_NOENT;ne=n.createFileIn(P.node,U)}return s[l]={node:ne,position:0,isPreopen:!1,path:G,fd:l},C.setUint32(W,l,!0),l++,E.WASI_ESUCCESS},path_filestat_get:(c,h,m,d,g)=>{let F=r(),_=p(c);if(!_)return E.WASI_ERRNO_BADF;if(_.node.type!=="dir")return E.WASI_ERRNO_NOTDIR;let D=i.readString(F,m,d),W=_.path,C=W.endsWith("/")?W+D:`${W}/${D}`,P=n.lookup(C);if(!P)return E.WASI_ERRNO_NOENT;if(P.type==="character"&&P.kind==="stdio")return E.WASI_ERRNO_INVAL;let U,G=0;P.type==="dir"?U=E.WASI_FILETYPE_DIRECTORY:P.type==="character"&&P.kind==="devnull"?U=E.WASI_FILETYPE_CHARACTER_DEVICE:(U=E.WASI_FILETYPE_REGULAR_FILE,G=f(P));let{atim:H,mtim:ne,ctim:xe}=o(P);return i.writeFilestat(F,g,U,BigInt(G),H,ne,xe),E.WASI_ESUCCESS}}}}function pa(e,t,i){return{proc_exit:r=>{throw new Tt(r)},proc_raise:r=>E.WASI_ESUCCESS}}function ma(e,t,i){return{random_get:(r,n)=>{let s=i(),o=new Uint8Array(s.buffer,r,n);return crypto.getRandomValues(o),E.WASI_ESUCCESS}}}class ga{wasiImport;instance=null;isStarted=!1;abi;constructor(t){if(this.wasiImport={},this.abi=new E,t?.features){let i={};for(let r of t.features){let n=r.name||"Unknown feature",s=r(t,this.abi,this.view.bind(this));for(let o in s){if(o in this.wasiImport){let l=i[o]||"Unknown feature";throw Error(`Import conflict: Function '${o}' is already provided by '${l}' and is being redefined by '${n}'`)}i[o]=n}this.wasiImport={...this.wasiImport,...s}}}for(let i of E.IMPORT_FUNCTIONS)i in this.wasiImport||(this.wasiImport[i]=()=>E.WASI_ENOSYS)}get exports(){if(!this.instance)throw Error("wasi.start() or wasi.initialize() has not been called");return this.instance.exports}view(){if(!this.instance)throw Error("wasi.start() or wasi.initialize() has not been called");if(!this.instance.exports.memory)throw Error("instance.exports.memory is undefined");if(!(this.instance.exports.memory instanceof WebAssembly.Memory))throw Error("instance.exports.memory is not a WebAssembly.Memory");return new DataView(this.instance.exports.memory.buffer)}async initialize(t){if(this.isStarted)throw Error("wasi.start() or wasi.initialize() has already been called");if(this.isStarted=!0,this.instance=t,!this.instance.exports._initialize)throw Error("instance.exports._initialize is undefined");if(typeof this.instance.exports._initialize!="function")throw Error("instance.exports._initialize is not a function");await this.instance.exports._initialize()}async start(t){if(this.isStarted)throw Error("wasi.start() or wasi.initialize() has already been called");if(this.isStarted=!0,this.instance=t,!this.instance.exports._start)throw Error("instance.exports._start is undefined");if(typeof this.instance.exports._start!="function")throw Error("instance.exports._start is not a function");try{return await this.instance.exports._start(),E.WASI_ESUCCESS}catch(i){if(i instanceof Tt)return i.code;throw i}}}var zt=new WeakMap,ha=new Set(["free","malloc"]);function ya(e){return!!e&&(typeof e=="object"||typeof e=="function")&&typeof e.then=="function"}function zr(e,t){return new Proxy(e,{get:(i,r)=>t(i[r])})}class ns{value=void 0;exports=null;unwrappedExports;constructor(t){this.unwrappedExports=new Set([...ha,...t?.unwrappedExports??[]])}getState(){if(!this.exports)throw Error("Exports not initialized");return this.exports.asyncify_get_state()}assertNoneState(){let t=this.getState();if(t!==0)throw Error(`Invalid async state ${t}, expected 0.`)}wrapImportFn(t){return(...i)=>{if(this.getState()===2){if(!this.exports)throw Error("Exports not initialized");return this.exports.asyncify_stop_rewind(),this.value}this.assertNoneState();let r=t(...i);if(!ya(r))return r;if(!this.exports)throw Error("Exports not initialized");this.exports.asyncify_start_unwind(16),this.value=r}}wrapModuleImports(t){return zr(t,i=>typeof i=="function"?this.wrapImportFn(i):i)}wrapImports(t){if(t!==void 0)return zr(t,(i=Object.create(null))=>this.wrapModuleImports(i))}wrapExportFn(t){let i=zt.get(t);return i!==void 0||(i=async(...r)=>{this.assertNoneState();let n=t(...r);for(;this.getState()===1;){if(!this.exports)throw Error("Exports not initialized");this.exports.asyncify_stop_unwind(),this.value=await this.value,this.assertNoneState(),this.exports.asyncify_start_rewind(16),n=t(...r)}return this.assertNoneState(),n},zt.set(t,i)),i}wrapExports(t){let i=Object.create(null);for(let r in t){let n=t[r];typeof n=="function"&&!r.startsWith("asyncify_")&&!this.unwrappedExports.has(r)&&(n=this.wrapExportFn(n)),Object.defineProperty(i,r,{enumerable:!0,value:n})}return zt.set(t,i),i}init(t,i){let r=t.exports,n=r.memory||i?.env&&i.env.memory;if(!n)throw Error("Memory not found in exports or imports.env");let s;r.__stack_pointer?s=r.__stack_pointer.value:s=1024,new Int32Array(n.buffer,16).set([24,s]),this.exports=this.wrapExports(r),Object.setPrototypeOf(t,ss.prototype)}}class ss extends WebAssembly.Instance{constructor(t,i,r){let n=new ns(r);super(t,n.wrapImports(i)),n.init(this,i)}get exports(){return zt.get(super.exports)}}Object.defineProperty(ss.prototype,"exports",{enumerable:!0});async function xa(e,t,i){let r=new ns(i),n=await WebAssembly.instantiate(e,r.wrapImports(t));return r.init(n.instance,t),n}var Hr="./zeroperl.wasm",_a=["zeroperl_free_interpreter","zeroperl_shutdown","zeroperl_last_error","zeroperl_clear_error","zeroperl_is_initialized","zeroperl_can_evaluate","zeroperl_flush","zeroperl_new_int","zeroperl_new_uint","zeroperl_new_double","zeroperl_new_string","zeroperl_new_bool","zeroperl_new_undef","zeroperl_to_int","zeroperl_to_double","zeroperl_to_string","zeroperl_to_bool","zeroperl_is_undef","zeroperl_get_type","zeroperl_incref","zeroperl_decref","zeroperl_value_free","zeroperl_new_array","zeroperl_array_push","zeroperl_array_pop","zeroperl_array_get","zeroperl_array_set","zeroperl_array_length","zeroperl_array_clear","zeroperl_array_to_value","zeroperl_value_to_array","zeroperl_array_free","zeroperl_new_hash","zeroperl_hash_set","zeroperl_hash_get","zeroperl_hash_exists","zeroperl_hash_delete","zeroperl_hash_clear","zeroperl_hash_iter_new","zeroperl_hash_iter_next","zeroperl_hash_iter_free","zeroperl_hash_to_value","zeroperl_value_to_hash","zeroperl_hash_free","zeroperl_new_ref","zeroperl_deref","zeroperl_is_ref","zeroperl_get_var","zeroperl_get_array_var","zeroperl_get_hash_var","zeroperl_set_var","zeroperl_register_function","zeroperl_register_method","zeroperl_result_get","zeroperl_result_free","zeroperl_set_host_error","zeroperl_get_host_error","zeroperl_clear_host_error"];let j=class os extends Error{exitCode;perlError;constructor(t,i,r){super(t),this.name="ZeroPerlError",this.exitCode=i,this.perlError=r,Error.captureStackTrace&&Error.captureStackTrace(this,os)}};var $r=new TextDecoder,Wi=new TextEncoder,Fi=null;function va(){return typeof window<"u"&&typeof document<"u"}async function ba(e){if(Fi){let i=Fi.deref();if(i)return i}let t;if(va())t=await(await(e??fetch)(Hr)).arrayBuffer();else{let i=new URL(Hr,import.meta.url).pathname;if(typeof Deno<"u")t=(await Deno.readFile(i)).buffer;else if(typeof Bun<"u")t=await Bun.file(i).arrayBuffer();else{let{readFile:r}=await la(()=>import("./__vite-browser-external-BIHI7g3E.js"),[],import.meta.url);t=(await r(i)).buffer}}return Fi=new WeakRef(t),t}function wa(e){return["undef","true","false","int","double","string","array","hash","code","ref"][e]||"undef"}function jr(e){return{void:0,scalar:1,list:2}[e]}let re=class Li{ptr;exports;disposed=!1;constructor(t,i){this.ptr=t,this.exports=i}getPtr(){return this.checkDisposed(),this.ptr}toInt(){this.checkDisposed();let t=this.exports.malloc(4);try{if(!this.exports.zeroperl_to_int(this.ptr,t))throw new j("Failed to convert value to int");return new DataView(this.exports.memory.buffer).getInt32(t,!0)}finally{this.exports.free(t)}}toDouble(){this.checkDisposed();let t=this.exports.malloc(8);try{if(!this.exports.zeroperl_to_double(this.ptr,t))throw new j("Failed to convert value to double");return new DataView(this.exports.memory.buffer).getFloat64(t,!0)}finally{this.exports.free(t)}}toString(){this.checkDisposed();let t=this.exports.malloc(4);try{let i=this.exports.zeroperl_to_string(this.ptr,t);if(i===0)return"";let r=new DataView(this.exports.memory.buffer).getUint32(t,!0);return $r.decode(new Uint8Array(this.exports.memory.buffer,i,r))}finally{this.exports.free(t)}}toBoolean(){return this.checkDisposed(),this.exports.zeroperl_to_bool(this.ptr)!==0}isUndef(){return this.checkDisposed(),this.exports.zeroperl_is_undef(this.ptr)!==0}isRef(){return this.checkDisposed(),this.exports.zeroperl_is_ref(this.ptr)!==0}getType(){return this.checkDisposed(),wa(this.exports.zeroperl_get_type(this.ptr))}project(){if(this.checkDisposed(),this.isUndef())return null;switch(this.getType()){case"true":return!0;case"false":return!1;case"int":case"double":return this.toDouble();case"string":return this.toString();default:return this.toString()}}createRef(){this.checkDisposed();let t=this.exports.zeroperl_new_ref(this.ptr);if(t===0)throw new j("Failed to create reference");return new Li(t,this.exports)}deref(){this.checkDisposed();let t=this.exports.zeroperl_deref(this.ptr);if(t===0)throw new j("Failed to dereference value");return new Li(t,this.exports)}incref(){this.checkDisposed(),this.exports.zeroperl_incref(this.ptr)}decref(){this.checkDisposed(),this.exports.zeroperl_decref(this.ptr)}dispose(){this.disposed||(this.exports.zeroperl_value_free(this.ptr),this.disposed=!0)}checkDisposed(){if(this.disposed)throw new j("PerlValue has been disposed")}};class Qt{ptr;exports;perl;disposed=!1;constructor(t,i,r){this.ptr=t,this.exports=i,this.perl=r}getPtr(){return this.checkDisposed(),this.ptr}push(t){this.checkDisposed();let i=this.perl.toPerlValue(t);try{this.exports.zeroperl_array_push(this.ptr,i.getPtr())}finally{t instanceof re||i.dispose()}}pop(){this.checkDisposed();let t=this.exports.zeroperl_array_pop(this.ptr);return t===0?null:new re(t,this.exports)}get(t){this.checkDisposed();let i=this.exports.zeroperl_array_get(this.ptr,t);return i===0?null:new re(i,this.exports)}set(t,i){this.checkDisposed();let r=this.perl.toPerlValue(i);try{if(!this.exports.zeroperl_array_set(this.ptr,t,r.getPtr()))throw new j(`Failed to set array element at index ${t}`)}finally{i instanceof re||r.dispose()}}getLength(){return this.checkDisposed(),this.exports.zeroperl_array_length(this.ptr)}clear(){this.checkDisposed(),this.exports.zeroperl_array_clear(this.ptr)}toValue(){this.checkDisposed();let t=this.exports.zeroperl_array_to_value(this.ptr);if(t===0)throw new j("Failed to convert array to value");return new re(t,this.exports)}project(){this.checkDisposed();let t=this.getLength(),i=[];for(let r=0;r<t;r++){let n=this.get(r);n?(i.push(n.project()),n.dispose()):i.push(null)}return i}static fromValue(t,i){let r=t.exports,n=r.zeroperl_value_to_array(t.getPtr());return n===0?null:new Qt(n,r,i)}*[Symbol.iterator](){let t=this.getLength();for(let i=0;i<t;i++){let r=this.get(i);r&&(yield r)}}dispose(){this.disposed||(this.exports.zeroperl_array_free(this.ptr),this.disposed=!0)}checkDisposed(){if(this.disposed)throw new j("PerlArray has been disposed")}}class ei{ptr;exports;perl;disposed=!1;constructor(t,i,r){this.ptr=t,this.exports=i,this.perl=r}getPtr(){return this.checkDisposed(),this.ptr}set(t,i){this.checkDisposed();let r=this.perl.toPerlValue(i),n=this.writeCString(t);try{if(!this.exports.zeroperl_hash_set(this.ptr,n,r.getPtr()))throw new j(`Failed to set hash key '${t}'`)}finally{this.exports.free(n),!(i instanceof re)&&r.dispose()}}get(t){this.checkDisposed();let i=this.writeCString(t);try{let r=this.exports.zeroperl_hash_get(this.ptr,i);return r===0?null:new re(r,this.exports)}finally{this.exports.free(i)}}has(t){this.checkDisposed();let i=this.writeCString(t);try{return this.exports.zeroperl_hash_exists(this.ptr,i)!==0}finally{this.exports.free(i)}}delete(t){this.checkDisposed();let i=this.writeCString(t);try{return this.exports.zeroperl_hash_delete(this.ptr,i)!==0}finally{this.exports.free(i)}}clear(){this.checkDisposed(),this.exports.zeroperl_hash_clear(this.ptr)}toValue(){this.checkDisposed();let t=this.exports.zeroperl_hash_to_value(this.ptr);if(t===0)throw new j("Failed to convert hash to value");return new re(t,this.exports)}project(){this.checkDisposed();let t={};for(let[i,r]of this.entries())t[i]=r.project(),r.dispose();return t}static fromValue(t,i){let r=t.exports,n=r.zeroperl_value_to_hash(t.getPtr());return n===0?null:new ei(n,r,i)}*entries(){this.checkDisposed();let t=this.exports.zeroperl_hash_iter_new(this.ptr);if(t===0)throw new j("Failed to create hash iterator");let i=this.exports.malloc(4),r=this.exports.malloc(4);try{for(;this.exports.zeroperl_hash_iter_next(t,i,r);){let n=new DataView(this.exports.memory.buffer),s=n.getUint32(i,!0),o=n.getUint32(r,!0);yield[this.readCString(s),new re(o,this.exports)]}}finally{this.exports.free(i),this.exports.free(r),this.exports.zeroperl_hash_iter_free(t)}}*keys(){for(let[t,i]of this.entries())i.dispose(),yield t}*values(){for(let[,t]of this.entries())yield t}dispose(){this.disposed||(this.exports.zeroperl_hash_free(this.ptr),this.disposed=!0)}writeCString(t){let i=Wi.encode(`${t}\0`),r=this.exports.malloc(i.length);return new Uint8Array(this.exports.memory.buffer).set(i,r),r}readCString(t){if(t===0)return"";let i=new Uint8Array(this.exports.memory.buffer),r=0;for(;i[t+r]!==0;)r++;return $r.decode(i.subarray(t,t+r))}checkDisposed(){if(this.disposed)throw new j("PerlHash has been disposed")}}class fi{wasi;isDisposed=!1;hostFunctions=new Map;nextFuncId=1;constructor(t){this.wasi=t}get exports(){return this.wasi.exports}static async create(t={}){let i=await ba(t.fetch),r=t.fileSystem||new ar({"/":""}),n={env:t.env||{},args:["zeroperl"],features:[fa,aa,ma,$a,pa,ca({withFileSystem:r,withStdIo:{stdout:f=>t.stdout?.(f),stderr:f=>t.stderr?.(f)}})]},s=new ga(n),o=new fi(s),l=async(f,c,h)=>o.handleHostCall(f,c,h),{instance:a}=await xa(i,{wasi_snapshot_preview1:s.wasiImport,env:{call_host_function:l}},{unwrappedExports:_a});await s.initialize(a);let p=await o.exports.zeroperl_init();if(p!==0)throw new j("Failed to initialize Perl interpreter",p,o.getLastError());return o}async handleHostCall(t,i,r){let n=this.hostFunctions.get(t);if(!n)return this.setHostError(`Host function ${t} not found`),0;try{let s=[];if(i>0){let a=new DataView(this.exports.memory.buffer);for(let p=0;p<i;p++){let f=a.getUint32(r+p*4,!0);f!==0&&s.push(new re(f,this.exports))}}let o=await n(...s);if(o instanceof re)return o.getPtr();let l=this.exports.zeroperl_new_undef();return l===0?(this.setHostError("Failed to allocate return value"),0):l}catch(s){return this.setHostError(s instanceof Error?s.message:String(s)),0}}setHostError(t){let i=this.writeCString(t);i&&(this.exports.zeroperl_set_host_error(i),this.exports.free(i))}createInt(t){this.checkDisposed();let i=this.exports.zeroperl_new_int(Math.floor(t));if(i===0)throw new j("Failed to create integer value");return new re(i,this.exports)}createUInt(t){this.checkDisposed();let i=this.exports.zeroperl_new_uint(Math.floor(Math.abs(t)));if(i===0)throw new j("Failed to create unsigned integer value");return new re(i,this.exports)}createDouble(t){this.checkDisposed();let i=this.exports.zeroperl_new_double(t);if(i===0)throw new j("Failed to create double value");return new re(i,this.exports)}createString(t){this.checkDisposed();let i=Wi.encode(t),r=this.exports.malloc(i.length);new Uint8Array(this.exports.memory.buffer).set(i,r);try{let n=this.exports.zeroperl_new_string(r,i.length);if(n===0)throw new j("Failed to create string value");return new re(n,this.exports)}finally{this.exports.free(r)}}createBool(t){this.checkDisposed();let i=this.exports.zeroperl_new_bool(t?1:0);if(i===0)throw new j("Failed to create boolean value");return new re(i,this.exports)}createUndef(){this.checkDisposed();let t=this.exports.zeroperl_new_undef();if(t===0)throw new j("Failed to create undef value");return new re(t,this.exports)}createArray(t){this.checkDisposed();let i=this.exports.zeroperl_new_array();if(i===0)throw new j("Failed to create array");let r=new Qt(i,this.exports,this);if(t)for(let n of t)r.push(n);return r}createHash(t){this.checkDisposed();let i=this.exports.zeroperl_new_hash();if(i===0)throw new j("Failed to create hash");let r=new ei(i,this.exports,this);if(t)for(let[n,s]of Object.entries(t))r.set(n,s);return r}toPerlValue(t){if(t instanceof re)return t;if(t==null)return this.createUndef();if(typeof t=="boolean")return this.createBool(t);if(typeof t=="number")return Number.isInteger(t)?this.createInt(t):this.createDouble(t);if(typeof t=="string")return this.createString(t);if(Array.isArray(t)){let i=this.createArray(t),r=i.toValue();return i.dispose(),r}if(typeof t=="object"){let i=this.createHash(t),r=i.toValue();return i.dispose(),r}throw new j(`Cannot convert value of type ${typeof t} to PerlValue`)}getVariable(t){this.checkDisposed();let i=this.writeCString(t);try{let r=this.exports.zeroperl_get_var(i);return r===0?null:new re(r,this.exports)}finally{this.exports.free(i)}}getArrayVariable(t){this.checkDisposed();let i=this.writeCString(t);try{let r=this.exports.zeroperl_get_array_var(i);return r===0?null:new Qt(r,this.exports,this)}finally{this.exports.free(i)}}getHashVariable(t){this.checkDisposed();let i=this.writeCString(t);try{let r=this.exports.zeroperl_get_hash_var(i);return r===0?null:new ei(r,this.exports,this)}finally{this.exports.free(i)}}setVariable(t,i){this.checkDisposed();let r=this.toPerlValue(i),n=this.writeCString(t);try{if(!this.exports.zeroperl_set_var(n,r.getPtr()))throw new j(`Failed to set variable '${t}'`)}finally{this.exports.free(n),!(i instanceof re)&&r.dispose()}}registerFunction(t,i){this.checkDisposed();let r=this.nextFuncId++;this.hostFunctions.set(r,i);let n=this.writeCString(t);try{this.exports.zeroperl_register_function(r,n)}finally{this.exports.free(n)}}registerMethod(t,i,r){this.checkDisposed();let n=this.nextFuncId++;this.hostFunctions.set(n,r);let s=this.writeCString(t),o=this.writeCString(i);try{this.exports.zeroperl_register_method(n,s,o)}finally{this.exports.free(s),this.exports.free(o)}}async call(t,i=[],r="scalar"){this.checkDisposed();let n=this.writeCString(t),s=jr(r),o=0;if(i.length>0){o=this.exports.malloc(i.length*4);let l=new DataView(this.exports.memory.buffer);for(let a=0;a<i.length;a++){let p=i[a];if(!p)throw new j(`Argument at index ${a} is undefined`);l.setUint32(o+a*4,p.getPtr(),!0)}}try{let l=await this.exports.zeroperl_call(n,s,i.length,o);if(l===0)return r==="void"?void 0:r==="scalar"?null:[];let a=new DataView(this.exports.memory.buffer),p=a.getInt32(l,!0),f=[];for(let h=0;h<p;h++){let m=this.exports.zeroperl_result_get(l,h);m!==0&&f.push(new re(m,this.exports))}let c=a.getUint32(l+4,!0);if(c!==0&&this.exports.free(c),this.exports.free(l),r==="void"){for(let h of f)h.dispose();return}return r==="scalar"?f[0]??null:f}catch(l){if(l instanceof Tt)return r==="void"?void 0:r==="scalar"?null:[];throw l}finally{this.exports.free(n),o!==0&&this.exports.free(o)}}async eval(t,i=[]){this.checkDisposed();let r=this.writeCString(t),n=0,s=[];if(i.length>0){let o=this.writeStringArray(i);n=o.argv,s=o.buffers}try{let o=await this.exports.zeroperl_eval(r,jr("scalar"),i.length,n);return o!==0?{success:!1,error:this.getLastError(),exitCode:o}:{success:!0,exitCode:0}}catch(o){if(o instanceof Tt)return o.code!==0?{success:!1,error:this.getLastError(),exitCode:o.code}:{success:!0,exitCode:0};throw o}finally{this.exports.free(r),s.length>0&&this.freeStringArray(n,s)}}async runFile(t,i=[]){this.checkDisposed();let r=this.writeCString(t),n=0,s=[];if(i.length>0){let o=this.writeStringArray(i);n=o.argv,s=o.buffers}try{let o=await this.exports.zeroperl_run_file(r,i.length,n);return o!==0?{success:!1,error:this.getLastError(),exitCode:o}:{success:!0,exitCode:0}}catch(o){if(o instanceof Tt)return o.code!==0?{success:!1,error:this.getLastError(),exitCode:o.code}:{success:!0,exitCode:0};throw o}finally{this.exports.free(r),s.length>0&&this.freeStringArray(n,s)}}async reset(){this.checkDisposed();let t=await this.exports.zeroperl_reset();if(t!==0)throw new j("Failed to reset Perl interpreter",t,this.getLastError())}flush(){if(this.checkDisposed(),this.exports.zeroperl_flush()!==0)throw new j("Failed to flush output buffers")}getLastError(){return this.checkDisposed(),this.readCString(this.exports.zeroperl_last_error())}clearError(){this.checkDisposed(),this.exports.zeroperl_clear_error()}isInitialized(){return this.checkDisposed(),this.exports.zeroperl_is_initialized()!==0}canEvaluate(){return this.checkDisposed(),this.exports.zeroperl_can_evaluate()!==0}dispose(){this.isDisposed||(this.exports.zeroperl_free_interpreter(),this.isDisposed=!0,this.hostFunctions.clear())}shutdown(){this.isDisposed||(this.exports.zeroperl_shutdown(),this.isDisposed=!0,this.hostFunctions.clear())}writeCString(t){if(!t)return 0;let i=Wi.encode(`${t}\0`),r=this.exports.malloc(i.length);return new Uint8Array(this.exports.memory.buffer).set(i,r),r}readCString(t){if(t===0)return"";let i=new Uint8Array(this.exports.memory.buffer),r=0;for(;i[t+r]!==0;)r++;return $r.decode(i.subarray(t,t+r))}writeStringArray(t){let i=[],r=this.exports.malloc(t.length*4),n=new DataView(this.exports.memory.buffer);for(let s=0;s<t.length;s++){let o=t[s];if(o===void 0)throw new j(`Argument at index ${s} is undefined`);let l=this.writeCString(o);i.push(l),n.setUint32(r+s*4,l,!0)}return{argv:r,buffers:i}}freeStringArray(t,i){for(let r of i)this.exports.free(r);this.exports.free(t)}checkDisposed(){if(this.isDisposed)throw new j("ZeroPerl instance has been disposed")}}var Fa=`use strict;use warnings;require 5.004;my$version='13.42';$^W=1;my$exePath;BEGIN {$exePath=@ARGV && lc($ARGV[0])eq '-xpath' && shift()? $^X : $0;my$exeDir=($exePath =~ /(.*)[\\\\\\/]/)? $1 : '.';my$incDir=($0 =~ /(.*)[\\\\\\/]/)? "$1/lib" : './lib';if (-l $0){my$lnk=eval {readlink $0};if (defined$lnk){my$lnkDir=($lnk =~ /(.*)[\\\\\\/]/)? $1 : '.';$exeDir=(($lnk =~ m(^/))? '' : $exeDir .'/').$lnkDir;$incDir="$exeDir/lib"}}$Image::ExifTool::exeDir=$exeDir;unshift@INC,$incDir;while (@ARGV and lc($ARGV[0])eq '-config'){shift;push@Image::ExifTool::configFiles,shift}}use Image::ExifTool qw{:Public};sub SigInt();sub SigCont();sub Cleanup();sub GetImageInfo($$);sub SetImageInfo($$$);sub DoHardLink($$$$$);sub CleanXML($);sub EncodeXML($);sub FormatXML($$$);sub EscapeJSON($;$);sub FormatJSON($$$;$);sub PrintCSV(;$);sub AddGroups($$$$);sub ConvertBinary($);sub IsEqual($$;$);sub Printable($);sub LengthUTF8($);sub Infile($;$);sub AddSetTagsFile($;$);sub Warning($$);sub DoSetFromFile($$$);sub CleanFilename($);sub HasWildcards($);sub SetWindowTitle($);sub ProcessFiles($;$);sub ScanDir($$;$);sub FindFileWindows($$);sub FileNotFound($);sub PreserveTime();sub AbsPath($);sub MyConvertFileName($$);sub SuggestedExtension($$$);sub LoadPrintFormat($;$);sub FilenameSPrintf($;$@);sub NextUnusedFilename($;$);sub CreateDirectory($);sub OpenOutputFile($;@);sub AcceptFile($);sub SlurpFile($$);sub FilterArgfileLine($);sub ReadStayOpen($);sub Progress($$);sub PrintTagList($@);sub PrintErrors($$$);END {Cleanup()}my@commonArgs;my@condition;my@csvExclude;my@csvFiles;my@csvTags;my@delFiles;my@dynamicFiles;my (@echo3,@echo4);my@efile;my@exclude;my@files;my@moreArgs;my@newValues;my@requestTags;my@srcFmt;my@tags;my%altFile;my%appended;my%countLink;my%created;my%csvTags;my%database;my%filterExt;my%ignore;my%outComma;my%outTrailer;my%preserveTime;my%printFmt;my%seqFileDir;my%setTags;my%setTagsList;my%usedFileName;my%utf8FileName;my%warnedOnce;my%wext;my%wroteHEAD;my$allGroup;my$altEnc;my$argFormat;my$binaryOutput;my$binaryStdout;my$binSep;my$binTerm;my$comma;my$count;my$countBad;my$countBadCr;my$countBadWr;my$countCopyWr;my$countDir;my$countFailed;my$countGoodCr;my$countGoodWr;my$countNewDir;my$countSameWr;my$critical;my$csv;my$csvDelim;my$dbAdd;my$dbSaveCount;my$deleteOrig;my$diff;my$disableOutput;my$doSetFileName;my$doUnzip;my ($end,$endDir,%endDir);my$escapeC;my$escapeHTML;my$evalWarning;my$executeID;my$failCondition;my$fastCondition;my$fileHeader;my$fileTrailer;my$filtered;my$filterFlag;my$fixLen;my$forcePrint;my$geoOnly;my$helped;my$html;my$ignoreHidden;my$interrupted;my$isBinary;my$isWriting;my$joinLists;my$json;my$langOpt;my$listDir;my$listItem;my$listSep;my$mt;my$multiFile;my$noBinary;my$outFormat;my$outOpt;my$overwriteOrig;my$pause;my$plot;my$preserveTime;my$progress;my$progressCount;my$progressIncr;my$progressMax;my$progressNext;my$progStr;my$quiet;my$rafStdin;my$recurse;my$rtnVal;my$rtnValPrev;my$saveCount;my$scanWritable;my$sectHeader;my$sectTrailer;my$seqFileDir;my$seqFileNum;my$setCharset;my$showGroup;my$showTagID;my$stayOpenBuff='';my$stayOpenFile;my$structOpt;my$tabFormat;my$tagOut;my$textOut;my$textOut2;my$textOverwrite;my$tmpFile;my$tmpText;my$validFile;my$verbose;my$vout;my$windowTitle;my$xml;my$stayOpen=0;my$rtnValApp=0;my$curTitle='';my$isCRLF={MSWin32=>1,os2=>1,dos=>1 }->{$^O};my%jsonChar=('"'=>'"','\\\\'=>'\\\\',"\\t"=>'t',"\\n"=>'n',"\\r"=>'r');my%escC=("\\n"=>'\\n',"\\r"=>'\\r',"\\t"=>'\\t','\\\\'=>'\\\\\\\\');my%unescC=(a=>"\\a",b=>"\\b",f=>"\\f",n=>"\\n",r=>"\\r",t=>"\\t",0=>"\\0",'\\\\'=>'\\\\');my%optArgs=('-tagsfromfile'=>1,'-addtagsfromfile'=>1,'-alltagsfromfile'=>1,'-@'=>1,'-api'=>1,'-c'=>1,'-coordformat'=>1,'-charset'=>0,'-config'=>1,'-csvdelim'=>1,'-d'=>1,'-dateformat'=>1,'-D'=>0,'-diff'=>1,'-echo'=>1,'-echo#'=>1,'-efile'=>1,'-efile#'=>1,'-efile!'=>1,'-efile#!'=>1,'-ext'=>1,'--ext'=>1,'-ext+'=>1,'--ext+'=>1,'-extension'=>1,'--extension'=>1,'-extension+'=>1,'--extension+'=>1,'-fileorder'=>1,'-fileorder#'=>1,'-file#'=>1,'-geotag'=>1,'-globaltimeshift'=>1,'-i'=>1,'-ignore'=>1,'-if'=>1,'-if#'=>1,'-lang'=>0,'-listitem'=>1,'-o'=>1,'-out'=>1,'-p'=>1,'-printformat'=>1,'-p-'=>1,'-printformat-'=>1,'-P'=>0,'-password'=>1,'-require'=>1,'-sep'=>1,'-separator'=>1,'-srcfile'=>1,'-stay_open'=>1,'-use'=>1,'-userparam'=>1,'-w'=>1,'-w!'=>1,'-w+'=>1,'-w+!'=>1,'-w!+'=>1,'-textout'=>1,'-textout!'=>1,'-textout+'=>1,'-textout+!'=>1,'-textout!+'=>1,'-tagout'=>1,'-tagout!'=>1,'-tagout+'=>1,'-tagout+!'=>1,'-tagout!+'=>1,'-wext'=>1,'-wm'=>1,'-writemode'=>1,'-x'=>1,'-exclude'=>1,'-X'=>0,);my@recommends=qw(Archive::Zip Compress::Zlib Digest::MD5 Digest::SHA IO::Compress::Bzip2 POSIX::strptime Time::Local Unicode::LineBreak Compress::Raw::Lzma IO::Compress::RawDeflate IO::Uncompress::RawInflate IO::Compress::Brotli IO::Uncompress::Brotli Win32::API Win32::FindFile Win32API::File);my%altRecommends=('POSIX::strptime'=>'Time::Piece',);my%unescapeChar=('t'=>"\\t",'n'=>"\\n",'r'=>"\\r");sub Image::ExifTool::EndDir() {return$endDir=1}sub Image::ExifTool::End() {return$end=1}sub Exit {if ($pause){if (eval {require Term::ReadKey}){print STDERR "-- press any key --";Term::ReadKey::ReadMode('cbreak');Term::ReadKey::ReadKey(0);Term::ReadKey::ReadMode(0);print STDERR "\\b \\b" x 20}else {print STDERR "-- press RETURN --\\n";<STDIN>}}exit shift}sub Warn {if ($quiet < 2 or $_[0]=~ /^Error/){my$oldWarn=$SIG{'__WARN__'};delete$SIG{'__WARN__'};warn(@_);$SIG{'__WARN__'}=$oldWarn if defined$oldWarn}}sub Error {Warn @_;$rtnVal=1}sub WarnOnce($) {Warn(@_)and $warnedOnce{$_[0]}=1 unless$warnedOnce{$_[0]}}sub SigInt() {$critical and $interrupted=1,return;Cleanup();exit 1}sub SigCont() {}sub Cleanup() {$mt->Unlink($tmpFile)if defined$tmpFile;$mt->Unlink($tmpText)if defined$tmpText;undef$tmpFile;undef$tmpText;PreserveTime()if%preserveTime;SetWindowTitle('')}if (grep /^-common_args$/i,@ARGV){my (@newArgs,$common,$end);for (@ARGV){if (/^-common_args$/i and not $end){$common=1}elsif ($common){push@commonArgs,$_}else {$end=1 if $_ eq '--';push@newArgs,$_}}@ARGV=@newArgs if$common}Command: for (;;){if (@echo3){my$str=join("\\n",@echo3)."\\n";$str =~ s/\\$\\{status\\}/$rtnVal/ig;print STDOUT$str}if (@echo4){my$str=join("\\n",@echo4)."\\n";$str =~ s/\\$\\{status\\}/$rtnVal/ig;print STDERR$str}$rafStdin->Close()if$rafStdin;undef$rafStdin;$rtnValPrev=$rtnVal;$rtnValApp=$rtnVal if$rtnVal;last unless@ARGV or not defined$rtnVal or $stayOpen >= 2 or @commonArgs;if ($binaryStdout){binmode(STDOUT,':crlf')if $] >= 5.006 and $isCRLF;$binaryStdout=0}if ($stayOpen >= 2){if ($quiet and not defined$executeID){eval {require IO::Handle}and STDERR->flush(),STDOUT->flush()}else {eval {require IO::Handle}and STDERR->flush();my$id=defined$executeID ? $executeID : '';my$save=$|;$|=1;print "{ready$id}\\n";$|=$save}}undef@condition;undef@csvExclude;undef@csvFiles;undef@csvTags;undef@delFiles;undef@dynamicFiles;undef@echo3;undef@echo4;undef@efile;undef@exclude;undef@files;undef@newValues;undef@requestTags;undef@srcFmt;undef@tags;undef%altFile;undef%appended;undef%countLink;undef%created;undef%csvTags;undef%database;undef%endDir;undef%filterExt;undef%ignore;undef%outComma;undef%outTrailer;undef%preserveTime;undef%printFmt;undef%seqFileDir;undef%setTags;undef%setTagsList;undef%usedFileName;undef%utf8FileName;undef%warnedOnce;undef%wext;undef%wroteHEAD;undef$allGroup;undef$altEnc;undef$argFormat;undef$binaryOutput;undef$binSep;undef$binTerm;undef$comma;undef$csv;undef$dbAdd;undef$deleteOrig;undef$diff;undef$disableOutput;undef$doSetFileName;undef$doUnzip;undef$end;undef$endDir;undef$escapeC;undef$escapeHTML;undef$evalWarning;undef$executeID;undef$failCondition;undef$fastCondition;undef$fileHeader;undef$filtered;undef$fixLen;undef$forcePrint;undef$geoOnly;undef$ignoreHidden;undef$isBinary;undef$joinLists;undef$langOpt;undef$listDir;undef$listItem;undef$multiFile;undef$noBinary;undef$outOpt;undef$plot;undef$preserveTime;undef$progress;undef$progressCount;undef$progressIncr;undef$progressMax;undef$progressNext;undef$rafStdin;undef$recurse;undef$scanWritable;undef$sectHeader;undef$setCharset;undef$showGroup;undef$showTagID;undef$structOpt;undef$tagOut;undef$textOut;undef$textOut2;undef$textOverwrite;undef$tmpFile;undef$tmpText;undef$validFile;undef$verbose;undef$windowTitle;$count=0;$countBad=0;$countBadCr=0;$countBadWr=0;$countCopyWr=0;$countDir=0;$countFailed=0;$countGoodCr=0;$countGoodWr=0;$countNewDir=0;$countSameWr=0;$csvDelim=',';$dbSaveCount=0;$fileTrailer='';$filterFlag=0;$html=0;$isWriting=0;$json=0;$listSep=', ';$outFormat=0;$overwriteOrig=0;$progStr='';$quiet=0;$rtnVal=0;$saveCount=0;$sectTrailer='';$seqFileDir=0;$seqFileNum=0;$tabFormat=0;$vout=\\*STDOUT;$xml=0;my@fileOrder;my$fileOrderFast;my$addGeotime;my$doGlob;my$endOfOpts;my$escapeXML;my$setTagsFile;my$sortOpt;my$srcStdin;my$tagsFrom='';my$useMWG;my ($argsLeft,@nextPass,$badCmd);my$pass=0;if ($^O eq 'MSWin32' and eval {require File::Glob}){import File::Glob qw(:globally :nocase);$doGlob=1}$mt=Image::ExifTool->new;$mt->Options(Duplicates=>0)unless%Image::ExifTool::UserDefined::Options and defined$Image::ExifTool::UserDefined::Options{Duplicates};$joinLists=1 if defined$mt->Options('List')and not $mt->Options('List');if (not $preserveTime and $^O eq 'MSWin32'){$preserveTime=2 if eval {require Win32::API}and eval {require Win32API::File}}if (@Image::ExifTool::UserDefined::Arguments){unshift@ARGV,@Image::ExifTool::UserDefined::Arguments}if ($version ne $Image::ExifTool::VERSION){Warn "Application version $version does not match Image::ExifTool library version $Image::ExifTool::VERSION\\n"}for (;;){if (not @ARGV or ($ARGV[0]=~ /^(-|\\xe2\\x88\\x92)execute(\\d+)?$/i and not $endOfOpts)){if (@ARGV){$executeID=$2;$helped=1;$badCmd and shift,$rtnVal=1,next Command}elsif ($stayOpen >= 2){ReadStayOpen(\\@ARGV);next}elsif ($badCmd){undef@commonArgs;$rtnVal=1;next Command}if ($pass==0){if (@commonArgs and not defined$argsLeft){$argsLeft=scalar(@ARGV)+ scalar(@moreArgs);unshift@ARGV,@commonArgs;undef@commonArgs unless$argsLeft;next}if (defined$argsLeft and $argsLeft < scalar(@ARGV)+ scalar(@moreArgs)){Warn "Ignoring -common_args from $ARGV[0] onwards to avoid infinite recursion\\n";while ($argsLeft < scalar(@ARGV)+ scalar(@moreArgs)){@ARGV and shift(@ARGV),next;shift@moreArgs}}$useMWG=1 if not $useMWG and grep /^([--_0-9A-Z]+:)*1?mwg:/i,@tags,@requestTags;if ($useMWG){require Image::ExifTool::MWG;Image::ExifTool::MWG::Load()}if (defined$forcePrint){unless (defined$mt->Options('MissingTagValue')){$mt->Options(MissingTagValue=>'-')}$forcePrint=$mt->Options('MissingTagValue')}}if (@nextPass){unshift@ARGV,@nextPass;undef@nextPass;undef$endOfOpts;++$pass;next}@ARGV and shift;last}$_=shift;next if$badCmd;if (not $endOfOpts and s/^(-|\\xe2\\x88\\x92)//){s/^\\xe2\\x88\\x92/-/;if ($_ eq '-'){$pass or push@nextPass,'--';$endOfOpts=1;next}my$a=lc $_;if (/^list([wfrdx]|wf|g(\\d*)|geo)?$/i){$pass or push@nextPass,"-$_";my$type=lc($1 || '');if (not $type or $type eq 'w' or $type eq 'x'){my$group;if ($ARGV[0]and $ARGV[0]=~ /^(-|\\xe2\\x88\\x92)(.+):(all|\\*)$/i){if ($pass==0){$useMWG=1 if lc($2)eq 'mwg';push@nextPass,shift;next}$group=$2;shift;$group =~ /IFD/i and Warn("Can't list tags for specific IFD\\n"),$helped=1,next;$group =~ /^(all|\\*)$/ and undef$group}else {$pass or next}$helped=1;if ($type eq 'x'){require Image::ExifTool::TagInfoXML;my%opts;$opts{Flags}=1 if defined$forcePrint;$opts{NoDesc}=1 if$outFormat > 0;$opts{Lang}=$langOpt;Image::ExifTool::TagInfoXML::Write(undef,$group,%opts);next}my$wr=($type eq 'w');my$msg=($wr ? 'Writable' : 'Available').($group ? " $group" : '').' tags';PrintTagList($msg,$wr ? GetWritableTags($group): GetAllTags($group));next if$group or $wr;my@tagList=GetShortcuts();PrintTagList('Command-line shortcuts',@tagList)if@tagList;next}$pass or next;$helped=1;if ($type eq 'wf'){my@wf;CanWrite($_)and push@wf,$_ foreach GetFileType();PrintTagList('Writable file extensions',@wf)}elsif ($type eq 'f'){PrintTagList('Supported file extensions',GetFileType())}elsif ($type eq 'r'){PrintTagList('Recognized file extensions',GetFileType(undef,0))}elsif ($type eq 'd'){PrintTagList('Deletable groups',GetDeleteGroups())}elsif ($type eq 'geo'){require Image::ExifTool::Geolocation;my ($i,$entry);print "Geolocation database:\\n" unless$quiet;my$isAlt=$mt->Options('GeolocAltNames')? ',AltNames' : '';$isAlt='' if$isAlt and not Image::ExifTool::Geolocation::ReadAltNames();print "City,Region,Subregion,CountryCode,Country,TimeZone,FeatureCode,Population,Latitude,Longitude$isAlt\\n";Image::ExifTool::Geolocation::SortDatabase('City')if$sortOpt;my$minPop=$mt->Options('GeolocMinPop');my$feature=$mt->Options('GeolocFeature')|| '';my$neg=$feature =~ s/^-//;my%fcodes=map {lc($_)=>1}split /\\s*,\\s*/,$feature;my@isUTF8=(0,1,2,4);push@isUTF8,10 if$isAlt;for ($i=0;;++$i){my@entry=Image::ExifTool::Geolocation::GetEntry($i,$langOpt,1)or last;$#entry=9;next if$minPop and $entry[7]< $minPop;next if%fcodes and $neg ? $fcodes{lc$entry[6]}: not $fcodes{lc$entry[6]};push@entry,Image::ExifTool::Geolocation::GetAltNames($i,1)if$isAlt;$_=defined $_ ? $mt->Decode($_,'UTF8'): '' foreach@entry[@isUTF8];pop@entry if$isAlt and not $entry[10];print join(',',@entry),"\\n"}}else {my$family=$2 || 0;PrintTagList("Groups in family $family",$mt->GetAllGroups($family))}next}if ($a eq 'ver'){$pass or push(@nextPass,'-ver'),next;my$libVer=$Image::ExifTool::VERSION;my$str=$libVer eq $version ? '' : " [Warning: Library version is $libVer]";if ($verbose){print "ExifTool version $version$str$Image::ExifTool::RELEASE\\n";printf "Perl version %s%s\\n",$],(defined \${^UNICODE} ? " (-C\${^UNICODE})" : '');print "Platform: $^O\\n";if ($verbose > 8){print "Current Dir: " .Cwd::getcwd()."\\n" if (eval {require Cwd});print "Script Name: $0\\n";print "Exe Name:    $^X\\n";print "Exe Dir:     $Image::ExifTool::exeDir\\n";print "Exe Path:    $exePath\\n"}print "Optional libraries:\\n";for (@recommends){next if /^Win32/ and $^O ne 'MSWin32';my$ver=eval "require $_ and \\$\${_}::VERSION";my$alt=$altRecommends{$_};$ver=eval "require $alt and \\$\${alt}::VERSION" and $_=$alt if not $ver and $alt;printf "  %-28s %s\\n",$_,$ver || '(not installed)'}if ($verbose > 1){print "Include directories:\\n";ref $_ or print "  $_\\n" foreach@INC}}else {print "$version$str$Image::ExifTool::RELEASE\\n"}$helped=1;next}if (/^(all|add)?tagsfromfile(=.*)?$/i){$setTagsFile=$2 ? substr($2,1): (@ARGV ? shift : '');if ($setTagsFile eq ''){Error("File must be specified for -tagsFromFile option\\n");$badCmd=1;next}AddSetTagsFile($setTagsFile,{Replace=>($1 and lc($1)eq 'add')? 0 : 1 });$tagsFrom='File';next}if ($a eq '@'){my$argFile=shift or Error("Expecting filename for -\\@ option\\n"),$badCmd=1,next;if ($stayOpen==1){@moreArgs=@ARGV;undef@ARGV}elsif ($stayOpen==3){if ($stayOpenFile and $stayOpenFile ne '-' and $argFile eq $stayOpenFile){$stayOpen=2;Warn "Ignoring request to switch to the same -stay_open ARGFILE ($argFile)\\n";next}close STAYOPEN;$stayOpen=1}my$fp=($stayOpen==1 ? \\*STAYOPEN : \\*ARGFILE);unless ($mt->Open($fp,$argFile)){unless ($argFile !~ /^\\// and $mt->Open($fp,"$Image::ExifTool::exeDir/$argFile")){Error "Error opening arg file $argFile\\n";$badCmd=1;next}}if ($stayOpen==1){$stayOpenFile=$argFile;$stayOpenBuff='';$stayOpen=2;$helped=1;ReadStayOpen(\\@ARGV);next}my (@newArgs,$didBOM);for (<ARGFILE>){unless ($didBOM){s/^\\xef\\xbb\\xbf//;$didBOM=1}$_=FilterArgfileLine($_);push@newArgs,$_ if defined $_}close ARGFILE;unshift@ARGV,@newArgs;next}/^(-?)(a|duplicates)$/i and $mt->Options(Duplicates=>($1 ? 0 : 1)),next;if ($a eq 'api'){my$opt=shift;if (defined$opt and length$opt){my$val=($opt =~ s/=(.*)//s)? $1 : 1;$val=undef unless$opt =~ s/\\^$// or length$val;$mt->Options($opt=>$val)}else {print "Available API Options:\\n";my$availableOptions=Image::ExifTool::AvailableOptions();$$_[3]or printf("  %-17s - %s\\n",$$_[0],$$_[2])foreach @$availableOptions;$helped=1}next}/^arg(s|format)$/i and $argFormat=1,next;if (/^(-?)b(inary)?$/i){($binaryOutput,$noBinary)=$1 ? (undef,1): (1,undef);$mt->Options(Binary=>$binaryOutput,NoPDFList=>$binaryOutput);next}if (/^c(oordFormat)?$/i){my$fmt=shift;$fmt or Error("Expecting coordinate format for -c option\\n"),$badCmd=1,next;$mt->Options('CoordFormat',$fmt);next}if ($a eq 'charset'){my$charset=(@ARGV and $ARGV[0]!~ /^(-|\\xe2\\x88\\x92)/)? shift : undef;if (not $charset){$pass or push(@nextPass,'-charset'),next;my%charsets;$charsets{$_}=1 foreach values%Image::ExifTool::charsetName;PrintTagList('Available character sets',sort keys%charsets);$helped=1}elsif ($charset !~ s/^(\\w+)=// or lc($1)eq 'exiftool'){{local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};undef$evalWarning;$mt->Options(Charset=>$charset)}if ($evalWarning){Warn$evalWarning}else {$setCharset=$mt->Options('Charset')}}else {my$type={id3=>'ID3',iptc=>'IPTC',exif=>'EXIF',filename=>'FileName',photoshop=>'Photoshop',quicktime=>'QuickTime',riff=>'RIFF' }->{lc $1};$type or Warn("Unknown type for -charset option: $1\\n"),next;$mt->Options("Charset$type"=>$charset)}next}/^config$/i and Warn("Ignored -config option (not first on command line)\\n"),shift,next;if (/^(csv|j(son)?)(\\+?=.*)?$/i){my$dbFile=$3;my$dbType=lc($1)eq 'csv' ? 'CSV' : 'JSON';unless ($dbFile){if ($dbType eq 'CSV'){$csv=$dbType}else {$json=1;$html=$xml=0;$mt->Options(Duplicates=>1);require Image::ExifTool::XMP}next}unless ($pass){@tags and Warn("Tag arguments should come after the -$1= option\\n");push@nextPass,"-$_";push@newValues,{SaveCount=>++$saveCount };$dbSaveCount=$saveCount;$tagsFrom='CSV';next}$dbFile =~ s/^(\\+?=)//;$dbAdd=2 if $1 eq '+=';$vout=\\*STDERR if$srcStdin;$verbose and print$vout "Reading $dbType file $dbFile\\n";my$msg;if ($mt->Open(\\*CSVFILE,$dbFile)){binmode CSVFILE;require Image::ExifTool::Import;if ($dbType eq 'CSV'){$msg=Image::ExifTool::Import::ReadCSV(\\*CSVFILE,\\%database,$forcePrint,$csvDelim)}else {my$chset=$mt->Options('Charset');$msg=Image::ExifTool::Import::ReadJSON(\\*CSVFILE,\\%database,$forcePrint,$chset)}close(CSVFILE)}else {$msg="Error opening $dbType file '\${dbFile}'"}$msg and Warn("$msg\\n");$isWriting=1;$csv=$dbType;next}if (/^csvdelim$/i){$csvDelim=shift;defined$csvDelim or Error("Expecting argument for -csvDelim option\\n"),$badCmd=1,next;$csvDelim =~ /"/ and Error("CSV delimiter can not contain a double quote\\n"),$badCmd=1,next;my%unescape=('t'=>"\\t",'n'=>"\\n",'r'=>"\\r",'\\\\'=>'\\\\');$csvDelim =~ s/\\\\(.)/$unescape{$1}||"\\\\$1"/sge;$mt->Options(CSVDelim=>$csvDelim);next}if (/^d$/ or $a eq 'dateformat'){my$fmt=shift;$fmt or Error("Expecting date format for -d option\\n"),$badCmd=1,next;$mt->Options('DateFormat',$fmt);next}(/^D$/ or $a eq 'decimal')and $showTagID='D',next;if (/^diff$/i){$diff=shift;defined$diff or Error("Expecting file name for -$_ option\\n"),$badCmd=1;CleanFilename($diff);next}/^delete_original(!?)$/i and $deleteOrig=($1 ? 2 : 1),next;/^list_dir$/i and $listDir=1,next;(/^e$/ or $a eq '-composite')and $mt->Options(Composite=>0),next;(/^-e$/ or $a eq 'composite')and $mt->Options(Composite=>1),next;(/^E$/ or $a eq 'escapehtml')and require Image::ExifTool::HTML and $escapeHTML=1,next;($a eq 'ec' or $a eq 'escapec')and $escapeC=1,next;($a eq 'ex' or $a eq 'escapexml')and $escapeXML=1,next;if (/^echo(\\d)?$/i){my$n=$1 || 1;my$arg=shift;next unless defined$arg;$n > 4 and Warn("Invalid -echo number\\n"),next;if ($n > 2){$n==3 ? push(@echo3,$arg): push(@echo4,$arg)}else {print {$n==2 ? \\*STDERR : \\*STDOUT}$arg,"\\n"}$helped=1;next}if (/^(ee|extractembedded)(\\d*)$/i){$mt->Options(ExtractEmbedded=>$2 || 1);$mt->Options(Duplicates=>1);next}if (/^efile(\\d+)?(!)?$/i){my$arg=shift;defined$arg or Error("Expecting file name for -$_ option\\n"),$badCmd=1,next;$efile[0]=$arg if not $1 or $1 & 0x01;$efile[1]=$arg if $1 and $1 & 0x02;$efile[2]=$arg if $1 and $1 & 0x04;$efile[3]=$arg if $1 and $1 & 0x08;$efile[4]=$arg if $1 and $1 & 0x016;unlink$arg if $2;next}if (/^-?ext(ension)?(\\+)?$/i){my$ext=shift;defined$ext or Error("Expecting extension for -ext option\\n"),$badCmd=1,next;my$flag=/^-/ ? 0 : ($2 ? 2 : 1);$filterFlag |= (0x01 << $flag);$ext =~ s/^\\.//;$filterExt{uc($ext)}=$flag ? 1 : 0;next}if (/^f$/ or $a eq 'forceprint'){$forcePrint=1;next}if (/^F([-+]?\\d*)$/ or /^fixbase([-+]?\\d*)$/i){$mt->Options(FixBase=>$1);next}if (/^fast(\\d*)$/i){$mt->Options(FastScan=>(length $1 ? $1 : 1));next}if (/^(file\\d+)$/i){$altFile{lc $1}=shift or Error("Expecting file name for -file option\\n"),$badCmd=1,next;next}if (/^fileorder(\\d*)$/i){push@fileOrder,shift if@ARGV;my$num=$1 || 0;$fileOrderFast=$num if not defined$fileOrderFast or $fileOrderFast > $num;next}$a eq 'globaltimeshift' and $mt->Options(GlobalTimeShift=>shift),next;if (/^(g)(roupHeadings|roupNames)?([\\d:]*)$/i){$showGroup=$3 || 0;$allGroup=($2 ? lc($2)eq 'roupnames' : $1 eq 'G');$mt->Options(SavePath=>1)if$showGroup =~ /\\b5\\b/;$mt->Options(SaveFormat=>1)if$showGroup =~ /\\b6\\b/;next}if ($a eq 'geotag'){my$trkfile=shift;unless ($pass){push@nextPass,'-geotag',$trkfile;next}$trkfile or Error("Expecting file name for -geotag option\\n"),$badCmd=1,next;if (HasWildcards($trkfile)){my@trks;if ($^O eq 'MSWin32' and eval {require Win32::FindFile}){@trks=FindFileWindows($mt,$trkfile)}elsif (eval {require File::Glob}){@trks=File::Glob::bsd_glob($trkfile)}else {@trks=glob($trkfile)}@trks or Error("No matching file found for -geotag option\\n"),$badCmd=1,next;push@newValues,'geotag='.shift(@trks)while@trks > 1;$trkfile=pop(@trks)}$_="geotag=$trkfile"}if (/^h$/ or $a eq 'htmlformat'){require Image::ExifTool::HTML;$html=$escapeHTML=1;$json=$xml=0;next}(/^H$/ or $a eq 'hex')and $showTagID='H',next;if (/^htmldump([-+]?\\d+)?$/i){$verbose=($verbose || 0)+ 1;$html=2;$mt->Options(HtmlDumpBase=>$1)if defined $1;next}if (/^i(gnore)?$/i){my$dir=shift;defined$dir or Error("Expecting directory name for -i option\\n"),$badCmd=1,next;$ignore{$dir}=1;$dir eq 'HIDDEN' and $ignoreHidden=1;next}if (/^if(\\d*)$/i){my$cond=shift;my$fast=length($1)? $1 : undef;defined$cond or Error("Expecting expression for -if option\\n"),$badCmd=1,next;if (not @condition or not defined$fast or (defined$fastCondition and $fastCondition > $fast)){$fastCondition=$fast}$cond =~ /^\\s*(not\\s*)\\$ok\\s*$/i and ($1 xor $rtnValPrev)and $failCondition=1;push@requestTags,$cond =~ /\\$\\{?((?:[-_0-9A-Z]+:)*[-_0-9A-Z?*]+)/ig;push@condition,$cond;next}/^(k|pause)$/i and $pause=1,next;(/^l$/ or $a eq 'long')and --$outFormat,next;(/^L$/ or $a eq 'latin')and $mt->Options(Charset=>'Latin'),next;if ($a eq 'lang'){$langOpt=(@ARGV and $ARGV[0]!~ /^(-|\\xe2\\x88\\x92)/)? shift : undef;if ($langOpt){$langOpt =~ tr/-A-Z/_a-z/;$mt->Options(Lang=>$langOpt);next if$langOpt eq $mt->Options('Lang')}else {$pass or push(@nextPass,'-lang'),next}my$langs=$quiet ? '' : "Available languages:\\n";$langs .= "  $_ - $Image::ExifTool::langName{$_}\\n" foreach@Image::ExifTool::langs;$langs =~ tr/_/-/;$langs=Image::ExifTool::HTML::EscapeHTML($langs)if$escapeHTML;$langs=$mt->Decode($langs,'UTF8');$langOpt and Error("Invalid or unsupported language '\${langOpt}'.\\n$langs"),$badCmd=1,next;print$langs;$helped=1;next}if ($a eq 'listitem'){my$li=shift;defined$li and Image::ExifTool::IsInt($li)or Warn("Expecting integer for -listItem option\\n"),next;$mt->Options(ListItem=>$li);$listItem=$li;next}/^(m|ignoreminorerrors)$/i and $mt->Options(IgnoreMinorErrors=>1),next;/^(n|-printconv)$/i and $mt->Options(PrintConv=>0),next;/^(-n|printconv)$/i and $mt->Options(PrintConv=>1),next;$a eq 'nop' and $helped=1,next;if (/^o(ut)?$/i){$outOpt=shift;defined$outOpt or Error("Expected output file or directory name for -o option\\n"),$badCmd=1,next;CleanFilename($outOpt);$vout=\\*STDERR if$vout =~ /^-(\\.\\w+)?$/;next}/^overwrite_original$/i and $overwriteOrig=1,next;/^overwrite_original_in_place$/i and $overwriteOrig=2,next;/^plot$/i and require Image::ExifTool::Plot and $plot=Image::ExifTool::Plot->new,next;if (/^p(-?)$/ or /^printformat(-?)$/i){my$fmt=shift;if ($pass){LoadPrintFormat($fmt,$1 || $binaryOutput);if (not $useMWG and grep /^([-_0-9A-Z]+:)*1?mwg:/i,@requestTags){$useMWG=1;require Image::ExifTool::MWG;Image::ExifTool::MWG::Load()}}else {push@nextPass,"-$_",$fmt}next}(/^P$/ or $a eq 'preserve')and $preserveTime=1,next;/^password$/i and $mt->Options(Password=>shift),next;if (/^progress(\\d*)(:.*)?$/i){$progressIncr=$1 || 1;$progressNext=0;if ($2){$windowTitle=substr $2,1;$windowTitle='ExifTool %p%%' unless length$windowTitle;$windowTitle =~ /%\\d*[bpr]/ and $progress=0 unless defined$progress}else {$progress=1;$verbose=0 unless defined$verbose}$progressCount=0;next}/^q(uiet)?$/i and ++$quiet,next;/^r(ecurse)?(\\.?)$/i and $recurse=($2 ? 2 : 1),next;if ($a eq 'require'){my$ver=shift;unless (defined$ver and Image::ExifTool::IsFloat($ver)){Error("Expecting version number for -require option\\n");$badCmd=1;next}unless ($Image::ExifTool::VERSION >= $ver){Error("Requires ExifTool version $ver or later\\n");$badCmd=1}next}/^restore_original$/i and $deleteOrig=0,next;(/^S$/ or $a eq 'veryshort')and $outFormat+=2,next;/^s(hort)?(\\d*)$/i and $outFormat=$2 eq '' ? $outFormat + 1 : $2,next;/^scanforxmp$/i and $mt->Options(ScanForXMP=>1),next;if (/^sep(arator)?$/i){my$sep=$listSep=shift;defined$listSep or Error("Expecting list item separator for -sep option\\n"),$badCmd=1,next;$sep =~ s/\\\\(.)/$unescapeChar{$1}||$1/sge;(defined$binSep ? $binTerm : $binSep)=$sep;$mt->Options(ListSep=>$listSep);$joinLists=1;my$listSplit=quotemeta$listSep;$listSplit =~ s/(\\\\ )+/\\\\s\\*/g;$listSplit='\\\\s+' if$listSplit eq '\\\\s*';$mt->Options(ListSplit=>$listSplit);next}/^(-)?sort$/i and $sortOpt=$1 ? 0 : 1,next;if ($a eq 'srcfile'){@ARGV or Warn("Expecting FMT for -srcfile option\\n"),next;push@srcFmt,shift;next}if ($a eq 'stay_open'){my$arg=shift;defined$arg or Warn("Expecting argument for -stay_open option\\n"),next;if ($arg =~ /^(1|true)$/i){if (not $stayOpen){$stayOpen=1}elsif ($stayOpen==2){$stayOpen=3}else {Warn "-stay_open already active\\n"}}elsif ($arg =~ /^(0|false)$/i){if ($stayOpen >= 2){close STAYOPEN;push@ARGV,@moreArgs;undef@moreArgs}elsif (not $stayOpen){Warn("-stay_open wasn't active\\n")}$stayOpen=0}else {Warn "Invalid argument for -stay_open\\n"}next}if (/^(-)?struct$/i){$mt->Options(Struct=>$1 ? 0 : 1);next}/^t(ab)?$/ and $tabFormat=1,next;if (/^T$/ or $a eq 'table'){$tabFormat=$forcePrint=1;$outFormat+=2;++$quiet;next}if (/^(u)(nknown(2)?)?$/i){my$inc=($3 or (not $2 and $1 eq 'U'))? 2 : 1;$mt->Options(Unknown=>$mt->Options('Unknown')+ $inc);next}if ($a eq 'use'){my$module=shift;$module or Error("Expecting module name for -use option\\n"),$badCmd=1,next;lc$module eq 'mwg' and $useMWG=1,next;$module =~ /[^\\w:]/ and Error("Invalid module name: $module\\n"),$badCmd=1,next;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};unless (eval "require Image::ExifTool::$module" or eval "require $module" or eval "require '\${module}'"){Error("Error using module $module\\n");$badCmd=1}next}if ($a eq 'userparam'){my$opt=shift;defined$opt or Error("Expected parameter for -userParam option\\n"),$badCmd=1,next;$opt =~ /=/ or $opt .= '=1';$mt->Options(UserParam=>$opt);next}if (/^v(erbose)?(\\d*)$/i){$verbose=($2 eq '')? ($verbose || 0)+ 1 : $2;next}if (/^(w|textout|tagout)([!+]*)$/i){$textOut=shift || Warn("Expecting argument for -$_ option\\n");my ($t1,$t2)=($1,$2);$textOverwrite=0;$textOverwrite += 1 if$t2 =~ /!/;$textOverwrite += 2 if$t2 =~ /\\+/;if ($t1 ne 'W' and lc($t1)ne 'tagout'){undef$tagOut}elsif ($textOverwrite >= 2 and $textOut !~ /%[-+]?\\d*[.:]?\\d*[lu]?[tgso]/){$tagOut=0}else {$tagOut=1}next}if (/^(-?)(wext|tagoutext)$/i){my$ext=shift;defined$ext or Error("Expecting extension for -wext option\\n"),$badCmd=1,next;my$flag=1;$1 and $wext{'*'}=1,$flag=-1;$ext =~ s/^\\.//;$wext{lc$ext}=$flag;next}if ($a eq 'wm' or $a eq 'writemode'){my$wm=shift;defined$wm or Error("Expecting argument for -$_ option\\n"),$badCmd=1,next;$wm =~ /^[wcg]*$/i or Error("Invalid argument for -$_ option\\n"),$badCmd=1,next;$mt->Options(WriteMode=>$wm);next}if (/^x$/ or $a eq 'exclude'){my$tag=shift;defined$tag or Error("Expecting tag name for -x option\\n"),$badCmd=1,next;$tag =~ s/\\ball\\b/\\*/ig;if (not $tagsFrom){push@exclude,$tag}elsif ($tagsFrom eq 'CSV'){push@csvExclude,$tag}else {push @{$setTags{$setTagsFile}},"-$tag"}next}(/^X$/ or $a eq 'xmlformat')and $xml=1,$html=$json=0,$mt->Options(Duplicates=>1),next;if (/^php$/i){$json=2;$html=$xml=0;$mt->Options(Duplicates=>1);next}if (/^z(ip)?$/i){$doUnzip=1;$mt->Options(Compress=>1,XMPShorthand=>1);$mt->Options(Compact=>1)unless$mt->Options('Compact');next}$_ eq '' and push(@files,'-'),$srcStdin=1,next;length $_ eq 1 and $_ ne '*' and Error("Unknown option -$_\\n"),$badCmd=1,next;if (/^[^<]+(<?)=(.*)/s){my$val=$2;if ($1 and length($val)and ($val eq '@' or not defined FilenameSPrintf($val))){push@newValues,{SaveCount=>++$saveCount }}push@newValues,$_;if (/^([-_0-9A-Z]+:)*1?mwg:/i){$useMWG=1}elsif (/^([-_0-9A-Z]+:)*(filename|directory|testname)\\b/i){$doSetFileName=1}elsif (/^([-_0-9A-Z]+:)*(geotag|geotime|geosync|geolocate)\\b/i){if (lc $2 eq 'geotime'){$addGeotime=''}else {unshift@newValues,pop@newValues;if (lc $2 eq 'geotag' and (not defined$addGeotime or $addGeotime)and length$val){$addGeotime=($1 || '').q[Geotime<\${DateTimeOriginal#;$_=$self->GetValue('SubSecDateTimeOriginal','ValueConv') || $_}]}}}}else {if (not $setTagsFile and $tagsFrom ne 'CSV' and /(<|>)/){AddSetTagsFile($setTagsFile='@');$tagsFrom='File'}if ($tagsFrom eq 'CSV'){my$lst=s/^-// ? \\@csvExclude : \\@tags;push @$lst,$_}elsif ($setTagsFile){push @{$setTags{$setTagsFile}},$_;if ($1 eq '>'){$useMWG=1 if /^(.*>\\s*)?([-_0-9A-Z]+:)*1?mwg:/si;if (/\\b(filename|directory|testname)#?$/i){$doSetFileName=1}elsif (/\\bgeotime#?$/i){$addGeotime=''}}else {$useMWG=1 if /^([^<]+<\\s*(.*\\$\\{?)?)?([-_0-9A-Z]+:)*1?mwg:/si;if (/^([-_0-9A-Z]+:)*(filename|directory|testname)\\b/i){$doSetFileName=1}elsif (/^([-_0-9A-Z]+:)*geotime\\b/i){$addGeotime=''}}}else {my$lst=s/^-// ? \\@exclude : \\@tags;Warn(qq(Invalid TAG name: "$_"\\n))unless /^([-_0-9A-Z*]+:)*([-_0-9A-Z*?]+)#?$/i;push @$lst,$_}}}else {unless ($pass){push@nextPass,$_;next}if ($doGlob and HasWildcards($_)){if ($^O eq 'MSWin32' and eval {require Win32::FindFile}){push@files,FindFileWindows($mt,$_)}else {push@files,File::Glob::bsd_glob($_)}$doGlob=2}else {push@files,$_;$srcStdin=1 if $_ eq '-'}}}$mt->Options(UserParam=>'OK=' .(not $rtnValPrev));$vout=\\*STDERR if$srcStdin and ($isWriting or @newValues);$mt->Options(TextOut=>$vout)if$vout eq \\*STDERR;if ($useMWG and not defined$mt->Options('CharsetEXIF')){$mt->Options(CharsetEXIF=>'UTF8')}if (not @files and not $outOpt and not @newValues){my$loc=$mt->Options('Geolocation');$loc and $loc ne '1' and push(@files,qq(\\@JSON:{})),$geoOnly=1}unless ((@tags and not $outOpt)or @files or @newValues or $geoOnly){if ($doGlob and $doGlob==2){Error "No matching files\\n";next}$outOpt and Error("Nothing to write\\n"),next;unless ($helped){local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my$dummy=\\*SAVEERR;unless ($^O eq 'os2'){open SAVEERR,">&STDERR";open STDERR,'>/dev/null'}if (system('perldoc',$0)){print "Syntax:  exiftool [OPTIONS] FILE\\n\\n";print "Consult the exiftool documentation for a full list of options.\\n"}unless ($^O eq 'os2'){close STDERR;open STDERR,'>&SAVEERR'}}next}if (defined$deleteOrig and (@newValues or @tags)){if (not @newValues){my$verb=$deleteOrig ? 'deleting' : 'restoring from';Error "Can't specify tags when $verb originals\\n"}elsif ($deleteOrig){Error "Can't use -delete_original when writing.\\n";Error "Maybe you meant -overwrite_original ?\\n"}else {Error "It makes no sense to use -restore_original when writing\\n"}next}if ($overwriteOrig > 1 and $outOpt){Error "Can't overwrite in place when -o option is used\\n";next}if (($tagOut or defined$diff)and ($csv or $json or %printFmt or $tabFormat or $xml or $plot or ($verbose and $html))){my$opt=$tagOut ? '-W' : '-diff';Error "Sorry, $opt may not be combined with -csv, -htmlDump, -j, -p, -t or -X\\n";next}if ($csv and $csv eq 'CSV' and not $isWriting){$json=0;if ($textOut){$textOut2=$textOut;undef$textOut}if ($binaryOutput){$binaryOutput=0;$setCharset='default' unless defined$setCharset}if (%printFmt){Warn "The -csv option has no effect when -p is used\\n";undef$csv}require Image::ExifTool::XMP if$setCharset}if ($plot and $textOut){$textOut2=$textOut;undef$textOut}if ($textOut2){if ($textOverwrite > 1){Error "Can not append to multi-file output format\\n";undef$textOut2;next}if (not $textOverwrite and $mt->Exists($textOut2,1)){Error "Output file $textOut2 already exists\\n";undef$textOut2;next}CreateDirectory($textOut2);if ($mt->Open(\\*OUTFILE,$textOut2,'>')){close(\\*OUTFILE);unlink($textOut2)}else {Error("Error creating $textOut2\\n");undef$textOut2;next}}if ($escapeHTML or $json){$mt->Options(Charset=>'UTF8')if$json;$mt->Options(Escape=>'HTML')if$escapeHTML and not $xml}elsif ($escapeXML and not $xml){$mt->Options(Escape=>'XML')}if ($sortOpt){my$sort=($outFormat > 0 or $xml or $json or $csv or $plot)? 'Tag' : 'Descr';$mt->Options(Sort=>$sort,Sort2=>$sort)}if ($mt->Options('Struct')and not $structOpt){$structOpt=$mt->Options('Struct');require 'Image/ExifTool/XMPStruct.pl'}if ($plot){undef$joinLists;$mt->Options(List=>1);$plot->Settings($mt->Options('Plot'))}elsif ($xml){require Image::ExifTool::XMP;my$charset=$mt->Options('Charset');my%encoding=(UTF8=>'UTF-8',Latin=>'windows-1252',Latin2=>'windows-1250',Cyrillic=>'windows-1251',Greek=>'windows-1253',Turkish=>'windows-1254',Hebrew=>'windows-1255',Arabic=>'windows-1256',Baltic=>'windows-1257',Vietnam=>'windows-1258',MacRoman=>'macintosh',);unless ($encoding{$charset}){$charset='UTF8';$mt->Options(Charset=>$charset)}$fileHeader="<?xml version='1.0' encoding='$encoding{$charset}'?>\\n" ."<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\\n";$fileTrailer="</rdf:RDF>\\n";$joinLists=1 if$outFormat > 0;$mt->Options(List=>1)unless$joinLists;$showGroup=$allGroup=1;$binaryOutput=($outFormat > 0 ? undef : 0)if$binaryOutput;$showTagID='D' if$tabFormat and not $showTagID}elsif ($json){if ($json==1){$fileHeader='[';$fileTrailer="]\\n"}else {$fileHeader='Array(';$fileTrailer=");\\n"}if ($binaryOutput){$binaryOutput=0;require Image::ExifTool::XMP if$json==1}$mt->Options(List=>1)unless$joinLists;$showTagID='D' if$tabFormat and not $showTagID}elsif ($structOpt){$mt->Options(List=>1)}else {$joinLists=1}if ($argFormat){$outFormat=3;$allGroup=1 if defined$showGroup}if (Image::ExifTool::IsPC()){tr/\\\\/\\// foreach@files}unless (@files){unless ($outOpt){if ($doGlob and $doGlob==2){Error "No matching files\\n"}else {Error "No file specified\\n"}next}push@files,''}if ($verbose){$disableOutput=1 unless@tags or @exclude or $tagOut;undef$binaryOutput unless$tagOut;if ($html){$html=2;$mt->Options(HtmlDump=>$verbose)}else {$mt->Options(Verbose=>$verbose)unless$tagOut}}elsif (defined$verbose){require FileHandle;STDOUT->autoflush(1);STDERR->autoflush(1)}my$needSave=1;if (@newValues){if ($addGeotime){AddSetTagsFile($setTagsFile='@')unless$setTagsFile and $setTagsFile eq '@';push @{$setTags{$setTagsFile}},$addGeotime;$verbose and print$vout qq(Using default "-$addGeotime"\\n)}my%setTagsIndex;my%addDelOpt=('+'=>'AddValue','-'=>'DelValue',"\\xe2\\x88\\x92"=>'DelValue');$saveCount=0;for (@newValues){if (ref $_ eq 'HASH'){if ($$_{SaveCount}){$saveCount=$mt->SaveNewValues();$needSave=0;push@dynamicFiles,\\$csv if $$_{SaveCount}==$dbSaveCount}next}/(.*?)=(.*)/s or next;
        my ($tag, $newVal) = ($1, $2);
        $tag =~ s/\\ball\\b/\\*/ig;    # replace 'all' with '*' in tag names
        $newVal eq '' and undef $newVal unless $tag =~ s/\\^([-+]*)$/$1/;  # undefined to delete tag
        if ($tag =~ /^(All)?TagsFromFile$/i){defined$newVal or Error("Need file name for -tagsFromFile\\n"),next Command;++$isWriting;if ($newVal eq '@' or not defined FilenameSPrintf($newVal)or grep /\\bfile\\d+:/i,@{$setTags{$newVal}}){push@dynamicFiles,$newVal;next}unless ($mt->Exists($newVal)or $newVal eq '-'){Error "File '\${newVal}' does not exist for -tagsFromFile option\\n";next Command}my$setTags=$setTags{$newVal};if ($setTagsList{$newVal}){my$i=$setTagsIndex{$newVal}|| 0;$setTagsIndex{$newVal}=$i + 1;$setTags=$setTagsList{$newVal}[$i]if$setTagsList{$newVal}[$i]}unless (DoSetFromFile($mt,$newVal,$setTags)){$rtnVal=1;next Command}$needSave=1;next}my%opts=(Shift=>0);$opts{Protected}=1 unless$tag =~ /[?*]/;if ($tag =~ s/<// and defined$newVal){if (defined FilenameSPrintf($newVal)){SlurpFile($newVal,\\$newVal)or next}else {$tag =~ s/([-+]|\\xe2\\x88\\x92)$// and $opts{$addDelOpt{$1}}=1;my$result=Image::ExifTool::IsWritable($tag);if ($result){$opts{ProtectSaved}=$saveCount;push@dynamicFiles,[$tag,$newVal,\\%opts ];++$isWriting}elsif (defined$result){Warn "Tag '\${tag}' is not writable\\n"}else {Warn "Tag '\${tag}' does not exist\\n"}next}}if ($tag =~ s/([-+]|\\xe2\\x88\\x92)$//){$opts{$addDelOpt{$1}}=1;$newVal='' if $1 eq '-' and not defined$newVal}if ($escapeC and defined$newVal){$newVal =~ s/\\\\(x([0-9a-fA-F]{2})|.)/$2 ? chr(hex($2)) : $unescC{$1} || $1/seg}my ($rtn,$wrn)=$mt->SetNewValue($tag,$newVal,%opts);$needSave=1;++$isWriting if$rtn;$wrn and Warning($mt,$wrn);}for (@exclude){$mt->SetNewValue($_,undef,Replace=>2);$needSave=1}unless ($isWriting or $outOpt or @tags){Error "Nothing to do.\\n";next}}elsif (grep /^(\\*:)?\\*$/,@exclude){Error "All tags excluded -- nothing to do.\\n";next}if ($isWriting){if (defined$diff){Error "Can't use -diff option when writing tags\\n";next}elsif ($plot){Error "Can't use -plot option when writing tags\\n";next}elsif (@tags and not $outOpt and not $csv){my ($tg,$s)=@tags > 1 ? ("$tags[0] ...",'s'): ($tags[0],'');Warn "Ignored superfluous tag name$s or invalid option$s: -$tg\\n"}}$mt->SaveNewValues()if$outOpt or (@dynamicFiles and $needSave);$multiFile=1 if@files > 1;@exclude and $mt->Options(Exclude=>\\@exclude);undef$binaryOutput if$html;if ($binaryOutput){$outFormat=99;$mt->Options(PrintConv=>0);unless ($textOut or $binaryStdout){binmode(STDOUT);$binaryStdout=1;$mt->Options(TextOut=>($vout=\\*STDERR))}undef$showGroup}if (defined$showGroup and not (@tags and ($allGroup or $csv))and ($sortOpt or not defined$sortOpt)){$mt->Options(Sort=>"Group$showGroup")}if ($textOut){CleanFilename($textOut);$textOut=".$textOut" unless$textOut =~ /[.%]/ or defined$tagOut}if ($outOpt){my$type=GetFileType($outOpt);if ($type){my$canWrite=CanWrite($outOpt);unless ($canWrite){if (defined$canWrite and $canWrite eq ''){$type=Image::ExifTool::GetFileExtension($outOpt);$type=uc($outOpt)unless defined$type}Error "Can't write $type files\\n";next}$scanWritable=$type unless CanCreate($type)}else {$scanWritable=1}$isWriting=1}elsif ($isWriting or defined$deleteOrig){$scanWritable=1}$altEnc=$mt->Options('Charset');undef$altEnc if$altEnc eq 'UTF8';if (not $altEnc and $mt->Options('Lang')ne 'en'){$fixLen=eval {require Unicode::GCString}? 2 : 1}if (@fileOrder){my@allFiles;ProcessFiles($mt,\\@allFiles);my$sortTool=Image::ExifTool->new;$sortTool->Options(FastScan=>$fileOrderFast)if$fileOrderFast;$sortTool->Options(PrintConv=>$mt->Options('PrintConv'));$sortTool->Options(Duplicates=>0);my (%sortBy,%isFloat,@rev,$file);push@rev,(s/^-// ? 1 : 0)foreach@fileOrder;for$file (@allFiles){my@tags;my$info=$sortTool->ImageInfo(Infile($file,1),@fileOrder,\\@tags);for (@tags){$_=$$info{$_};defined $_ or $_='~',next;$isFloat{$_}=Image::ExifTool::IsFloat($_);s/(\\d+)/(length($1) < 12 ? '0'x(12-length($1)) : '') . $1/eg unless$isFloat{$_}}$sortBy{$file}=\\@tags}@files=sort {my ($i,$cmp);for ($i=0;$i<@rev;++$i){my$u=$sortBy{$a}[$i];my$v=$sortBy{$b}[$i];if (not $isFloat{$u}and not $isFloat{$v}){$cmp=$u cmp $v}elsif ($isFloat{$u}and $isFloat{$v}){$cmp=$u <=> $v}else {$cmp=$isFloat{$u}? -1 : 1}return$rev[$i]? -$cmp : $cmp if$cmp}return$a cmp $b}@allFiles}elsif (defined$progress){my@allFiles;ProcessFiles($mt,\\@allFiles);@files=@allFiles}$progressMax=scalar@files if defined$progress;my@dbKeys=keys%database;if (@dbKeys){if (eval {require Cwd}){undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};for (@dbKeys){my$db=$database{$_};tr/\\\\/\\// and $database{$_}=$db;$database{lc}=$db unless$database{lc};my$absPath=AbsPath($_);if (defined$absPath){$database{$absPath}=$db unless$database{$absPath};if ($verbose and $verbose > 1){print$vout "Imported entry for '\${_}' (full path: '\${absPath}')\\n"}$database{lc$absPath}=$db unless$database{lc$absPath}}elsif ($verbose and $verbose > 1){print$vout "Imported entry for '\${_}' (no full path)\\n"}}}}ProcessFiles($mt);Error "No file with specified extension\\n" if$filtered and not $validFile;if ($textOut){for (keys%outTrailer){next unless$outTrailer{$_};if ($mt->Open(\\*OUTTRAIL,$_,'>>')){my$fp=\\*OUTTRAIL;print$fp $outTrailer{$_};close$fp}else {Error("Error appending to $_\\n")}}}else {print$sectTrailer if$sectTrailer;print$fileTrailer if$fileTrailer and not $fileHeader;my ($fp,$err);if ($textOut2){if ($mt->Open(\\*OUTFILE,$textOut2,'>')){$fp=\\*OUTFILE}else {Error("Error creating $textOut2\\n");$err=1}}unless ($err){PrintCSV($fp)if$csv and not $isWriting;if ($plot){$plot->Draw($fp || \\*STDOUT);if ($$plot{Error}){Error("Error: $$plot{Error}\\n");$err=1}elsif ($$plot{Warn}){Warn("Warning: $$plot{Warn}\\n")}}}if ($fp){close($fp)or $err=1;if ($err){$mt->Unlink($textOut2)}else {$created{$textOut2}=1}}}my$totWr=$countGoodWr + $countBadWr + $countSameWr + $countCopyWr + $countGoodCr + $countBadCr;if (defined$deleteOrig){unless ($quiet){printf "%5d directories scanned\\n",$countDir if$countDir;printf "%5d directories created\\n",$countNewDir if$countNewDir;printf "%5d files failed condition\\n",$countFailed if$countFailed;printf "%5d image files found\\n",$count}if (@delFiles){if ($deleteOrig==1){printf '%5d originals will be deleted!  Are you sure [y/n]? ',scalar(@delFiles);my$response=<STDIN>;unless ($response =~ /^(y|yes)\\s*$/i){Warn "Originals not deleted.\\n";next}}$countGoodWr=$mt->Unlink(@delFiles);$countBad=scalar(@delFiles)- $countGoodWr}if ($quiet){}elsif ($count and not $countGoodWr and not $countBad){printf "%5d original files found\\n",$countGoodWr}elsif ($deleteOrig){printf "%5d original files deleted\\n",$countGoodWr if$count;printf "%5d originals not deleted due to errors\\n",$countBad if$countBad}else {printf "%5d image files restored from original\\n",$countGoodWr if$count;printf "%5d files not restored due to errors\\n",$countBad if$countBad}}elsif ((not $binaryStdout or $verbose)and not $quiet){my$tot=$count + $countBad;if ($countDir or $totWr or $countFailed or $tot > 1 or $textOut or %countLink){my$o=(($html or $json or $xml or %printFmt or $csv or $plot)and not $textOut)? \\*STDERR : $vout;printf($o "%5d directories scanned\\n",$countDir)if$countDir;printf($o "%5d directories created\\n",$countNewDir)if$countNewDir;printf($o "%5d files failed condition\\n",$countFailed)if$countFailed;printf($o "%5d image files created\\n",$countGoodCr)if$countGoodCr;printf($o "%5d image files updated\\n",$countGoodWr)if$totWr - $countGoodCr - $countBadCr - $countCopyWr;printf($o "%5d image files unchanged\\n",$countSameWr)if$countSameWr;printf($o "%5d image files %s\\n",$countCopyWr,$overwriteOrig ? 'moved' : 'copied')if$countCopyWr;printf($o "%5d files weren't updated due to errors\\n",$countBadWr)if$countBadWr;printf($o "%5d files weren't created due to errors\\n",$countBadCr)if$countBadCr;printf($o "%5d image files read\\n",$count)if ($tot+$countFailed)>1 or ($countDir and not $totWr);printf($o "%5d files could not be read\\n",$countBad)if$countBad;printf($o "%5d output files created\\n",scalar(keys%created))if$textOut or $textOut2;printf($o "%5d output files appended\\n",scalar(keys%appended))if%appended;printf($o "%5d hard links created\\n",$countLink{Hard}|| 0)if$countLink{Hard}or $countLink{BadHard};printf($o "%5d hard links could not be created\\n",$countLink{BadHard})if$countLink{BadHard};printf($o "%5d symbolic links created\\n",$countLink{Sym}|| 0)if$countLink{Sym}or $countLink{BadSym};printf($o "%5d symbolic links could not be created\\n",$countLink{BadSym})if$countLink{BadSym}}}if ($countBadWr or $countBadCr or $countBad){$rtnVal=1}elsif ($countFailed and not ($count or $totWr)and not $rtnVal){$rtnVal=2}Cleanup();}close STAYOPEN if$stayOpen >= 2;Exit$rtnValApp;sub GetImageInfo($$) {my ($et,$orig)=@_;my (@foundTags,@found2,$info,$info2,$et2,$file,$file2,$ind,$g8);if (defined$windowTitle){if ($progressCount >= $progressNext){my$prog=$progressMax ? "$progressCount/$progressMax" : '0/0';my$title=$windowTitle;my ($num,$denom)=split '/',$prog;my$frac=$num / ($denom || 1);my$n=$title =~ s/%(\\d+)b/%b/ ? $1 : 20;my$bar=int($frac * $n + 0.5);my%lkup=(b=>('I' x $bar).('.' x ($n - $bar)),f=>$orig,p=>int(100 * $frac + 0.5),r=>$prog,'%'=>'%',);$title =~ s/%([%bfpr])/$lkup{$1}/eg;SetWindowTitle($title);if (defined$progressMax){undef$progressNext}else {$progressNext += $progressIncr}}++$progressCount unless defined$progressMax}unless (length$orig or $outOpt){Warn qq(Error: Zero-length file name - ""\\n);++$countBad;return}if (@srcFmt){my ($fmt,$first);for$fmt (@srcFmt){$file=$fmt eq '@' ? $orig : FilenameSPrintf($fmt,$orig);$et->Exists($file)and undef($first),last;$verbose and print$vout "Source file $file does not exist\\n";$first=$file unless defined$first}$file=$first if defined$first;my ($d,$f)=Image::ExifTool::SplitFileName($orig);$et->Options(UserParam=>"OriginalDirectory#=$d");$et->Options(UserParam=>"OriginalFileName#=$f")}else {$file=$orig}for$g8 (sort keys%altFile){my$altName=$orig;unless ($altFile{$g8}eq '@'){$altName =~ s/\\$/\\$\\$/g;$altName=FilenameSPrintf($altFile{$g8},$altName)}$et->SetAlternateFile($g8,$altName)}my$pipe=$file;if ($doUnzip){if ($file =~ /\\.(gz|bz2)$/i){my$type=lc $1;if ($file =~ /[^-_.'A-Za-z0-9\\/\\\\]/){Warn "Error: Insecure zip file name. Skipped\\n";EFile($file);++$countBad;return}if ($type eq 'gz'){$pipe=qq{gzip -dc "$file" |}}else {$pipe=qq{bzip2 -dc "$file" |}}$$et{TRUST_PIPE}=1}}if (@condition){my$result;unless ($failCondition){undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my (%info,$condition);my$opts={Duplicates=>1,RequestTags=>\\@requestTags,Verbose=>0,HtmlDump=>0 };$$opts{FastScan}=$fastCondition if defined$fastCondition;@foundTags=('*',@tags)if@tags;$info=$et->ImageInfo(Infile($pipe,$isWriting),\\@foundTags,$opts);for$condition (@condition){my$cond=$et->InsertTagValues($condition,\\@foundTags,\\%info);{package Image::ExifTool;my$self=$et;$result=eval$cond;$@ and $evalWarning=$@}if ($evalWarning){undef$result;if ($verbose){chomp$evalWarning;$evalWarning =~ s/ at \\(eval .*//s;Warn "Condition: $evalWarning - $file\\n"}}last unless$result}undef@foundTags if$fastCondition}if ($result){undef$info unless$file eq '-' or $et->Exists($file)}else {Progress($vout,"-------- $file (failed condition)")if$verbose;EFile($file,2);++$countFailed;return}if ($isWriting or $verbose or defined$fastCondition or defined$diff){undef$info;--$$et{FILE_SEQUENCE}}}elsif ($file =~ s/^(\\@JSON:)(.*)/$1/){my$dat=$2;$info=$et->ImageInfo(\\$dat,\\@foundTags);if ($geoOnly){/^Geolocation/ or delete $$info{$_}foreach keys %$info;$file=' '}}if (defined$deleteOrig){Progress($vout,"======== $file")if defined$verbose;++$count;my$original="\${file}_original";$et->Exists($original)or return;if ($deleteOrig){$verbose and print$vout "Scheduled for deletion: $original\\n";push@delFiles,$original}elsif ($et->Rename($original,$file)){$verbose and print$vout "Restored from $original\\n";EFile($file,3);++$countGoodWr}else {Warn "Error renaming $original\\n";EFile($file);++$countBad}return}++$seqFileNum;my ($dir)=Image::ExifTool::SplitFileName($orig);$seqFileDir=$seqFileDir{$dir}=($seqFileDir{$dir}|| 0)+ 1;my$lineCount=0;my ($fp,$outfile,$append);if ($textOut and ($verbose or $et->Options('PrintCSV'))and not ($tagOut or defined$diff or $plot)){($fp,$outfile,$append)=OpenOutputFile($orig);$fp or EFile($file),++$countBad,return;$tmpText=$outfile unless$append;$et->Options(TextOut=>$fp)}if ($isWriting){Progress($vout,"======== $file")if defined$verbose;SetImageInfo($et,$file,$orig);$info=$et->GetInfo('Warning','Error');PrintErrors($et,$info,$file);if (defined$outfile){undef$tmpText;close($fp);$et->Options(TextOut=>$vout);if ($info->{Error}){$et->Unlink($outfile)}elsif ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}}return}unless ($file eq '-' or $et->Exists($file)or $info){Warn "Error: File not found - $file\\n";FileNotFound($file);defined$outfile and close($fp),undef($tmpText),$et->Unlink($outfile);EFile($file);++$countBad;return}my$o;unless ($binaryOutput or $textOut or %printFmt or $html > 1 or $csv or $plot){if ($html){require Image::ExifTool::HTML;my$f=Image::ExifTool::HTML::EscapeHTML($file);print "<!-- $f -->\\n"}elsif (not ($json or $xml or defined$diff)){$o=\\*STDOUT if ($multiFile and not $quiet)or $progress}}$o=\\*STDERR if$progress and not $o;Progress($o,"======== $file")if$o;if ($info){if (@tags and not %printFmt){@foundTags=@tags;$info=$et->GetInfo(\\@foundTags)}}else {my$oldDups=$et->Options('Duplicates');if (%printFmt){$et->Options(Duplicates=>1);$et->Options(RequestTags=>\\@requestTags);if ($printFmt{SetTags}){$$et{TAGS_FROM_FILE}=1;$et->Options(MakerNotes=>1);$et->Options(Struct=>2);$et->Options(List=>1);$et->Options(CoordFormat=>'%d %d %.8f')unless$et->Options('CoordFormat')}}else {@foundTags=@tags}if (defined$diff){$file2=FilenameSPrintf($diff,$orig);if ($file eq $file2){Warn "Error: Diffing file with itself - $file2\\n";EFile($file);++$countBad;return}if ($et->Exists($file2)){$showGroup=1 unless defined$showGroup;$allGroup=1 unless defined$allGroup;$et->Options(Duplicates=>1,Sort=>"Group$showGroup",Verbose=>0);$et2=Image::ExifTool->new;$et2->Options(%{$$et{OPTIONS}});$et2->Options(ListSep=>$$et{OPTIONS}{ListSep});$et2->Options(ListSplit=>$$et{OPTIONS}{ListSplit});@found2=@foundTags;$info2=$et2->ImageInfo($file2,\\@found2)}else {$info2={Error=>"Diff file not found" }}if ($$info2{Error}){Warn "Error: $$info2{Error} - $file2\\n";EFile($file);++$countBad;return}}$info=$et->ImageInfo(Infile($pipe),\\@foundTags);$et->Options(Duplicates=>$oldDups)}if ($fp){if (defined$outfile){$et->Options(TextOut=>\\*STDOUT);undef$tmpText;if ($info->{Error}){close($fp);$et->Unlink($outfile)}else {++$lineCount}}if ($info->{Error}){Warn "Error: $$info{Error} - $file\\n";EFile($file);++$countBad;return}}if ($binaryOutput or not %$info){my$errs=$et->GetInfo('Warning','Error');PrintErrors($et,$errs,$file)and EFile($file),$rtnVal=1}elsif ($et->GetValue('Error')or ($$et{Validate}and $et->GetValue('Warning'))){$rtnVal=1}unless (defined$outfile or $tagOut){($fp,$outfile,$append)=OpenOutputFile($orig);$fp or EFile($file),++$countBad,return;$tmpText=$outfile if defined$outfile and not $append}if (defined$diff){my (%done,%done2,$wasDiff,@diffs,@groupTags2);my$v=$verbose || 0;print$fp "======== diff < $file > $file2\\n";my ($g2,$same)=(0,0);for (;;){my ($g,$tag2,$i,$key,@dupl,$val2,$t2,$equal,%used);my$tag=shift@foundTags;if (defined$tag){$done{$tag}=1;$g=$et->GetGroup($tag,$showGroup)}else {for (;;){$tag2=shift@found2;defined$tag2 or $g='',last;$done2{$tag2}or $g=$et2->GetGroup($tag2,$showGroup),last}}if ($g ne $g2){for$t2 (@groupTags2){next if$done2{$t2};my$val2=$et2->GetValue($t2);next unless defined$val2;my$name=$outFormat < 1 ? $et2->GetDescription($t2): GetTagName($t2);my$len=LengthUTF8($name);my$pad=$outFormat < 2 ? ' ' x ($len < 32 ? 32 - $len : 0): '';if ($allGroup){my$grp="[$g2]";$grp .= ' ' x (15 - length($grp))if length($grp)< 15 and $outFormat < 2;push@diffs,sprintf "> %s %s%s: %s\\n",$grp,$name,$pad,Printable($val2)}else {push@diffs,sprintf "> %s%s: %s\\n",$name,$pad,Printable($val2)}$done2{$t2}=1}my$str='';$v and ($same or $v > 1)and $str="  ($same same tag" .($same==1 ? '' : 's').')';if (not $allGroup){print$fp "---- $g2 ----$str\\n" if$g2 and ($str or @diffs)}elsif ($str and $g2){printf$fp "   %-13s%s\\n",$g2,$str}@diffs and print($fp @diffs),$wasDiff=1,@diffs=();last unless$g;($g2,$same)=($g,0);@groupTags2=();push@groupTags2,$tag2 if defined$tag2;for$t2 (@found2){$done2{$t2}or $g ne $et2->GetGroup($t2,$showGroup)or push@groupTags2,$t2}}next unless defined$tag;my$val=$et->GetValue($tag);next unless defined$val;my$name=GetTagName($tag);my$desc=$outFormat < 1 ? $et->GetDescription($tag): $name;my@tags2=grep /^$name( |$)/,@groupTags2;T2: foreach$t2 (@tags2){next if$done2{$t2};$tag2=$t2;$val2=$et2->GetValue($t2);next unless defined$val2;IsEqual($val,$val2)and $equal=1,last;if ($$et{DUPL_TAG}{$name}and not @dupl){for ($i=0,$key=$name;$i<=$$et{DUPL_TAG}{$name};++$i,$key="$name ($i)"){push@dupl,$key unless$done{$key}or $g ne $et->GetGroup($key,$showGroup)}@dupl=sort {$$et{FILE_ORDER}{$a}<=> $$et{FILE_ORDER}{$b}}@dupl if@dupl > 1}for (@dupl){next if$used{$_};my$v=$et->GetValue($_);next unless defined($v)and IsEqual($v,$val2);$used{$_}=1;undef($tag2);undef($val2);next T2}last}if ($equal){++$same}else {my$len=LengthUTF8($desc);my$pad=$outFormat < 2 ? ' ' x ($len < 32 ? 32 - $len : 0): '';if ($allGroup){my$grp="[$g]";$grp .= ' ' x (15 - length($grp))if length($grp)< 15 and $outFormat < 2;push@diffs,sprintf "< %s %s%s: %s\\n",$grp,$desc,$pad,Printable($val);if (defined$val2){$grp=' ' x length($grp),$desc=' ' x $len if$v < 3;push@diffs,sprintf "> %s %s%s: %s\\n",$grp,$desc,$pad,Printable($val2)}}else {push@diffs,sprintf "< %s%s: %s\\n",$desc,$pad,Printable($val);$desc=' ' x $len if$v < 3;push@diffs,sprintf "> %s%s: %s\\n",$desc,$pad,Printable($val2)if defined$val2}}$done2{$tag2}=1 if defined$tag2}print$fp "(no metadata differences)\\n" unless$wasDiff;if (defined$outfile){$created{$outfile}=1;close($fp);undef$tmpText}++$count;return}$comma=$outComma{$outfile}if$append and ($textOverwrite & 0x02);if (%printFmt){my ($type,@doc,$grp,$lastDoc,$cache);$fileTrailer='';if ($et->Options('ExtractEmbedded')){$lastDoc=$$et{DOC_COUNT}and $cache={}}else {$lastDoc=0}for ($doc[0]=0;$doc[0]<=$lastDoc;){my$doc=join '-',@doc;my ($skipBody,$opt);for$type (qw(HEAD SECT IF BODY ENDS TAIL)){my$prf=$printFmt{$type}or next;if ($type eq 'HEAD' and defined$outfile){next if$wroteHEAD{$outfile};$wroteHEAD{$outfile}=1}next if$type eq 'BODY' and $skipBody;if ($type eq 'IF' or (($doc[0]> 1 or @doc > 1)and not $$et{OPTIONS}{IgnoreMinorErrors})){$opt='Silent'}else {$opt='Warn'}if ($lastDoc){if ($doc){next if$type eq 'HEAD' or $type eq 'TAIL';$grp="Doc$doc"}else {$grp='Main'}}my@lines;for (@$prf){my$line=$et->InsertTagValues($_,\\@foundTags,$opt,$grp,$cache);if ($type eq 'IF'){$skipBody=1 unless defined$line}elsif (defined$line){push@lines,$line}}$lineCount += scalar@lines;if ($type eq 'SECT'){my$thisHeader=join '',@lines;if ($sectHeader and $sectHeader ne $thisHeader){print$fp $sectTrailer if$sectTrailer;undef$sectHeader}$sectTrailer='';print$fp $sectHeader=$thisHeader unless$sectHeader}elsif ($type eq 'ENDS'){$sectTrailer .= join '',@lines if defined$sectHeader}elsif ($type eq 'TAIL'){$fileTrailer .= join '',@lines}elsif (@lines){print$fp @lines}}push@doc,1;while (@doc > 1){my$nextDoc=join '-',@doc;last if $$et{HAS_DOC}{$nextDoc};pop@doc;++$doc[-1]}}delete$printFmt{HEAD}unless defined$outfile;my$errs=$et->GetInfo('Warning','Error');PrintErrors($et,$errs,$file)and EFile($file)}elsif ($plot){my$tagExtra=$$et{TAG_EXTRA};my ($tag,%docNum);for$tag (keys %$info){next unless $$tagExtra{$tag}and $$tagExtra{$tag}{G3};$docNum{$tag}=$1 if $$tagExtra{$tag}{G3}=~ /(\\d+)/}$$plot{DocNum}=\\%docNum;$$plot{EE}=1 if$et->Options('ExtractEmbedded');$plot->AddPoints($info,\\@foundTags)}elsif (not $disableOutput){my ($tag,$line,%noDups,%csvInfo,$bra,$ket,$sep,$quote);if ($fp){if ($fileHeader){print$fp $fileHeader unless defined$outfile and ($created{$outfile}or $appended{$outfile});undef$fileHeader unless$textOut}if ($html){print$fp "<table>\\n"}elsif ($xml){my$f=$file;CleanXML(\\$f);print$fp "\\n<rdf:Description rdf:about='\${f}'";print$fp "\\n  xmlns:et='http://ns.exiftool.org/1.0/'";print$fp " et:toolkit='Image::ExifTool $Image::ExifTool::VERSION'";my (%groups,@groups,$grp0,$grp1);for$tag (@foundTags){($grp0,$grp1)=$et->GetGroup($tag);unless ($grp1){next unless defined$forcePrint;$grp0=$grp1='Unknown'}AddGroups($$info{$tag},$grp0,\\%groups,\\@groups)if ref $$info{$tag};next if$groups{$grp1};$groups{$grp1}=$grp0;push@groups,$grp1}for$grp1 (@groups){my$grp=$groups{$grp1};unless ($grp eq $grp1 and $grp =~ /^(ExifTool|File|Composite|Unknown)$/){$grp .= "/$grp1"}print$fp "\\n  xmlns:$grp1='http://ns.exiftool.org/$grp/1.0/'"}print$fp '>' if$outFormat < 1;$ind=$outFormat >= 0 ? ' ' : '   '}elsif ($json){($bra,$ket,$sep)=$json==1 ? ('{','}',':'): ('Array(',')',' =>');$quote=1 if $$et{OPTIONS}{StructFormat}and $$et{OPTIONS}{StructFormat}eq 'JSONQ';print$fp ",\\n" if$comma;print$fp qq($bra\\n  "SourceFile"$sep ),EscapeJSON(MyConvertFileName($et,$file),1);$comma=1;$ind=(defined$showGroup and not $allGroup)? '    ' : '  '}elsif ($csv){my$file2=MyConvertFileName($et,$file);$database{$file2}=\\%csvInfo;push@csvFiles,$file2}}my$noDups=($json or ($xml and $outFormat > 0));my$printConv=$et->Options('PrintConv');my$lastGroup='';my$i=-1;TAG: foreach$tag (@foundTags){++$i;my$tagName=GetTagName($tag);my ($group,$valList);my$val=$$info{$tag};$isBinary=(ref$val eq 'SCALAR' and defined$binaryOutput);if (ref$val){if (defined$binaryOutput and not $binaryOutput and $$et{TAG_INFO}{$tag}{Protected}){my$lcTag=lc$tag;$lcTag =~ s/ .*//;next unless $$et{REQ_TAG_LOOKUP}{$lcTag}or ($$et{OPTIONS}{RequestAll}|| 0)> 2}$val=ConvertBinary($val);next unless defined$val;if ($structOpt and ref$val){$val=Image::ExifTool::XMP::SerializeStruct($et,$val)unless$xml or $json}elsif (ref$val eq 'ARRAY'){if (defined$listItem){$val=$$val[$listItem]}elsif ($binaryOutput){if ($tagOut){$valList=$val;$val=shift @$valList}else {$val=join defined$binSep ? $binSep : "\\n",@$val}}elsif ($joinLists){$val=join$listSep,@$val}}}if (not defined$val){next if$binaryOutput;if (defined$forcePrint){$val=$forcePrint}elsif (not $csv){next}}if (defined$showGroup){$group=$et->GetGroup($tag,$showGroup);next if$noDups and $tag =~ /^(.*?) ?\\(/ and defined $$info{$1}and $group eq $et->GetGroup($1,$showGroup);if (not $group and ($xml or $json or $csv)){if ($showGroup !~ /\\b4\\b/){$group='Unknown'}elsif ($json and not $allGroup){$group='Copy0'}}if ($fp and not ($allGroup or $csv)){if ($lastGroup ne $group){if ($html){my$cols=1;++$cols if$outFormat==0 or $outFormat==1;++$cols if$showTagID;print$fp "<tr><td colspan=$cols bgcolor='#dddddd'>$group</td></tr>\\n"}elsif ($json){print$fp "\\n  $ket" if$lastGroup;print$fp ',' if$lastGroup or $comma;print$fp qq(\\n  "$group"$sep $bra);undef$comma;undef%noDups}else {print$fp "---- $group ----\\n"}$lastGroup=$group}undef$group}}elsif ($noDups){next if$tag =~ /^(.*?) ?\\(/ and defined $$info{$1}}++$lineCount;for (;;){if ($tagOut){my$ext=SuggestedExtension($et,\\$val,$tagName);if (%wext and ($wext{$ext}|| $wext{'*'}|| -1)< 0){if ($verbose and $verbose > 1){print$vout "Not writing $ext output file for $tagName\\n"}next TAG}my@groups=$et->GetGroup($tag);defined$outfile and close($fp),undef($tmpText);my$org=$et->GetValue('OriginalRawFileName')|| $et->GetValue('OriginalFileName');($fp,$outfile,$append)=OpenOutputFile($orig,$tagName,\\@groups,$ext,$org);$fp or ++$countBad,next TAG;$tmpText=$outfile unless$append}if ($binaryOutput){print$fp $val;print$fp $binTerm if defined$binTerm;if ($tagOut){if ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}close($fp);undef$tmpText;$verbose and print$vout "Wrote $tagName to $outfile\\n";undef$outfile;undef$fp;next TAG unless$valList and @$valList;$val=shift @$valList;next}next TAG}last}if ($csv){my$tn=$tagName;$tn .= '#' if$tag =~ /#/;my$gt=$group ? "$group:$tn" : $tn;my$lcTag=lc$gt;next if defined$csvInfo{$lcTag}and $tag =~ /\\(/;$csvInfo{$lcTag}=$val;if (defined$csvTags{$lcTag}){$csvTags{$lcTag}=$gt if defined $$info{$tag};next}if ($group and defined$csvTags[$i]and $csvTags[$i]=~ /^(.*):$tn$/i){next if$group eq 'Unknown';if ($1 eq 'unknown'){delete$csvTags{$csvTags[$i]};$csvTags{$lcTag}=defined($val)? $gt : '';$csvTags[$i]=$lcTag;next}}$csvTags{$lcTag}=defined($val)? $gt : '';if (@csvFiles==1){push@csvTags,$lcTag}elsif (@csvTags){undef@csvTags}next}my$desc=$outFormat > 0 ? $tagName : $et->GetDescription($tag);if ($xml){my$tok="$group:$tagName";if ($outFormat > 0){if ($structOpt and ref$val){$val=Image::ExifTool::XMP::SerializeStruct($et,$val)}if ($escapeHTML){$val =~ tr/\\0-\\x08\\x0b\\x0c\\x0e-\\x1f/./;Image::ExifTool::XMP::FixUTF8(\\$val)unless$altEnc;$val=Image::ExifTool::HTML::EscapeHTML($val,$altEnc)}else {CleanXML(\\$val)}unless ($noDups{$tok}){$isCRLF and $val =~ s/\\x0d\\x0a/\\x0a/g;print$fp "\\n $tok='\${val}'";$noDups{$tok}=1}next}my ($xtra,$valNum,$descClose);if ($showTagID){my ($id,$lang)=$et->GetTagID($tag);if ($id =~ /^\\d+$/){$id=sprintf("0x%.4x",$id)if$showTagID eq 'H'}else {$id=Image::ExifTool::XMP::FullEscapeXML($id)}$xtra=" et:id='\${id}'";$xtra .= " xml:lang='\${lang}'" if$lang}else {$xtra=''}if ($tabFormat){my$table=$et->GetTableName($tag);my$index=$et->GetTagIndex($tag);$xtra .= " et:table='\${table}'";$xtra .= " et:index='\${index}'" if defined$index}my$lastVal=$val;for ($valNum=0;$valNum<2;++$valNum){$val=FormatXML($val,$ind,$group);$isCRLF and $val =~ s/\\x0d\\x0a/\\x0a/g;if ($outFormat >= 0){print$fp "\\n <$tok$xtra$val</$tok>";last}elsif ($valNum==0){CleanXML(\\$desc);if ($xtra){print$fp "\\n <$tok>";print$fp "\\n  <rdf:Description$xtra>";$descClose="\\n  </rdf:Description>"}else {print$fp "\\n <$tok rdf:parseType='Resource'>";$descClose=''}print$fp "\\n   <et:desc>$desc</et:desc>";if ($printConv){print$fp "\\n   <et:prt$val</et:prt>";$val=$et->GetValue($tag,'ValueConv');$val='' unless defined$val;next unless IsEqual($val,$lastVal,1);print$fp "$descClose\\n </$tok>";last}}print$fp "\\n   <et:val$val</et:val>";print$fp "$descClose\\n </$tok>";last}next}elsif ($json){my$tok=$allGroup ? "$group:$tagName" : $tagName;next if$noDups{$tok};$noDups{$tok}=1;print$fp ',' if$comma;print$fp qq(\\n$ind"$tok"$sep );if ($showTagID or $outFormat < 0){$val={val=>$val };if ($showTagID){my ($id,$lang)=$et->GetTagID($tag);$id=sprintf('0x%.4x',$id)if$showTagID eq 'H' and $id =~ /^\\d+$/;$$val{lang}=$lang if$lang;$$val{id}=$id}if ($tabFormat){$$val{table}=$et->GetTableName($tag);my$index=$et->GetTagIndex($tag);$$val{index}=$index if defined$index}if ($outFormat < 0){$$val{desc}=$desc;if ($printConv){my$num=$et->GetValue($tag,'ValueConv');$$val{num}=$num if defined$num and not IsEqual($num,$$val{val},1)}my$ex=$$et{TAG_EXTRA}{$tag};$$val{'fmt'}=$$ex{G6}if defined $$ex{G6};if (defined $$ex{BinVal}){my$max=($$et{OPTIONS}{LimitLongValues}- 5)/ 3;if ($max >= 0 and length($$ex{BinVal})> int($max)){$max=int$max;$$val{'hex'}=join ' ',unpack("(H2)$max",$$ex{BinVal}),'[...]'}else {$$val{'hex'}=join ' ',unpack '(H2)*',$$ex{BinVal}}}$$val{rat}=$$ex{Rational}if defined $$ex{Rational}and $$et{OPTIONS}{SaveBin}}}FormatJSON($fp,$val,$ind,$quote);$comma=1;next}my$id;if ($showTagID){$id=$et->GetTagID($tag);if ($id =~ /^(\\d+)(\\.\\d+)?$/){$id=sprintf("0x%.4x",$1)if$showTagID eq 'H'}else {$id='-'}}if ($escapeC){$val =~ s/([\\0-\\x1f\\\\\\x7f])/$escC{$1} || sprintf('\\x%.2x', ord $1)/eg}else {$val =~ tr/\\x01-\\x1f\\x7f/./;$val =~ s/\\x00//g;$val =~ s/\\s+$//}if ($html){print$fp "<tr>";print$fp "<td>$group</td>" if defined$group;print$fp "<td>$id</td>" if$showTagID;print$fp "<td>$desc</td>" if$outFormat <= 1;print$fp "<td>$val</td></tr>\\n"}else {my$buff='';if ($tabFormat){$buff="$group\\t" if defined$group;$buff .= "$id\\t" if$showTagID;if ($outFormat <= 1){$buff .= "$desc\\t$val\\n"}elsif (defined$line){$line .= "\\t$val"}else {$line=$val}}elsif ($outFormat < 0){$buff="[$group] " if defined$group;$buff .= "$id " if$showTagID;$buff .= "$desc\\n      $val\\n"}elsif ($outFormat==0 or $outFormat==1){my$wid;my$len=0;if (defined$group){$buff=sprintf("%-15s ","[$group]");$len=16}if ($showTagID){$wid=($showTagID eq 'D')? 5 : 6;$len += $wid + 1;($wid=$len - length($buff)- 1)< 1 and $wid=1;$buff .= sprintf "%\${wid}s ",$id}$wid=32 - (length($buff)- $len);my$padLen=$wid - LengthUTF8($desc);$padLen=0 if$padLen < 0;$buff .= $desc .(' ' x $padLen).": $val\\n"}elsif ($outFormat==2){$buff="[$group] " if defined$group;$buff .= "$id " if$showTagID;$buff .= "$tagName: $val\\n"}elsif ($argFormat){$buff='-';$buff .= "$group:" if defined$group;$tagName .= '#' if$tag =~ /#/;$buff .= "$tagName=$val\\n"}else {$buff="$group " if defined$group;$buff .= "$id " if$showTagID;$buff .= "$val\\n"}print$fp $buff}if ($tagOut){if ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}close($fp);undef$tmpText;$verbose and print$vout "Wrote $tagName to $outfile\\n";undef$outfile;undef$fp}}if ($fp){if ($html){print$fp "</table>\\n"}elsif ($xml){print$fp $outFormat < 1 ? "\\n</rdf:Description>\\n" : "/>\\n"}elsif ($json){print$fp "\\n  $ket" if$lastGroup;print$fp "\\n$ket";$comma=1}elsif ($tabFormat and $outFormat > 1){print$fp "$line\\n" if defined$line}}}if (defined$outfile){if ($textOverwrite & 0x02){$outComma{$outfile}=$comma;$outTrailer{$outfile}='';$outTrailer{$outfile}.= $sectTrailer and $sectTrailer='' if$sectTrailer;$outTrailer{$outfile}.= $fileTrailer if$fileTrailer}else {print$fp $sectTrailer and $sectTrailer='' if$sectTrailer;print$fp $fileTrailer if$fileTrailer}close($fp);undef$tmpText;if ($lineCount){if ($append){$appended{$outfile}=1 unless$created{$outfile}}else {$created{$outfile}=1}}else {$et->Unlink($outfile)unless$append}undef$comma}++$count}sub SetImageInfo($$$) {my ($et,$file,$orig)=@_;my ($outfile,$restored,$isTemporary,$isStdout,$outType,$tagsFromSrc);my ($hardLink,$symLink,$testName,$sameFile);my$infile=$file;if (defined$tmpFile){$et->Unlink($tmpFile);undef$tmpFile}delete $$et{VALUE}{Error};delete $$et{VALUE}{Warning};if (defined$outOpt){if ($outOpt =~ /^-(\\.\\w+)?$/){$outType=GetFileType($outOpt)if $1;$outfile='-';$isStdout=1}else {$outfile=FilenameSPrintf($outOpt,$orig);if ($outfile eq ''){Warn "Error: Can't create file with zero-length name from $orig\\n";EFile($infile);++$countBadCr;return 0}}if (not $isStdout and (($et->IsDirectory($outfile)and not $listDir)or $outfile =~ /\\/$/)){$outfile .= '/' unless$outfile =~ /\\/$/;my$name=$file;$name =~ s/^.*\\///s;$outfile .= $name}else {my$srcType=GetFileType($file)|| '';$outType or $outType=GetFileType($outfile);if ($outType and ($srcType ne $outType or $outType eq 'ICC')and $file ne '-'){unless (CanCreate($outType)){my$what=$srcType ? 'other types' : 'scratch';WarnOnce "Error: Can't create $outType files from $what\\n";EFile($infile);++$countBadCr;return 0}if ($file ne ''){$et->RestoreNewValues()unless$restored;$restored=1;my@setTags=@tags;for (@exclude){push@setTags,"-$_"}my%forceCopy=(ICC=>'ICC_Profile',VRD=>'CanonVRD',DR4=>'CanonDR4',);push@setTags,$forceCopy{$outType}if$forceCopy{$outType};if (not %setTags or (@setTags and not $setTags{'@'})){return 0 unless DoSetFromFile($et,$file,\\@setTags)}elsif (@setTags){push@setTags,@{$setTags{'@'}};$tagsFromSrc=\\@setTags}$file=''}}}unless ($isStdout){$outfile=NextUnusedFilename($outfile);if ($et->Exists($outfile,1)and not $doSetFileName){Warn "Error: '\${outfile}' already exists - $infile\\n";EFile($infile);++$countBadWr;return 0}}}elsif ($file eq '-'){$isStdout=1}if (@dynamicFiles){$et->RestoreNewValues()unless$restored;my ($dyFile,%setTagsIndex);for$dyFile (@dynamicFiles){if (not ref$dyFile){my ($fromFile,$setTags);if ($dyFile eq '@'){$fromFile=$orig;$setTags=$tagsFromSrc || $setTags{$dyFile}}else {$fromFile=FilenameSPrintf($dyFile,$orig);defined$fromFile or EFile($infile),++$countBadWr,return 0;$setTags=$setTags{$dyFile}}if ($setTagsList{$dyFile}){my$i=$setTagsIndex{$dyFile}|| 0;$setTagsIndex{$dyFile}=$i + 1;$setTags=$setTagsList{$dyFile}[$i]if$setTagsList{$dyFile}[$i]}return 0 unless DoSetFromFile($et,$fromFile,$setTags)}elsif (ref$dyFile eq 'ARRAY'){my$fname=FilenameSPrintf($$dyFile[1],$orig);my ($buff,$rtn,$wrn);my$opts=$$dyFile[2];if (defined$fname and SlurpFile($fname,\\$buff)){$verbose and print$vout "Reading $$dyFile[0] from $fname\\n";($rtn,$wrn)=$et->SetNewValue($$dyFile[0],$buff,%$opts);$wrn and Warn "$wrn\\n"}$rtn or $et->SetNewValue($$dyFile[0],undef,Replace=>2,ProtectSaved=>$$opts{ProtectSaved});next}elsif (ref$dyFile eq 'SCALAR'){my ($f,$found,$csvTag,$tg,$csvEtPrt,$csvEtVal);undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my$old=$et->Options('Charset');$et->Options(Charset=>'UTF8')if$csv eq 'JSON';for$f ('*',MyConvertFileName($et,$file)){my$csvInfo=$database{$f};unless ($csvInfo){next if$f eq '*';my$absPath=AbsPath($f);if (defined$absPath and $database{$absPath}){$csvInfo=$database{$absPath}}elsif ($database{lc$f}){$csvInfo=$database{lc$f}}elsif (defined$absPath and $database{lc$absPath}){$csvInfo=$database{lc$absPath}}else {next}}$found=1;if ($verbose){print$vout "Setting new values from $csv database\\n";print$vout 'Including tags: ',join(' ',@tags),"\\n" if@tags;print$vout 'Excluding tags: ',join(' ',@csvExclude),"\\n" if@csvExclude}if (@tags){$csvEtPrt=Image::ExifTool->new unless$csvEtPrt;for$csvTag (OrderedKeys($csvInfo)){next if$csvTag =~ /^([-_0-9A-Z]+:)*(SourceFile|Directory|FileName)$/i;my@grps=split /:/,$csvTag;my$name=pop@grps;unshift@grps,'All' while@grps < 2;if ($name =~ s/#$//){$csvEtVal=Image::ExifTool->new unless$csvEtVal;$csvEtVal->FoundTag($name,$$csvInfo{$csvTag},@grps)}else {$csvEtPrt->FoundTag($name,$$csvInfo{$csvTag},@grps)}}next}my@exclTags=@csvExclude;for (@exclTags){tr/-0-9a-zA-Z_:#?*//dc;s/(^|:)(all:)+/$1/ig;s/(^|:)all(#?)$/$1*$2/i;tr/?/./;s/\\*/.*/g}for$csvTag (OrderedKeys($csvInfo)){next if$csvTag =~ /^([-_0-9A-Z]+:)*(SourceFile|Directory|FileName)$/i;if (@exclTags){my ($exclTag,$exclGrp,$excluded);ExclMatch: foreach$exclTag (@exclTags){if ($exclTag =~ /:/){next unless$csvTag =~ /:/;my@csvGrps=split /:/,$csvTag;my@exclGrps=split /:/,$exclTag;my$exclName=pop@exclGrps;next unless pop(@csvGrps)=~ /^$exclName$/i;for$exclGrp (@exclGrps){next ExclMatch unless grep /^$exclGrp$/i,@csvGrps}$excluded=1;last}$csvTag =~ /^([-_0-9A-Z]+:)*$exclTag$/i and $excluded=1,last}next if$excluded}my ($rtn,$wrn)=$et->SetNewValue($csvTag,$$csvInfo{$csvTag},Protected=>1,AddValue=>$dbAdd,ProtectSaved=>$dbSaveCount);$wrn and Warn "$wrn\\n" if$verbose}}if ($csvEtPrt){my@excl=map "-$_",@csvExclude;my$opts={AddValue=>$dbAdd,Replace=>0 };$et->SetNewValuesFromFile($csvEtPrt,$opts,@tags,@excl);if ($csvEtVal){$$opts{Type}='ValueConv';$et->SetNewValuesFromFile($csvEtVal,$opts,@tags,@excl)}}$et->Options(Charset=>$old)if$csv eq 'JSON';unless ($found){Warn("No SourceFile '\${file}' in imported $csv database\\n");my$absPath=AbsPath($file);Warn("(full path: '\${absPath}')\\n")if defined$absPath and $absPath ne $file;return 0}}}}if ($isStdout){$outfile=\\*STDOUT;unless ($binaryStdout){binmode(STDOUT);$binaryStdout=1}}else {$hardLink=$et->GetNewValues('HardLink');$symLink=$et->GetNewValues('SymLink');$testName=$et->GetNewValues('TestName');$hardLink=FilenameSPrintf($hardLink,$orig)if defined$hardLink;$symLink=FilenameSPrintf($symLink,$orig)if defined$symLink;my$newFileName=$et->GetNewValues('FileName');my$newDir=$et->GetNewValues('Directory');if (defined$newFileName and not length$newFileName){Warning($et,"New file name is empty - $infile");undef$newFileName}if (defined$testName){my$err;$err="You shouldn't write FileName or Directory with TestFile" if defined$newFileName or defined$newDir;$err="The -o option shouldn't be used with TestFile" if defined$outfile;$err and Warn("Error: $err - $infile\\n"),EFile($infile),++$countBadWr,return 0;$testName=FilenameSPrintf($testName,$orig);$testName=Image::ExifTool::GetNewFileName($file,$testName)if$file ne ''}if (defined$newFileName or defined$newDir or ($doSetFileName and defined$outfile)){if ($newFileName){$newFileName=FilenameSPrintf($newFileName,$orig);if (defined$outfile){$outfile=Image::ExifTool::GetNewFileName($file,$outfile)if$file ne '';$outfile=Image::ExifTool::GetNewFileName($outfile,$newFileName)}elsif ($file ne ''){$outfile=Image::ExifTool::GetNewFileName($file,$newFileName)}}if ($newDir){$newDir=FilenameSPrintf($newDir,$orig);$outfile=Image::ExifTool::GetNewFileName(defined$outfile ? $outfile : $file,$newDir)}$outfile=NextUnusedFilename($outfile,$infile);if ($et->Exists($outfile,1)){if ($infile eq $outfile){undef$outfile}elsif ($et->IsSameFile($infile,$outfile)){$sameFile=$outfile}else {Warn "Error: '\${outfile}' already exists - $infile\\n";EFile($infile);++$countBadWr;return 0}}}if (defined$outfile){defined$verbose and print$vout "'\${infile}' --> '\${outfile}'\\n";CreateDirectory($outfile);$tmpFile=$outfile if defined$outOpt}unless (defined$tmpFile){my ($numSet,$numPseudo)=$et->CountNewValues();if ($numSet!=$numPseudo and $et->IsDirectory($file)){print$vout "Can't write real tags to a directory - $infile\\n" if defined$verbose;$numSet=$numPseudo}if ($et->Exists($file)){unless ($numSet){print$vout "Nothing changed in $file\\n" if defined$verbose;EFile($infile,1);++$countSameWr;return 1}}elsif (CanCreate($file)){if ($numSet==$numPseudo){Warn("Error: Nothing to write - $file\\n");EFile($infile,1);++$countBadWr;return 0}unless (defined$outfile){$outfile=$file;$file=''}}else {Warn "Error: File not found - $file\\n";EFile($infile);FileNotFound($file);++$countBadWr;return 0}if ($numSet==$numPseudo){my ($r0,$r1,$r2,$r3)=(0,0,0,0);if (defined$outfile){$r0=$et->SetFileName($file,$outfile);$file=$$et{NewName}if$r0 > 0}unless ($r0 < 0){$r1=$et->SetFileModifyDate($file,undef,'FileCreateDate');$r2=$et->SetFileModifyDate($file);$r3=$et->SetSystemTags($file)}if ($r0 > 0 or $r1 > 0 or $r2 > 0 or $r3 > 0){EFile($infile,3);++$countGoodWr}elsif ($r0 < 0 or $r1 < 0 or $r2 < 0 or $r3 < 0){EFile($infile);++$countBadWr;return 0}else {EFile($infile,1);++$countSameWr}if (defined$hardLink or defined$symLink or defined$testName){DoHardLink($et,$file,$hardLink,$symLink,$testName)}return 1}if (not defined$outfile or defined$sameFile){$outfile="\${file}_exiftool_tmp";if ($et->Exists($outfile)){Warn("Error: Temporary file already exists: $outfile\\n");EFile($infile);++$countBadWr;return 0}$isTemporary=1}$tmpFile=$outfile}}my$success=$et->WriteInfo(Infile($file),$outfile,$outType);if ($success and (defined$hardLink or defined$symLink or defined$testName)){my$src=defined$outfile ? $outfile : $file;DoHardLink($et,$src,$hardLink,$symLink,$testName)}my ($aTime,$mTime,$cTime,$doPreserve);$doPreserve=$preserveTime unless$file eq '';if ($doPreserve and $success){($aTime,$mTime,$cTime)=$et->GetFileTime($file);undef$cTime if $$et{WRITTEN}{FileCreateDate};if ($$et{WRITTEN}{FileModifyDate}or $doPreserve==2){if (defined$cTime){undef$aTime;undef$mTime}else {undef$doPreserve}}}if ($success==1){if (defined$tmpFile){if ($et->Exists($file)){$et->SetFileTime($tmpFile,$aTime,$mTime,$cTime)if$doPreserve;if ($isTemporary){$et->CopyFileAttrs($file,$outfile);my$original="\${file}_original";if (not $overwriteOrig and not $et->Exists($original)){if (not $et->Rename($file,$original)or $et->Exists($file)){Error "Error renaming $file\\n";return 0}}my$dstFile=defined$sameFile ? $sameFile : $file;if ($overwriteOrig > 1){my ($err,$buff);my$newFile=$tmpFile;$et->Open(\\*NEW_FILE,$newFile)or Error("Error opening $newFile\\n"),return 0;binmode(NEW_FILE);$critical=1;undef$tmpFile;if ($et->Open(\\*ORIG_FILE,$file,'+<')){binmode(ORIG_FILE);while (read(NEW_FILE,$buff,65536)){print ORIG_FILE$buff or $err=1}close(NEW_FILE);eval {truncate(ORIG_FILE,tell(ORIG_FILE))}or $err=1;close(ORIG_FILE)or $err=1;if ($err){Warn "Couldn't overwrite in place - $file\\n";unless ($et->Rename($newFile,$file)or ($et->Unlink($file)and $et->Rename($newFile,$file))){Error("Error renaming $newFile to $file\\n");undef$critical;SigInt()if$interrupted;return 0}}else {$et->SetFileModifyDate($file,$cTime,'FileCreateDate',1);$et->SetFileModifyDate($file,$mTime,'FileModifyDate',1);$et->Unlink($newFile);if ($doPreserve){$et->SetFileTime($file,$aTime,$mTime,$cTime);$preserveTime{$file}=[$aTime,$mTime,$cTime ]}}EFile($infile,3);++$countGoodWr}else {close(NEW_FILE);Warn "Error opening $file for writing\\n";EFile($infile);$et->Unlink($newFile);++$countBadWr}undef$critical;SigInt()if$interrupted}elsif ($et->Rename($tmpFile,$dstFile)){EFile($infile,3);++$countGoodWr}else {my$newFile=$tmpFile;undef$tmpFile;if (not $et->Unlink($file)){Warn "Error renaming temporary file to $dstFile\\n";EFile($infile);$et->Unlink($newFile);++$countBadWr}elsif (not $et->Rename($newFile,$dstFile)){Warn "Error renaming temporary file to $dstFile\\n";EFile($infile);++$countBadWr}else {EFile($infile,3);++$countGoodWr}}}elsif ($overwriteOrig){EFile($infile,3);$et->Unlink($file)or Warn "Error erasing original $file\\n";++$countGoodWr}else {EFile($infile,4);++$countGoodCr}}else {EFile($infile,4);++$countGoodCr}}else {EFile($infile,3);++$countGoodWr}}elsif ($success){EFile($infile,1);if ($isTemporary){$et->Unlink($tmpFile);++$countSameWr}else {$et->SetFileTime($outfile,$aTime,$mTime,$cTime)if$doPreserve;if ($overwriteOrig){$et->Unlink($file)or Warn "Error erasing original $file\\n"}++$countCopyWr}print$vout "Nothing changed in $file\\n" if defined$verbose}else {EFile($infile);$et->Unlink($tmpFile)if defined$tmpFile;++$countBadWr}undef$tmpFile;return$success}sub DoHardLink($$$$$) {my ($et,$src,$hardLink,$symLink,$testName)=@_;if (defined$hardLink){$hardLink=NextUnusedFilename($hardLink);if ($et->SetFileName($src,$hardLink,'Link')> 0){$countLink{Hard}=($countLink{Hard}|| 0)+ 1}else {$countLink{BadHard}=($countLink{BadHard}|| 0)+ 1}}if (defined$symLink){$symLink=NextUnusedFilename($symLink);if ($et->SetFileName($src,$symLink,'SymLink')> 0){$countLink{Sym}=($countLink{Sym}|| 0)+ 1}else {$countLink{BadSym}=($countLink{BadSym}|| 0)+ 1}}if (defined$testName){$testName=NextUnusedFilename($testName,$src);if ($usedFileName{$testName}){$et->Warn("File '\${testName}' would exist")}elsif ($et->SetFileName($src,$testName,'Test',$usedFileName{$testName})==1){$usedFileName{$testName}=1;$usedFileName{$src}=0}}}sub CleanXML($) {my$strPt=shift;$$strPt =~ tr/\\0-\\x08\\x0b\\x0c\\x0e-\\x1f/./;Image::ExifTool::XMP::FixUTF8($strPt)unless$altEnc;$$strPt=Image::ExifTool::XMP::EscapeXML($$strPt)}sub EncodeXML($) {my$strPt=shift;if ($$strPt =~ /[\\0-\\x08\\x0b\\x0c\\x0e-\\x1f]/ or (not $altEnc and Image::ExifTool::IsUTF8($strPt)< 0)){$$strPt=Image::ExifTool::XMP::EncodeBase64($$strPt);return 'http://www.w3.org/2001/XMLSchema#base64Binary'}elsif ($escapeHTML){$$strPt=Image::ExifTool::HTML::EscapeHTML($$strPt,$altEnc)}else {$$strPt=Image::ExifTool::XMP::EscapeXML($$strPt)}return ''}sub FormatXML($$$) {local $_;my ($val,$ind,$grp)=@_;my$gt='>';if (ref$val eq 'ARRAY'){my$val2="\\n$ind <rdf:Bag>";for (@$val){$val2 .= "\\n$ind  <rdf:li" .FormatXML($_,"$ind  ",$grp)."</rdf:li>"}$val="$val2\\n$ind </rdf:Bag>\\n$ind"}elsif (ref$val eq 'HASH'){$gt=" rdf:parseType='Resource'>";my$val2='';for (OrderedKeys($val)){my ($ns,$tg)=($grp,$_);if (/^(.*?):(.*)/){if ($grp eq 'JSON'){$tg =~ tr/:/_/}else {($ns,$tg)=($1,$2)}}my$name;for$name ($ns,$tg){$name =~ tr/-_A-Za-z0-9.//dc;$name='_' .$name if$name !~ /^[_A-Za-z]/}my$tok=$ns .':' .$tg;$val2 .= "\\n$ind <$tok" .FormatXML($$val{$_},"$ind ",$grp)."</$tok>"}$val="$val2\\n$ind"}else {my$enc=EncodeXML(\\$val);$gt=" rdf:datatype='\${enc}'>\\n" if$enc}return$gt .$val}sub EscapeJSON($;$) {my ($str,$quote)=@_;unless ($quote){return lc($str)if$str =~ /^(true|false)$/i and $json < 2;return$str if$str =~ /^-?(\\d|[1-9]\\d{1,14})(\\.\\d{1,16})?(e[-+]?\\d{1,3})?$/i}if ($json < 2 and defined$binaryOutput and Image::ExifTool::IsUTF8(\\$str)< 0){return '"base64:' .Image::ExifTool::XMP::EncodeBase64($str,1).'"'}$str =~ s/(["\\t\\n\\r\\\\])/\\\\$jsonChar{$1}/sg;if ($json < 2){$str =~ tr/\\0//d;$str =~ s/([\\0-\\x1f\\x7f])/sprintf("\\\\u%.4X",ord $1)/sge;Image::ExifTool::XMP::FixUTF8(\\$str)unless$altEnc}else {$str =~ s/\\0+$// unless$isBinary;$str =~ s/\\$/\\\\\\$/sg;$str =~ s/([\\0-\\x1f\\x7f])/sprintf("\\\\x%.2X",ord $1)/sge}return '"' .$str .'"'}sub FormatJSON($$$;$) {local $_;my ($fp,$val,$ind,$quote)=@_;my$comma;if (not ref$val){print$fp EscapeJSON($val,$quote)}elsif (ref$val eq 'ARRAY'){if ($joinLists and not ref $$val[0]){print$fp EscapeJSON(join($listSep,@$val),$quote)}else {my ($bra,$ket)=$json==1 ? ('[',']'): ('Array(',')');print$fp $bra;for (@$val){print$fp ',' if$comma;FormatJSON($fp,$_,$ind,$quote);$comma=1,}print$fp $ket,}}elsif (ref$val eq 'HASH'){my ($bra,$ket,$sep)=$json==1 ? ('{','}',':'): ('Array(',')',' =>');print$fp $bra;for (OrderedKeys($val)){print$fp ',' if$comma;my$key=EscapeJSON($_,1);print$fp qq(\\n$ind  $key$sep );if ($showTagID and $_ eq 'id' and $showTagID eq 'H' and $$val{$_}=~ /^\\d+\\.\\d+$/){print$fp qq{"$$val{$_}"}}else {FormatJSON($fp,$$val{$_},"$ind  ",$quote)}$comma=1,}print$fp "\\n$ind$ket",}else {print$fp '"<err>"'}}sub FormatCSV($) {my$val=shift;if ($setCharset and ($val =~ /[^\\x09\\x0a\\x0d\\x20-\\x7e\\x80-\\xff]/ or ($setCharset eq 'UTF8' and Image::ExifTool::IsUTF8(\\$val)< 0))){$val='base64:' .Image::ExifTool::XMP::EncodeBase64($val,1)}$val=qq{"$val"} if$val =~ s/"/""/g or $val =~ /(^\\s+|\\s+$)/ or $val =~ /[\\n\\r]|\\Q$csvDelim/;return$val}sub PrintCSV(;$) {my$fp=shift || \\*STDOUT;my ($file,$lcTag,@tags);@csvTags or @csvTags=sort keys%csvTags;for$lcTag (@csvTags){push@tags,FormatCSV($csvTags{$lcTag})if$csvTags{$lcTag}}print$fp join($csvDelim,'SourceFile',@tags),"\\n";my$empty=defined($forcePrint)? $forcePrint : '';for$file (@csvFiles){my@vals=(FormatCSV($file));my$csvInfo=$database{$file};for$lcTag (@csvTags){next unless$csvTags{$lcTag};my$val=$$csvInfo{$lcTag};defined$val or push(@vals,$empty),next;push@vals,FormatCSV($val)}print$fp join($csvDelim,@vals),"\\n"}}sub AddGroups($$$$) {my ($val,$grp,$groupHash,$groupList)=@_;my ($key,$val2);if (ref$val eq 'HASH'){for$key (sort keys %$val){if ($key =~ /^(.*?):/ and not $$groupHash{$1}and $grp ne 'JSON'){$$groupHash{$1}=$grp;push @$groupList,$1}AddGroups($$val{$key},$grp,$groupHash,$groupList)if ref $$val{$key}}}elsif (ref$val eq 'ARRAY'){for$val2 (@$val){AddGroups($val2,$grp,$groupHash,$groupList)if ref$val2}}}sub ConvertBinary($) {my$obj=shift;my ($key,$val);if (ref$obj eq 'HASH'){for$key (keys %$obj){next unless ref $$obj{$key};$$obj{$key}=ConvertBinary($$obj{$key});return undef unless defined $$obj{$key}}}elsif (ref$obj eq 'ARRAY'){for$val (@$obj){next unless ref$val;$val=ConvertBinary($val);return undef unless defined$val}}elsif (ref$obj eq 'SCALAR'){return undef if$noBinary;if (defined$binaryOutput){$obj=$$obj;if ($json==1 and ($obj =~ /[^\\x09\\x0a\\x0d\\x20-\\x7e\\x80-\\xf7]/ or Image::ExifTool::IsUTF8(\\$obj)< 0)){$obj='base64:' .Image::ExifTool::XMP::EncodeBase64($obj,1)}}else {my$bOpt=$html ? '' : ', use -b option to extract';if ($$obj =~ /^Binary data \\d+ bytes$/){$obj="($$obj$bOpt)"}else {$obj='(Binary data ' .length($$obj)." bytes$bOpt)"}}}return$obj}sub IsEqual($$;$) {my ($a,$b,$trueScalar)=@_;return 1 if$a eq $b;if (ref$a eq 'SCALAR'){return 1 if$trueScalar;return 1 if ref$b eq 'SCALAR' and $$a eq $$b;return 0}if (ref$a eq 'HASH' and ref$b eq 'HASH'){return 0 if scalar(keys %$a)!=scalar(keys %$b);my$key;for$key (keys %$a){return 0 unless IsEqual($$a{$key},$$b{$key},$trueScalar)}}else {return 0 if ref$a ne 'ARRAY' or ref$b ne 'ARRAY' or @$a!=@$b;my$i;for ($i=0;$i<scalar(@$a);++$i){return 0 unless IsEqual($$a[$i],$$b[$i],$trueScalar)}}return 1}sub Printable($) {my$val=shift;if (ref$val){if ($structOpt){require Image::ExifTool::XMP;$val=Image::ExifTool::XMP::SerializeStruct($mt,$val)}elsif (ref$val eq 'ARRAY'){$val=join($listSep,@$val)}elsif (ref$val eq 'SCALAR'){$val='(Binary data '.length($$val).' bytes)'}}if ($escapeC){$val =~ s/([\\0-\\x1f\\\\\\x7f])/$escC{$1} || sprintf('\\x%.2x', ord $1)/eg}else {$val =~ tr/\\x01-\\x1f\\x7f/./;$val =~ s/\\x00//g;$val =~ s/\\s+$//}return$val}sub LengthUTF8($) {my$str=shift;return length$str unless$fixLen;local$SIG{'__WARN__'}=sub {};if (not $$mt{OPTIONS}{EncodeHangs}and eval {require Encode}){$str=Encode::decode_utf8($str)}else {$str=pack('U0C*',unpack 'C*',$str)}my$len;if ($fixLen==1){$len=length$str}else {my$gcstr=eval {Unicode::GCString->new($str)};if ($gcstr){$len=$gcstr->columns}else {$len=length$str;delete$SIG{'__WARN__'};Warning($mt,'Unicode::GCString problem.  Columns may be misaligned');$fixLen=1}}return$len}sub AddSetTagsFile($;$) {my ($setFile,$opts)=@_;if ($setTags{$setFile}){$setTagsList{$setFile}or $setTagsList{$setFile}=[];push @{$setTagsList{$setFile}},$setTags{$setFile}}$setTags{$setFile}=[];push@newValues,{SaveCount=>++$saveCount },"TagsFromFile=$setFile";$opts or $opts={};$$opts{ProtectSaved}=$saveCount;push @{$setTags{$setFile}},$opts}sub Infile($;$) {my ($file,$bufferStdin)=@_;if ($file eq '-' and ($bufferStdin or $rafStdin)){if ($rafStdin){$rafStdin->Seek(0)}elsif (open RAF_STDIN,'-'){$rafStdin=File::RandomAccess->new(\\*RAF_STDIN);$rafStdin->BinMode()}return$rafStdin if$rafStdin}return$file}sub Warning($$) {my ($et,$str)=@_;my$noWarn=$et->Options('NoWarning');if (not defined$noWarn or not eval {$str =~ /$noWarn/}){Warn "Warning: $str\\n"}}sub DoSetFromFile($$$) {local $_;my ($et,$file,$setTags)=@_;$verbose and print$vout "Setting new values from $file\\n";my$info=$et->SetNewValuesFromFile(Infile($file,1),@$setTags);my$numSet=scalar(keys %$info);if ($$info{Error}){my@warns=grep /^(Error|Warning)\\b/,keys %$info;$numSet -= scalar(@warns);my$err=$$info{Error};delete $$info{$_}foreach@warns;my$noWarn=$et->Options('NoWarning');$$info{Warning}=$err unless defined$noWarn and eval {$err =~ /$noWarn/}}elsif ($$info{Warning}){my$warns=1;++$warns while $$info{"Warning ($warns)"};$numSet -= $warns}PrintErrors($et,$info,$file)and EFile($file),++$countBadWr,return 0;Warning($et,"No writable tags set from $file")unless$numSet;return 1}sub CleanFilename($) {$_[0]=~ tr/\\\\/\\// if Image::ExifTool::IsPC()}sub HasWildcards($) {my$path=shift;return 0 if $^O eq 'MSWin32' and $path =~ m{^[\\\\/]{2}\\?[\\\\/]};return$path =~ /[*?]/}sub CheckUTF8($$) {my ($file,$enc)=@_;my$isUTF8=0;if ($file =~ /[\\x80-\\xff]/){$isUTF8=Image::ExifTool::IsUTF8(\\$file);if ($isUTF8 < 0){if ($enc){Warn("Invalid filename encoding for $file\\n")}elsif (not defined$enc){WarnOnce(qq{FileName encoding not specified.  Use "-charset FileName=CHARSET"\\n})}}}return$isUTF8}sub SetWindowTitle($) {my$title=shift;if ($curTitle ne $title){$curTitle=$title;if ($^O eq 'MSWin32'){$title =~ s/([&\\/\\?:|"<>])/^$1/g;eval {system qq{title $title}}}else {printf STDERR "\\033]0;%s\\007",$title}}}sub ProcessFiles($;$) {my ($et,$list)=@_;my$enc=$et->Options('CharsetFileName');my$file;for$file (@files){$et->Options(CharsetFileName=>'UTF8')if$utf8FileName{$file};if (defined$progressMax){unless (defined$progressNext){$progressNext=$progressCount + $progressIncr;$progressNext -= $progressNext % $progressIncr;$progressNext=$progressMax if$progressNext > $progressMax}++$progressCount;if ($progress){if ($progressCount >= $progressNext){$progStr=" [$progressCount/$progressMax]"}else {undef$progStr}}}if ($et->IsDirectory($file)and not $listDir){$multiFile=$validFile=1;ScanDir($et,$file,$list)}elsif ($filterFlag and not AcceptFile($file)){if ($et->Exists($file)){$filtered=1;Progress($vout,"-------- $file (wrong extension)")if$verbose}else {Error "Error: File not found - $file\\n";FileNotFound($file)}}else {$validFile=1;if ($list){push(@$list,$file)}else {if (%endDir){my ($d,$f)=Image::ExifTool::SplitFileName($file);next if$endDir{$d}}GetImageInfo($et,$file);$end and Warn("End called - $file\\n");if ($endDir){Warn("EndDir called - $file\\n");my ($d,$f)=Image::ExifTool::SplitFileName($file);$endDir{$d}=1;undef$endDir}}}$et->Options(CharsetFileName=>$enc)if$utf8FileName{$file};last if$end}}sub ScanDir($$;$) {local $_;my ($et,$dir,$list)=@_;my (@fileList,$done,$file,$utf8Name,$winSurrogate,$endThisDir);my$enc=$et->Options('CharsetFileName');if ($enc){unless ($enc eq 'UTF8'){$dir=$et->Decode($dir,$enc,undef,'UTF8');$et->Options(CharsetFileName=>'UTF8')}$utf8Name=1}return if$ignore{$dir};if ($^O eq 'MSWin32' and not HasWildcards($dir)){undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};;if (CheckUTF8($dir,$enc)>= 0){if (eval {require Win32::FindFile}){eval {@fileList=Win32::FindFile::ReadDir($dir);$_=$_->cFileName foreach@fileList};$@ and $evalWarning=$@;if ($evalWarning){chomp$evalWarning;$evalWarning =~ s/ at .*//s;Warning($et,"[Win32::FindFile] $evalWarning - $dir");$winSurrogate=1 if$evalWarning =~ /surrogate/}else {$et->Options(CharsetFileName=>'UTF8');$utf8Name=1;$done=1}}else {$done=0}}}unless ($done){unless (opendir(DIR_HANDLE,$dir)){Warn("Error opening directory $dir\\n");return}@fileList=readdir(DIR_HANDLE);closedir(DIR_HANDLE);if (defined$done){for$file ($dir,@fileList){next unless$file =~ /[\\?\\x80-\\xff]/;WarnOnce("Install Win32::FindFile to support Windows Unicode file names in directories\\n");last}}}$dir =~ /\\/$/ or $dir .= '/';for$file (@fileList){next if$file eq '.' or $file eq '..';my$path="$dir$file";if ($et->IsDirectory($path)){next unless$recurse;next if$file =~ /^\\./ and $recurse==1;next if$ignore{$file}or ($ignore{SYMLINKS}and -l $path);ScanDir($et,$path,$list);last if$end;next}next if$endThisDir;next if$ignoreHidden and $file =~ /^\\./;my$accepted;if ($filterFlag){$accepted=AcceptFile($file)or next;$accepted &= 0x01}unless ($accepted){if ($scanWritable){if ($scanWritable eq '1'){next unless CanWrite($file)}else {my$type=GetFileType($file);next unless defined$type and $type eq $scanWritable}}elsif (not GetFileType($file)){next unless$doUnzip;next unless$file =~ /\\.(gz|bz2)$/i}}if ($winSurrogate and $isWriting and (not $overwriteOrig or $overwriteOrig!=2)and not $doSetFileName and $file =~ /~/){Warn("Not writing $path\\n");WarnOnce("Use -overwrite_original_in_place to write files with Unicode surrogate characters\\n");EFile($file);++$countBad;next}$utf8FileName{$path}=1 if$utf8Name;if ($list){push(@$list,$path)}else {GetImageInfo($et,$path);if ($end){Warn("End called - $file\\n");last}if ($endDir){$path =~ s(/$)();Warn("EndDir called - $path\\n");$endDir{$path}=1;$endThisDir=1;undef$endDir}}}++$countDir;$et->Options(CharsetFileName=>$enc)}sub FindFileWindows($$) {my ($et,$wildfile)=@_;my$enc=$et->Options('CharsetFileName');$wildfile=$et->Decode($wildfile,$enc,undef,'UTF8')if$enc and $enc ne 'UTF8';CleanFilename($wildfile);my ($dir,$wildname)=($wildfile =~ m{(.*[:/])(.*)})? ($1,$2): ('',$wildfile);if (HasWildcards($dir)){Warn "Wildcards don't work in the directory specification\\n";return ()}CheckUTF8($wildfile,$enc)>= 0 or return ();undef$evalWarning;local$SIG{'__WARN__'}=sub {$evalWarning=$_[0]};my@files;eval {my@names=Win32::FindFile::FindFile($wildfile)or return;@names=sort {uc($a)cmp uc($b)}@names;my ($rname,$nm);($rname=quotemeta$wildname)=~ s/\\\\\\?/./g;$rname =~ s/\\\\\\*/.*/g;for$nm (@names){$nm=$nm->cFileName;next unless$nm =~ /^$rname$/i;next if$nm eq '.' or $nm eq '..';my$file="$dir$nm";push@files,$file;$utf8FileName{$file}=1}};$@ and $evalWarning=$@;if ($evalWarning){chomp$evalWarning;$evalWarning =~ s/ at .*//s;Warn "Error: [Win32::FindFile] $evalWarning - $wildfile\\n";undef@files;EFile($wildfile);++$countBad}return@files}sub FileNotFound($) {my$file=shift;if ($file =~ /^(DIR|FILE)$/){my$type={DIR=>'directory',FILE=>'file' }->{$file};Warn qq{You were meant to enter any valid $type name, not "$file" literally.\\n}}}sub PreserveTime() {local $_;$mt->SetFileTime($_,@{$preserveTime{$_}})foreach keys%preserveTime;undef%preserveTime}sub AbsPath($) {my$file=shift;my$path;if (defined$file){return undef if$file eq '*';if ($^O eq 'MSWin32' and $mt->Options('WindowsLongPath')){$path=$mt->WindowsLongPath($file)}elsif (eval {require Cwd}){local$SIG{'__WARN__'}=sub {};$path=eval {Cwd::abs_path($file)}}CleanFilename($path)if defined$path}return$path}sub MyConvertFileName($$) {my ($et,$file)=@_;my$enc=$et->Options('CharsetFileName');$et->Options(CharsetFileName=>'UTF8')if$utf8FileName{$file};my$convFile=$et->ConvertFileName($file);$et->Options(CharsetFileName=>$enc)if$utf8FileName{$file};return$convFile}sub AddPrintFormat($) {my$expr=shift;my$type;if ($expr =~ /^#/){$expr =~ s/^#\\[(HEAD|SECT|IF|BODY|ENDS|TAIL)\\]// or return;$type=$1}else {$type='BODY'}$printFmt{$type}or $printFmt{$type}=[];push @{$printFmt{$type}},$expr;push@requestTags,$expr =~ /\\$\\{?((?:[-_0-9A-Z]+:)*[-_0-9A-Z?*]+)/ig;$printFmt{SetTags}=1 if$expr =~ /\\bSetTags\\b/}sub SuggestedExtension($$$) {my ($et,$valPt,$tag)=@_;my$ext;if (not $binaryOutput){$ext='txt'}elsif ($$valPt =~ /^\\xff\\xd8\\xff/){$ext='jpg'}elsif ($$valPt =~ /^(\\0\\0\\0\\x0cjP(  |\\x1a\\x1a)\\x0d\\x0a\\x87\\x0a|\\xff\\x4f\\xff\\x51\\0)/){$ext='jp2'}elsif ($$valPt =~ /^(\\x89P|\\x8aM|\\x8bJ)NG\\r\\n\\x1a\\n/){$ext='png'}elsif ($$valPt =~ /^GIF8[79]a/){$ext='gif'}elsif ($$valPt =~ /^<\\?xpacket/ or $tag eq 'XMP'){$ext='xmp'}elsif ($$valPt =~ /^<\\?xml/ or $tag eq 'XML'){$ext='xml'}elsif ($$valPt =~ /^RIFF....WAVE/s){$ext='wav'}elsif ($tag eq 'OriginalRawImage' and defined($ext=$et->GetValue('OriginalRawFileName'))){$ext =~ s/^.*\\.//s;$ext=$ext ? lc($ext): 'raw'}elsif ($tag eq 'EXIF'){$ext='exif'}elsif ($tag eq 'ICC_Profile'){$ext='icc'}elsif ($$valPt =~ /^(MM\\0\\x2a|II\\x2a\\0)/){$ext='tiff'}elsif ($$valPt =~ /^.{4}ftyp(3gp|mp4|f4v|qt  )/s){my%movType=('qt  '=>'mov');$ext=$movType{$1}|| $1}elsif ($$valPt =~ /^<(!DOCTYPE )?html/i){$ext='html'}elsif ($$valPt =~ /^[\\n\\r]*\\{[\\n\\r]*\\\\rtf/){$ext='rtf'}elsif ($$valPt !~ /^.{0,4096}\\0/s){$ext='txt'}elsif ($$valPt =~ /^BM.{15}\\0/s){$ext='bmp'}elsif ($$valPt =~ /^CANON OPTIONAL DATA\\0/){$ext='vrd'}elsif ($$valPt =~ /^IIII\\x04\\0\\x04\\0/){$ext='dr4'}elsif ($$valPt =~ /^(.{10}|.{522})(\\x11\\x01|\\x00\\x11)/s){$ext='pict'}elsif ($$valPt =~ /^\\xff\\x0a|\\0\\0\\0\\x0cJXL \\x0d\\x0a......ftypjxl/s){$ext='jxl'}elsif ($$valPt =~ /^.{4}jumb\\0.{3}jumdc2pa/s){$ext='c2pa'}elsif ($tag eq 'JUMBF'){$ext='jumbf'}else {$ext='dat'}return$ext}sub LoadPrintFormat($;$) {my ($arg,$noNL)=@_;if (not defined$arg){Error "Must specify file or expression for -p option\\n"}elsif ($arg !~ /\\n/ and -f $arg and $mt->Open(\\*FMT_FILE,$arg)){for (<FMT_FILE>){AddPrintFormat($_)}close(FMT_FILE)}else {$arg .= "\\n" unless$noNL;AddPrintFormat($arg)}}sub FilenameSPrintf($;$@) {my ($fmt,$file,@extra)=@_;local $_;return$fmt unless$fmt =~ /%[-+]?\\d*[.:]?\\d*[lu]?[dDfFeEtgso]/;return undef unless defined$file;CleanFilename($file);my%part;@part{qw(d f E)}=($file =~ /^(.*?)([^\\/]*?)(\\.[^.\\/]*)?$/);defined$part{f}or Warn("Error: Bad pattern match for file $file\\n"),return undef;if ($part{E}){$part{e}=substr($part{E},1)}else {@part{qw(e E)}=('','')}$part{F}=$part{f}.$part{E};($part{D}=$part{d})=~ s{/+$}{};@part{qw(t g s o)}=@extra;my ($filename,$pos)=('',0);while ($fmt =~ /(%([-+]?)(\\d*)([.:]?)(\\d*)([lu]?)([dDfFeEtgso]))/g){$filename .= substr($fmt,$pos,pos($fmt)- $pos - length($1));$pos=pos($fmt);my ($sign,$wid,$dot,$skip,$mod,$code)=($2,$3,$4,$5 || 0,$6,$7);my (@path,$part,$len,$groups);if (lc$code eq 'd' and $dot and $dot eq ':'){@path=split '/',$part{$code};$len=scalar@path}else {if ($code eq 'g'){$groups=$part{g}|| []unless defined$groups;$fmt =~ /\\G(\\d?)/g;$part{g}=$$groups[$1 || 0];$pos=pos($fmt)}$part{$code}='' unless defined$part{$code};$len=length$part{$code}}next unless$skip < $len;$wid=$len - $skip if$wid eq '' or $wid + $skip > $len;$skip=$len - $wid - $skip if$sign eq '-';if (@path){$part=join('/',@path[$skip..($skip+$wid-1)]);$part .= '/' unless$code eq 'D'}else {$part=substr($part{$code},$skip,$wid)}$part=($mod eq 'u')? uc($part): lc($part)if$mod;$filename .= $part}$filename .= substr($fmt,$pos);$filename =~ s{(?!^)//}{/}g;return$filename}sub Num2Alpha($) {my$num=shift;my$alpha=chr(97 + ($num % 26));while ($num >= 26){$num=int($num / 26)- 1;$alpha=chr(97 + ($num % 26)).$alpha}return$alpha}sub NextUnusedFilename($;$) {my ($fmt,$okfile)=@_;return$fmt unless$fmt =~ /%[-+]?\\d*[.:]?\\d*[lun]?[cC]/;my%sep=('-'=>'-','+'=>'_');my ($copy,$alpha)=(0,'a');my$lastFile;for (;;){my ($filename,$pos)=('',0);while ($fmt =~ /(%([-+]?)(\\d*)([.:]?)(\\d*)([lun]?)([cC]))/g){$filename .= substr($fmt,$pos,pos($fmt)- $pos - length($1));$pos=pos($fmt);my ($sign,$wid,$dec,$wid2,$mod,$tok)=($2,$3 || 0,$4,$5 || 0,$6,$7);my$seq;if ($tok eq 'C'){$sign eq '-' ? ++$seqFileDir : ++$seqFileNum if$copy and $dec eq ':';$seq=$wid + ($sign eq '-' ? $seqFileDir : $seqFileNum)- 1;$wid=$wid2}else {next unless$dec or $copy;$wid=$wid2 if$wid < $wid2;$filename .= $sep{$sign}if$sign}if ($mod and $mod ne 'n'){my$a=$tok eq 'C' ? Num2Alpha($seq): $alpha;my$str=($wid and $wid > length$a)? 'a' x ($wid - length($a)): '';$str .= $a;$str=uc$str if$mod eq 'u';$filename .= $str}else {my$c=$tok eq 'C' ? $seq : $copy;my$num=$c + ($mod ? 1 : 0);$filename .= $wid ? sprintf("%.\${wid}d",$num): $num}}$filename .= substr($fmt,$pos);return$filename unless ($mt->Exists($filename,1)and not defined$usedFileName{$filename})or $usedFileName{$filename};if (defined$okfile){return$filename if$filename eq $okfile;my ($fn,$ok)=(AbsPath($filename),AbsPath($okfile));return$okfile if defined$fn and defined$ok and $fn eq $ok}return$filename if defined$lastFile and $lastFile eq $filename;$lastFile=$filename;++$copy;++$alpha}}sub CreateDirectory($) {my$file=shift;my$err=$mt->CreateDirectory($file);if (defined$err){$err and Error("$err\\n"),return 0;if ($verbose){my$dir;($dir=$file)=~ s(/[^/]*$)();print$vout "Created directory $dir\\n"}++$countNewDir;return 1}return 0}sub OpenOutputFile($;@) {my ($file,@args)=@_;my ($fp,$outfile,$append);if ($textOut){$outfile=$file;CleanFilename($outfile);if ($textOut =~ /%[-+]?\\d*[.:]?\\d*[lun]?[dDfFeEtgsocC]/ or defined$tagOut){$outfile=FilenameSPrintf($textOut,$file,@args);return ()unless defined$outfile;$outfile=NextUnusedFilename($outfile);CreateDirectory($outfile)}else {$outfile =~ s/\\.[^.\\/]*$//;$outfile .= $textOut}my$mode='>';if ($mt->Exists($outfile,1)){unless ($textOverwrite){Warn "Output file $outfile already exists for $file\\n";return ()}if ($textOverwrite==2 or ($textOverwrite==3 and $created{$outfile})){$mode='>>';$append=1}}unless ($mt->Open(\\*OUTFILE,$outfile,$mode)){my$what=$mode eq '>' ? 'creating' : 'appending to';Error("Error $what $outfile\\n");return ()}binmode(OUTFILE)if$binaryOutput;$fp=\\*OUTFILE}else {$fp=\\*STDOUT}return($fp,$outfile,$append)}sub AcceptFile($) {my$file=shift;my$ext=($file =~ /^.*\\.(.+)$/s)? uc($1): '';return$filterExt{$ext}if defined$filterExt{$ext};return$filterExt{'*'}if defined$filterExt{'*'};return 0 if$filterFlag & 0x02;return 2}sub SlurpFile($$) {my ($file,$buffPt)=@_;$mt->Open(\\*INFILE,$file)or Warn("Error opening file $file\\n"),return 0;binmode(INFILE);undef $$buffPt;my$bsize=1024 * 1024;my$num=read(INFILE,$$buffPt,$bsize);unless (defined$num){close(INFILE);Warn("Error reading $file\\n");return 0}my$bmax=64 * $bsize;while ($num==$bsize){$bsize *= 2 if$bsize < $bmax;my$buff;$num=read(INFILE,$buff,$bsize);last unless$num;$$buffPt .= $buff}close(INFILE);return 1}sub FilterArgfileLine($) {my$arg=shift;if ($arg =~ /^#/){return undef unless$arg =~ s/^#\\[CSTR\\]//;$arg =~ s/[\\x0d\\x0a]+$//s;$arg =~ s{\\\\(.)|(["\\$\\@]|\\\\$)}{'\\\\'.($2 || $1)}sge;my%esc=(a=>"\\a",b=>"\\b",f=>"\\f",n=>"\\n",r=>"\\r",t=>"\\t",'"'=>'"','\\\\'=>'\\\\');$arg =~ s/\\\\(.)/$esc{$1}||'\\\\'.$1/egs}else {$arg =~ s/^\\s+//;$arg =~ s/[\\x0d\\x0a]+$//s;$arg =~ s/^(-[-_0-9A-Z:]+#?)\\s*([-+<]?=) ?/$1$2/i;return undef if$arg eq ''}return$arg}sub ReadStayOpen($) {my$args=shift;my (@newArgs,$processArgs,$result,$optArgs);my$lastOpt='';my$unparsed=length$stayOpenBuff;for (;;){if ($unparsed){$result=$unparsed;undef$unparsed}else {$result=sysread(STAYOPEN,$stayOpenBuff,65536,length($stayOpenBuff))}if ($result){my$pos=0;while ($stayOpenBuff =~ /\\n/g){my$len=pos($stayOpenBuff)- $pos;my$arg=substr($stayOpenBuff,$pos,$len);$pos += $len;$arg=FilterArgfileLine($arg);next unless defined$arg;push@newArgs,$arg;if ($optArgs){undef$optArgs;next unless$lastOpt eq '-stay_open' or $lastOpt eq '-@'}else {$lastOpt=lc$arg;$optArgs=$optArgs{$arg};unless (defined$optArgs){$optArgs=$optArgs{$lastOpt};$optArgs=$optArgs{"$1#$2"}if not defined$optArgs and $lastOpt =~ /^(.*?)\\d+(!?)$/}next unless$lastOpt =~ /^-execute\\d*$/}$processArgs=1;last}next unless$pos;$stayOpenBuff=substr($stayOpenBuff,$pos);if ($processArgs){unshift @$args,@newArgs;last}}elsif ($result==0){select(undef,undef,undef,0.01)}else {Warn "Error reading from ARGFILE\\n";close STAYOPEN;$stayOpen=0;last}}}sub EFile($$) {my$entry=shift;my$efile=$efile[shift || 0];if (defined$efile and length$entry and $entry ne '-'){my$err;CreateDirectory($efile);if ($mt->Open(\\*EFILE_FILE,$efile,'>>')){print EFILE_FILE$entry,"\\n" or Warn("Error writing to $efile\\n"),$err=1;close EFILE_FILE}else {Warn("Error opening '\${efile}' for append\\n");$err=1}if ($err){defined $_ and $_ eq $efile and undef $_ foreach@efile}}}sub Progress($$) {my ($file,$msg)=@_;if (defined$progStr){print$file $msg,$progStr,"\\n";undef$progressNext if defined$progressMax}}sub PrintTagList($@) {my$msg=shift;print$msg,":\\n" unless$quiet;my$tag;if (($outFormat < 0 or $verbose)and $msg =~ /file extensions$/ and @_){for$tag (@_){printf("  %-11s %s\\n",$tag,GetFileType($tag,1))}return}my ($len,$pad)=(0,$quiet ? '' : '  ');for$tag (@_){my$taglen=length($tag);if ($len + $taglen > 77){print "\\n";($len,$pad)=(0,$quiet ? '' : '  ')}print$pad,$tag;$len += $taglen + 1;$pad=' '}@_ or print$pad,'[empty list]';print "\\n"}sub PrintErrors($$$) {my ($et,$info,$file)=@_;my ($tag,$key);for$tag (qw(Warning Error)){next unless $$info{$tag};my@keys=($tag);push@keys,sort(grep /^$tag /,keys %$info)if$et->Options('Duplicates');for$key (@keys){Warn "$tag: $info->{$key} - $file\\n"}}return $$info{Error}}`;class ls{parts;constructor(t=""){this.parts=t?[t]:[]}append(t){return this.parts.push(t),this}clear(){return this.parts=[],this}appendLine(t=""){return this.parts.push(`${t}
`),this}get length(){return this.toString().length}toString(){return this.parts.join("")}static isMultiline(t){let i=0;for(let r=0;r<t.length;r++)(t[r]===`
`||t[r]==="\r"&&(r===t.length-1||t[r+1]!==`
`))&&i++;return i>0}}var Xr=null,Kr=null,ki=new ls,qi=new ls,Yr=new TextDecoder;async function Ea(e){let t=Xr?.deref(),i=Kr?.deref();return t&&i?{perl:t,fileSystem:i}:(i=new ar({"/":""}),i.addFile("/exiftool",Fa),t=await fi.create({fileSystem:i,stdout:r=>{let n=typeof r=="string"?r:Yr.decode(r);ki.append(n)},stderr:r=>{let n=typeof r=="string"?r:Yr.decode(r);qi.append(n)},fetch:e}),Xr=new WeakRef(t),Kr=new WeakRef(i),{perl:t,fileSystem:i})}function Sa(e,t){for(let i of t)try{e.removeFile(i)}catch{}}async function Ta(e,t={}){let{perl:i,fileSystem:r}=await Ea(t.fetch),n=[];ki.clear(),qi.clear(),await i.reset();try{let s=`/${e.name}`;e instanceof File?r.addFile(s,e):r.addFile(s,e.data),n.push(s);let o=[...t.args||[]];if(t.config){let c=`/${t.config.name}`;t.config instanceof File?r.addFile(c,t.config):r.addFile(c,t.config.data),n.push(c),o.push("-config",c)}o.push(s);let l=await i.runFile("/exiftool",o);i.flush();let a=qi.toString(),p=ki.toString();if(!l.success||l.exitCode!==0)return{success:!1,data:void 0,error:i.getLastError()||a||"Unknown error",exitCode:l.exitCode};if(a&&a.trim())return{success:!1,data:void 0,error:a,exitCode:0};if(!p||!p.trim())return{success:!1,data:void 0,error:"No output data from ExifTool",exitCode:0};let f;return t.transform?f=t.transform(p):f=p,{success:!0,data:f,exitCode:0}}finally{Sa(r,n)}}const Oa={saturation:0,hue:2,high_low_key:4,contrast:6,contrast_highlight:8,contrast_shadow:10,sharpness:12,shading:18,clarity:20,grain_effect:38,toning:26,filter_effect:34,filter_effect_red:35,filter_effect_green:36,filter_effect_blue:37,hdr_tone_level:32,hdr_toning:30,color_tone:42,retro_toning:16,bleach_bypass_toning:28},Ia=["filter_effect","filter_effect_red","filter_effect_green","filter_effect_blue","hdr_tone_level","hdr_toning","color_tone","bleach_bypass_toning"],Ca={grain_effect:{1:3,3:2,5:1,0:0}},Aa=["saturation","hue","high_low_key","contrast","contrast_highlight","contrast_shadow","sharpness","toning","retro_toning","bleach_bypass_toning","shading","clarity","grain_effect","filter_effect","filter_effect_red","filter_effect_green","filter_effect_blue","hdr_toning","hdr_tone_level","color_tone"],Da=async e=>{const i=await Ta(e,{args:["-U","-Pentax_0x0247","-WhiteBalance","-WBShiftAB","-WBShiftGM","-ImageTone","-ColorTemperature","-PeripheralIlluminationCorr","-ShadowCorrection","-DynamicRangeExpansion","-b","-json"]});if(!i.data)throw new Error("No valid EXIF data found for the file.");const r=JSON.parse(i.data);if(r.length===0||!r[0].Pentax_0x0247)throw new Error("No valid EXIF data found for the file.");const n=r[0].Pentax_0x0247.replace("base64:",""),s=Pa(n),o=Na(s.buffer);return{props:{image_control:r[0].ImageTone,white_balance:r[0].WhiteBalance,wb_shift_ab:r[0].WBShiftAB,wb_shift_gm:r[0].WBShiftGM,color_temperature:r[0].ColorTemperature,image_control_settings:o,peripheral_illumination_correction:r[0].PeripheralIlluminationCorr,shadow_correction:r[0].ShadowCorrection,dynamic_range_expansion:r[0].DynamicRangeExpansion}}};function Pa(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))}function Na(e){const t=new DataView(e),i={};for(const r of Aa){const n=Oa[r],s=t.getUint8(n);let o=0;!Ia.includes(r)&&(o=t.getUint8(n+1));const a=Ra(s,o);if(a!==null){const p=Ca[r];p?i[r]=p[a]:i[r]=a}else console.warn(`Invalid control byte for ${r}: ${o}`)}return i}function Ra(e,t){return t===255?e-256:t===0?e:null}const Wa={class:"file-list-container",tabindex:"0"},La={class:"empty-state-content"},ka={class:"file-input"},qa={key:1,class:"active-state"},Ga={class:"top-bar"},Ua={class:"file-input"},Va={class:"panels-container"},Ma={class:"file-list"},Ba={class:"files-list"},za=["onClick"],Ha={class:"file-info"},ja={class:"file-preview"},Xa={key:0,class:"preview-loading"},Ka=["src"],Ya={key:1,class:"preview-placeholder"},Ja={class:"file-type"},Za={class:"file-size"},Qa={key:0,class:"file-dimensions"},e$={class:"file-name-container"},t$={class:"file-details-container"},i$={class:"file-name"},r$={class:"file-metadata"},n$={class:"file-size"},s$={key:0,class:"file-dimensions"},o$={class:"status-container"},l$={key:0,class:"spinner"},a$=["title"],$$=["onClick"],f$={key:0,class:"selected-preview-container"},u$=["src","alt"],d$={class:"file-details"},c$={class:"details-content"},p$={key:0,class:"no-selection"},m$={class:"detail-item"},g$={key:0,class:"loading-container"},h$={key:1,class:"error-container"},y$={class:"error-message"},x$={key:2,class:"extracted-data"},_$=tr({__name:"FileList",setup(e){const t=jt([]),i=jt(null),r=d=>{if(!(t.value.length===0||!i.value)&&(d.key==="ArrowDown"||d.key==="ArrowUp")){d.preventDefault();let g=t.value.indexOf(i.value);d.key==="ArrowDown"?g++:g--,g<0?g=0:g>=t.value.length&&(g=t.value.length-1),s(t.value[g])}},n=async d=>new Promise(g=>{const F=URL.createObjectURL(d);d.originalUrl=F;const _=new Image;_.onload=()=>{d.dimensions={width:_.naturalWidth,height:_.naturalHeight};const D=document.createElement("canvas"),W=300;let C=_.width,P=_.height;C>P?C>W&&(P=Math.round(P*W/C),C=W):P>W&&(C=Math.round(C*W/P),P=W),D.width=C,D.height=P,D.getContext("2d")?.drawImage(_,0,0,C,P),D.toBlob(G=>{if(G){const H=URL.createObjectURL(G);g(H)}else g(F)},"image/jpeg",.8)},_.src=F}),s=d=>{i.value=d,En(()=>{document.querySelector(".file-item-selected")?.scrollIntoView({behavior:"smooth",block:"nearest"})}),!d.extractedData&&!d.isLoading&&(d.isLoading=!0,t.value=[...t.value],Da(d).then(g=>{d.extractedData=g,d.isLoading=!1,d.error=void 0,t.value=[...t.value]}).catch(g=>{console.error("Error extracting data:",g),d.isLoading=!1,d.error=g.message||"Failed to extract data",t.value=[...t.value]}))},o=async d=>{const g=d.target;if(g.files){const F=Array.from(g.files);F.forEach(_=>{_.isPreviewLoading=!0}),t.value.push(...F);for(const _ of F)try{_.preview=await n(_)}finally{_.isPreviewLoading=!1,t.value=[...t.value]}}g.value=""},l=d=>{const g=t.value.indexOf(d);t.value.indexOf(i.value),d.preview&&URL.revokeObjectURL(d.preview),d.originalUrl&&URL.revokeObjectURL(d.originalUrl),t.value.splice(g,1),i.value===d&&(i.value=null)},a=d=>{if(d===0)return"0 Bytes";const g=1024,F=["Bytes","KB","MB","GB"],_=Math.floor(Math.log(d)/Math.log(g));return parseFloat((d/Math.pow(g,_)).toFixed(2))+" "+F[_]},p=async d=>{d.preventDefault(),d.stopPropagation();const g=new DataTransfer;Array.from(d.dataTransfer?.files||[]).filter(_=>_.type.startsWith("image/")).forEach(_=>g.items.add(_)),await o({target:{files:g.files}}),m()},f=d=>{d.preventDefault(),d.stopPropagation(),h()},c=d=>{d.preventDefault(),d.stopPropagation(),m()},h=()=>{const d=document.querySelector(".empty-state, .files-container");d&&d.classList.add("drag-over")},m=()=>{const d=document.querySelector(".empty-state, .files-container");d&&d.classList.remove("drag-over")};return ir(()=>{window.addEventListener("keydown",r)}),rr(()=>{window.removeEventListener("keydown",r)}),(d,g)=>(Z(),Q("div",Wa,[t.value.length===0?(Z(),Q("div",{key:0,class:"empty-state",onDrop:p,onDragover:f,onDragleave:c},[O("div",La,[O("div",ka,[g[1]||(g[1]=O("label",{for:"file-upload",class:"file-label"},"Add images",-1)),O("input",{type:"file",id:"file-upload",multiple:"",accept:"image/*",onChange:o,class:"file-input-hidden"},null,32)]),g[2]||(g[2]=O("p",{class:"empty-state-text"},"Drag and drop images here or click to browse",-1))])],32)):(Z(),Q("div",qa,[O("div",Ga,[O("div",Ua,[g[3]||(g[3]=O("label",{for:"file-upload-more",class:"file-label"},"Add more images",-1)),O("input",{type:"file",id:"file-upload-more",multiple:"",accept:"image/*",onChange:o,class:"file-input-hidden"},null,32)])]),O("div",Va,[O("div",Ma,[O("div",{class:"files-container",onDrop:p,onDragover:f,onDragleave:c},[O("ul",Ba,[(Z(!0),Q(ye,null,Pn(t.value,(F,_)=>(Z(),Q("li",{key:_,class:he(["file-item",{"file-item-selected":i.value===F}]),onClick:D=>s(F)},[O("div",Ha,[O("div",ja,[F.isPreviewLoading?(Z(),Q("div",Xa,g[4]||(g[4]=[O("div",{class:"preview-spinner"},null,-1)]))):(Z(),Q(ye,{key:1},[F.preview?(Z(),Q("img",{key:0,src:F.preview,alt:"Preview",class:"preview-image"},null,8,Ka)):(Z(),Q("div",Ya,[O("span",Ja,ie(F.type||"Unknown type"),1),O("span",Za,ie(a(F.size)),1),F.dimensions?(Z(),Q("span",Qa,ie(F.dimensions.width)+""+ie(F.dimensions.height),1)):it("",!0)]))],64))]),O("div",e$,[O("div",t$,[O("span",i$,ie(F.name),1),O("div",r$,[O("span",n$,ie(a(F.size)),1),F.dimensions?(Z(),Q("span",s$,ie(F.dimensions.width)+""+ie(F.dimensions.height),1)):it("",!0)])]),O("div",o$,[F.isLoading?(Z(),Q("div",l$)):it("",!0),O("div",{class:he(["extraction-status",[F.isLoading?"loading":F.error?"error":F.extractedData?"extracted":"not-extracted"]]),title:F.error?"Error extracting data":F.extractedData?"Data extracted":F.isLoading?"Extracting data...":"Data not extracted"},null,10,a$)])])]),O("button",{onClick:Al(D=>l(F),["stop"]),class:"remove-button"},"Remove",8,$$)],10,za))),128))])],32),i.value&&(i.value.originalUrl||i.value.preview)?(Z(),Q("div",f$,[O("img",{src:i.value.originalUrl||i.value.preview,alt:i.value.name,class:"selected-preview-image"},null,8,u$)])):it("",!0)]),O("div",d$,[O("div",c$,[i.value===null?(Z(),Q("div",p$,g[5]||(g[5]=[O("p",null,"Select a file to view its details",-1)]))):(Z(),Q(ye,{key:1},[O("p",m$,ie(i.value.name),1),i.value.isLoading?(Z(),Q("div",g$,g[6]||(g[6]=[O("div",{class:"spinner"},null,-1),O("p",null,"Extracting data from image...",-1)]))):i.value.error?(Z(),Q("div",h$,[g[7]||(g[7]=O("div",{class:"error-icon"},"!",-1)),O("p",y$,ie(i.value.error),1),O("button",{class:"retry-button",onClick:g[0]||(g[0]=F=>s(i.value))},"Try Again")])):i.value.extractedData?(Z(),Q("div",x$,[Fe(na,{data:i.value.extractedData},null,8,["data"])])):it("",!0)],64))])])])]))]))}}),v$=rs(_$,[["__scopeId","data-v-dcb1973b"]]),b$={class:"app-container"},w$={class:"app-main"},F$=tr({__name:"App",setup(e){return(t,i)=>(Z(),Q("div",b$,[i[0]||(i[0]=Jo('<header class="app-header"><h1><span class="main-title">R3</span><span class="subtitle"><span class="emphasis">R</span>icoh <span class="emphasis">R</span>ecipe <span class="emphasis">R</span>eader</span></h1></header>',1)),O("main",w$,[Fe(v$)]),i[1]||(i[1]=O("footer",{class:"footer"},[O("a",{href:"https://github.com/ovibobi/ricoh-recipe-decoder",target:"_blank",rel:"noopener noreferrer"},"View on GitHub")],-1))]))}});await fi.create({fetch:()=>fetch("/zeroperl.wasm"),stdout:e=>console.log(e)});const as=Nl(F$);as.use(kl());as.mount("#app");
